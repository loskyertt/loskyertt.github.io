<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python 爬虫教程 02</title>
    <url>/2024/10/17/02Python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="1-测试网址"><a href="#1-测试网址" class="headerlink" title="1.测试网址"></a>1.测试网址</h1><p><a class="link"   href="https://www.spiderbuf.cn/list" >测试网站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="2-编写代码"><a href="#2-编写代码" class="headerlink" title="2.编写代码"></a>2.编写代码</h1><h2 id="2-1-代码示例"><a href="#2-1-代码示例" class="headerlink" title="2.1 代码示例"></a>2.1 代码示例</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://spiderbuf.cn/playground/s01&quot;</span></span><br><span class="line"></span><br><span class="line">html = requests.get(url=url).text</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/01course/01.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">f.write(html)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(html)</span></span><br><span class="line">root = etree.HTML(html)</span><br><span class="line">trs = root.xpath(<span class="string">&#x27;//tr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/01course/data01.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">    tds = tr.xpath(<span class="string">&#x27;./td&#x27;</span>)</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> td <span class="keyword">in</span> tds:</span><br><span class="line">        <span class="comment"># 这里加 str 是为了防止 &lt;td&gt;&lt;/td&gt; 之间是空数据</span></span><br><span class="line">        s = s + <span class="built_in">str</span>(td.text) + <span class="string">&#x27; | &#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    <span class="comment"># 保存解析到的数据到本地</span></span><br><span class="line">    <span class="keyword">if</span> s!= <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        f.write(s + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>在很多时候，建议先把请求到的网页内容保存到本地（如上面代码所示），因为有时候解析数据无法一次性解析成功，那就会再向网页发送请求，这样不断的去访问服务器，就容易被服务器检测到是爬虫。</p>
<h1 id="3-lxml-基础使用"><a href="#3-lxml-基础使用" class="headerlink" title="3.lxml 基础使用"></a>3.lxml 基础使用</h1><h2 id="3-1-XPath-基本语法"><a href="#3-1-XPath-基本语法" class="headerlink" title="3.1 XPath 基本语法"></a>3.1 XPath 基本语法</h2><ul>
<li><code>/</code>：从根节点选择。根节点是一个 XML 或 HTML 文档的最顶层节点，所有其他元素都是它的子节点。</li>
<li><code>//</code>：选择文档中的所有符合条件的节点，不论它们在文档的什么位置。</li>
<li><code>.</code>：当前节点。</li>
<li><code>..</code>：父节点。</li>
<li><code>@</code>：选择属性。</li>
<li><code>[ ]</code>：筛选器，添加条件。</li>
<li><code>text()</code>：选择文本节点。</li>
</ul>
<h2 id="3-2-示例说明"><a href="#3-2-示例说明" class="headerlink" title="3.2 示例说明"></a>3.2 示例说明</h2><p>假设有如下 HTML 结构，<code>&lt;html&gt;</code>是根节点：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;status&quot;</span>&gt;</span>在线<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;status&quot;</span>&gt;</span>离线<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>456<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;status&quot;</span>&gt;</span>在线<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>789<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="3-3-使用-XPath-提取数据"><a href="#3-3-使用-XPath-提取数据" class="headerlink" title="3.3 使用 XPath 提取数据"></a>3.3 使用 XPath 提取数据</h2><ol>
<li><strong>提取所有行的 <code>&lt;td&gt;</code> 内容：</strong></li>
</ol>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">root = etree.HTML(html)</span><br><span class="line">trs = root.xpath(<span class="string">&#x27;//tr&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><code>//tr</code> 表示选择文档中所有的 <code>&lt;tr&gt;</code> 节点，不论它们在文档的哪个层级。</p>
<ol start="2">
<li><strong>提取某个特定列的数据：</strong></li>
</ol>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">status_list = root.xpath(<span class="string">&#x27;//td[@class=&quot;status&quot;]/text()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(status_list)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>//td[@class=&quot;status&quot;]</code>：选择所有 class 为 “status” 的 <code>&lt;td&gt;</code> 节点。</li>
<li><code>/text()</code>：选择这些节点的文本内容。</li>
</ul>
<p><strong>结果：</strong></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;在线&#x27;</span>, <span class="string">&#x27;离线&#x27;</span>, <span class="string">&#x27;在线&#x27;</span>]</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>结合 <code>for</code> 循环逐行提取多个列的内容：</strong></li>
</ol>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">trs = root.xpath(<span class="string">&#x27;//tr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">    status = tr.xpath(<span class="string">&#x27;./td[@class=&quot;status&quot;]/text()&#x27;</span>)[<span class="number">0</span>]  <span class="comment"># 获取状态</span></span><br><span class="line">    number = tr.xpath(<span class="string">&#x27;./td[2]/text()&#x27;</span>)[<span class="number">0</span>]  <span class="comment"># 获取数字</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;状态: <span class="subst">&#123;status&#125;</span>, 数字: <span class="subst">&#123;number&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>./td[@class=&quot;status&quot;]/text()</code>：从当前行的 <code>&lt;td&gt;</code> 中选择 class 为 “status” 的列。</li>
<li><code>./td[2]/text()</code>：选择当前行的第二个 <code>&lt;td&gt;</code> 节点的文本内容。</li>
</ul>
<p><strong>输出：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">状态: 在线, 数字: 123</span><br><span class="line">状态: 离线, 数字: 456</span><br><span class="line">状态: 在线, 数字: 789</span><br></pre></td></tr></table></figure></div>

<h2 id="3-4-XPath-实用技巧"><a href="#3-4-XPath-实用技巧" class="headerlink" title="3.4 XPath 实用技巧"></a>3.4 XPath 实用技巧</h2><ol>
<li><p><strong>使用属性选择节点：</strong></p>
<ul>
<li><code>//td[@class=&quot;status&quot;]</code> 选择所有 class 为 “status” 的 <code>&lt;td&gt;</code>。</li>
<li><code>//a[@href]</code> 选择带有 <code>href</code> 属性的所有 <code>&lt;a&gt;</code> 标签。</li>
</ul>
</li>
<li><p><strong>使用索引选择特定节点：</strong></p>
<ul>
<li><code>//tr[1]</code> 选择第一个 <code>&lt;tr&gt;</code> 节点。</li>
<li><code>//td[2]</code> 选择当前 <code>&lt;tr&gt;</code> 中的第二个 <code>&lt;td&gt;</code> 节点。</li>
</ul>
</li>
<li><p><strong>选择文本和属性：</strong></p>
<ul>
<li><code>//td/text()</code> 选择 <code>&lt;td&gt;</code> 内的文本。</li>
<li><code>//a/@href</code> 选择所有 <code>&lt;a&gt;</code> 标签的 <code>href</code> 属性。</li>
</ul>
</li>
<li><p><strong>条件筛选：</strong></p>
<ul>
<li><code>//tr[td[1]=&quot;在线&quot;]</code> 选择第一列文本为“在线”的行。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬虫教程 01</title>
    <url>/2024/09/17/01Python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="1-浏览器"><a href="#1-浏览器" class="headerlink" title="1.浏览器"></a>1.浏览器</h1><h2 id="1-1-获取页面信息"><a href="#1-1-获取页面信息" class="headerlink" title="1.1 获取页面信息"></a>1.1 获取页面信息</h2><p>进入要爬取的页面，按<code>F12</code>进入开发者模式：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/09/17/2L7UlQKkAjaNVud.png"
                      alt="豆瓣Top250电影.png"
                ><figcaption>豆瓣Top250电影.png</figcaption></figure></p>
<p>选择<code>network</code>一栏，左上角有一个<code>红点</code>标识暂停的意思，通过刷新页面可以获得当前页面的流量，但是对我们来说最重要的是<code>top250?start=</code>这个信息，正好与该网址<code>https://movie.douban.com/top250?start=</code>最后一部分的站点相对应。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/09/17/uDgx4JOBaVZT6w3.png"
                      alt="豆瓣Top250电影.png"
                ><figcaption>豆瓣Top250电影.png</figcaption></figure></p>
<p>选择<code>top250?start=</code>这块，这部分内容主要是用于我们伪装自己的爬虫程序为浏览器（相当于把<code>Python</code>伪装成<code>Chrome</code>浏览器）。尤其是<code>User-Agent</code>部分。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/09/17/z5tewy4Zmr2AD3V.png"
                      alt="top250?start=.png"
                ><figcaption>top250?start=.png</figcaption></figure></p>
<h1 id="2-配置爬虫编程环境"><a href="#2-配置爬虫编程环境" class="headerlink" title="2.配置爬虫编程环境"></a>2.配置爬虫编程环境</h1><ul>
<li>创建虚拟环境<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n scrapy python</span><br></pre></td></tr></table></figure></div></li>
<li>激活：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate scrapy</span><br></pre></td></tr></table></figure></div></li>
<li>安装必要的包：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pandas bs4 urllib xlwt sqlite3</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h1 id="3-urllib-包讲解"><a href="#3-urllib-包讲解" class="headerlink" title="3.urllib 包讲解"></a>3.urllib 包讲解</h1><p>需要导入这两个类：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br></pre></td></tr></table></figure></div>

<h2 id="3-1-get-请求"><a href="#3-1-get-请求" class="headerlink" title="3.1 get 请求"></a>3.1 get 请求</h2><p>获取一个百度的<code>get</code>请求，然后把内容保存到<code>baidu.html</code>文件中：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发送一个 HTTP GET 请求，访问百度首页</span></span><br><span class="line">response = urllib.request.urlopen(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="comment"># 使用 read() 方法从 response 响应对象中读取网页的内容。</span></span><br><span class="line">content = response.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;baidu.html&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(content)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;内容已保存到 baidu.html 文件中&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>用浏览器打开<code>baidu.html</code>文件，可以发现它就是百度搜索的页面。</p>
<p>这里的<code>read()</code>方法返回的是网页的字节数据（<code>bytes</code>类型），即网页的 HTML 源代码。这是因为读取的是未经解码的二进制数据。<br><code>open</code>方法中传入参数的参数是<code>wb (write binary)</code>，该模式用于打开文件进行写入，且文件以二进制模式打开。由于<code>response.read()</code>返回的是字节数据（非文本），所以使用二进制模式写入文件。</p>
<h2 id="3-2-post-请求"><a href="#3-2-post-请求" class="headerlink" title="3.2 post 请求"></a>3.2 post 请求</h2><p>测试网址为：<code>https://httpbin.org/post</code>：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将字典 &#123;&quot;hello&quot;: &quot;world&quot;&#125; 编码为查询字符串 &#x27;hello=world&#x27;</span></span><br><span class="line">data = <span class="built_in">bytes</span>(urllib.parse.urlencode(&#123;<span class="string">&quot;hello&quot;</span> : <span class="string">&quot;world&quot;</span>&#125;), encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="comment"># 发送 POST 请求，data 包含要发送的数据</span></span><br><span class="line">response = urllib.request.urlopen(<span class="string">&quot;https://httpbin.org/post&quot;</span>, data=data)</span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">&quot;utf-8&quot;</span>))</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;, </span><br><span class="line">  &quot;data&quot;: &quot;&quot;, </span><br><span class="line">  &quot;files&quot;: &#123;&#125;, </span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;hello&quot;: &quot;world&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;, </span><br><span class="line">    &quot;Content-Length&quot;: &quot;11&quot;, </span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Python-urllib/3.12&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-66e971aa-12f8daa034aa05d42f8a080c&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;json&quot;: null, </span><br><span class="line">  &quot;origin&quot;: &quot;113.57.44.61&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;https://httpbin.org/post&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>从输出结果可以看出在请求时伪装成了浏览器的样子。</p>
<p><code>POST</code> 请求在 Web 开发中非常常用，通常用于向服务器提交数据，比如表单提交、文件上传、新数据的创建等。在发送 <code>POST</code> 请求时，服务器期望接收到的数据会放在请求的主体（<code>body</code>）中，而不是像 <code>GET</code> 请求那样附加在 URL 的查询字符串中。这也是需要通过 <code>data</code> 参数来封装发送给服务器的数据的原因。</p>
<h3 id="3-2-1-POST-请求的用途"><a href="#3-2-1-POST-请求的用途" class="headerlink" title="3.2.1 POST 请求的用途"></a>3.2.1 POST 请求的用途</h3><ul>
<li><strong>提交表单数据：</strong> 用户在网页上填写表单，并点击提交按钮，浏览器会向服务器发送一个 <code>POST</code> 请求，表单中的数据会通过 <code>POST</code> 请求的主体发送。</li>
<li><strong>上传文件：</strong> 文件上传通常通过 <code>POST</code> 请求，文件数据被封装在请求主体中传递给服务器。</li>
<li><strong>创建或修改资源：</strong> 比如在 REST API 中，<code>POST</code> 请求常用于向服务器创建新的资源，发送 JSON 或 XML 格式的数据。</li>
<li><strong>提交敏感数据：</strong> 由于 <code>POST</code> 请求的数据不在 URL 中，而是在请求主体中，适合传递一些敏感信息，如密码、个人数据等（但仍需结合 HTTPS 保障安全性）。</li>
</ul>
<h3 id="3-2-2-封装数据的用途"><a href="#3-2-2-封装数据的用途" class="headerlink" title="3.2.2 封装数据的用途"></a>3.2.2 封装数据的用途</h3><ul>
<li>在 <code>POST</code> 请求中，服务器期望从请求的 <strong>主体</strong> 接收数据。因此，数据必须通过 <code>data</code> 参数以字节（<code>bytes</code>）形式发送。</li>
<li>如果不提供 <code>data</code> 参数，<code>urllib.request.urlopen()</code> 默认发送的是一个 <code>GET</code> 请求（即不携带数据），而 <code>GET</code> 请求不能用于修改资源，只能用于获取资源。这时，访问像 <code>https://httpbin.org/post</code> 这种只能处理 <code>POST</code> 请求的 API，服务器会返回 <code>HTTP 405</code>错误，表示 <code>METHOD NOT ALLOWED</code>（方法不被允许），因为服务器只允许 <code>POST</code>，不允许 <code>GET</code>。</li>
<li>将数据通过 <code>bytes</code> 封装后，<code>urlopen</code> 方法知道你正在发送的是一个 <code>POST</code> 请求，而不是 <code>GET</code> 请求。</li>
</ul>
<h3 id="3-2-3-将数据封装为-bytes-的原因"><a href="#3-2-3-将数据封装为-bytes-的原因" class="headerlink" title="3.2.3 将数据封装为 bytes 的原因"></a>3.2.3 将数据封装为 bytes 的原因</h3><p>在发送 <code>POST</code> 请求时，数据会被放在 HTTP 请求的主体中，HTTP 协议规定传输的数据以字节（<code>bytes</code>）的形式发送，因此你需要先将数据转换为 <code>bytes</code> 格式。Python 的 <code>urllib.parse.urlencode()</code> 函数将字典编码为查询字符串格式，然后将其通过 <code>bytes()</code> 转换为字节流。</p>
<h2 id="3-3-超时处理"><a href="#3-3-超时处理" class="headerlink" title="3.3 超时处理"></a>3.3 超时处理</h2><p>以<code>get</code>请求为例：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib.request.urlopen(<span class="string">&quot;https://httpbin.org/get&quot;</span>, timeout=<span class="number">0.01</span>)</span><br><span class="line">    <span class="built_in">print</span>(response.read().decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;time out&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h2 id="3-4-查看响应"><a href="#3-4-查看响应" class="headerlink" title="3.4 查看响应"></a>3.4 查看响应</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">response = urllib.request.urlopen(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.status)</span><br></pre></td></tr></table></figure></div>

<p>输出结果为<code>200</code>， 表示 HTTP 请求成功，服务器正常处理并返回了所请求的资源。HTTP 状态码是服务器在处理客户端请求后返回的标准响应代码。</p>
<p><strong>常见的 HTTP 状态码：</strong></p>
<ul>
<li><code>2xx</code>（成功类状态码）：<ul>
<li><code>200 OK</code>：请求成功并返回资源。</li>
<li><code>201 Created</code>：请求成功且服务器创建了新的资源。</li>
</ul>
</li>
<li><code>3xx</code>（重定向类状态码）：<ul>
<li><code>301 Moved Permanently</code>：资源已永久移动到新位置。</li>
<li><code>302 Found</code>：资源临时移动到新位置。</li>
</ul>
</li>
<li><code>4xx</code>（客户端错误类状态码）：<ul>
<li><code>400 Bad Request</code>：请求无效，通常是由于请求格式错误。</li>
<li><code>401 Unauthorized</code>：未经授权，通常是未提供认证信息。</li>
<li><code>404 Not Found</code>：服务器无法找到请求的资源。</li>
<li><code>418</code>：表示访问的网站有反爬虫机制，解决方法就是带请求头<code>header(suser-agent)</code>访问。</li>
</ul>
</li>
<li><code>5xx</code>（服务器错误类状态码）：<ul>
<li><code>500 Internal Server Error</code>：服务器内部错误。</li>
<li><code>503 Service Unavailable</code>：服务器暂时无法处理请求，通常是因为过载或维护。</li>
</ul>
</li>
</ul>
<p>查看响应内容：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">response = urllib.request.urlopen(<span class="string">&quot;http://baidu.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.getheaders())</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">[(&#x27;Date&#x27;, &#x27;Tue, 17 Sep 2024 15:43:39 GMT&#x27;), (&#x27;Server&#x27;, &#x27;Apache&#x27;), (&#x27;Last-Modified&#x27;, &#x27;Tue, 12 Jan 2010 13:48:00 GMT&#x27;), (&#x27;ETag&#x27;, &#x27;&quot;51-47cf7e6ee8400&quot;&#x27;), (&#x27;Accept-Ranges&#x27;, &#x27;bytes&#x27;), (&#x27;Content-Length&#x27;, &#x27;81&#x27;), (&#x27;Cache-Control&#x27;, &#x27;max-age=86400&#x27;), (&#x27;Expires&#x27;, &#x27;Wed, 18 Sep 2024 15:43:39 GMT&#x27;), (&#x27;Connection&#x27;, &#x27;Close&#x27;), (&#x27;Content-Type&#x27;, &#x27;text/html&#x27;)]</span><br></pre></td></tr></table></figure></div>
<p>这个输出结果正好就是对应网页（这里是<code>baidu</code>）的响应头。如图所示：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/09/17/1JbukLBxFqTNgOm.png"
                      alt="百度响应头.png"
                ><figcaption>百度响应头.png</figcaption></figure></p>
<h2 id="3-5-把访问伪装成浏览器"><a href="#3-5-把访问伪装成浏览器" class="headerlink" title="3.5 把访问伪装成浏览器"></a>3.5 把访问伪装成浏览器</h2><p><code>user-agen</code>的信息需要在浏览器中按<code>F12</code>后，在对应页面的响应头中找到。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&quot;https://douban.com&quot;</span></span><br><span class="line"><span class="comment"># 这里可以添加更多的键值对，模拟得更像</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">data = <span class="built_in">bytes</span>(urllib.parse.urlencode(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;eric&#x27;</span>&#125;), encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">req = urllib.request.Request(url=url, data=data, headers=headers, method=<span class="string">&quot;POST&quot;</span>)</span><br><span class="line">response = urllib.request.urlopen(req)</span><br><span class="line"><span class="built_in">print</span>(response.read())</span><br></pre></td></tr></table></figure></div>

<p>这样的话就能获得该网址的页面信息。</p>
<p>这里并不是必须封装 <code>data</code>的，因为我们 <strong>不需要向豆瓣发送数据</strong> ，因此可以不传递 <code>data</code> 参数，但这会导致 <code>urllib.request.Request()</code> 默认使用 <code>GET</code> 方法而不是 <code>POST</code> 方法。<title>百度一下，你就知道</title></p>
<p>  如果使用 <code>GET</code> 请求的话，需要注意 <code>GET</code> 请求的特点是将数据 <strong>附加在 URL 后面</strong> 作为查询字符串，而不是放在请求体中。因此，<code>GET</code> 请求一般不用于提交大量数据，且不适合提交敏感数据。</p>
<p>可以将数据拼接到 URL 中，比如这样：<br>  <div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&quot;https://douban.com?name=eric&quot;</span></span><br><span class="line">req = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(req)</span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">&quot;utf-8&quot;</span>))</span><br></pre></td></tr></table></figure></div><br>  这种形式会将参数 <code>name=eric</code> 直接放到 URL 后面，形成一个完整的查询 URL。</p>
<h1 id="4-bs4-包讲解"><a href="#4-bs4-包讲解" class="headerlink" title="4.bs4 包讲解"></a>4.bs4 包讲解</h1><p><code>BeautifulSoup</code> 通过解析 HTML 或 XML，将其转换成 Python 对象树，方便开发者使用各种方式来查找和操作数据，比如通过标签、类名、属性等。<br>需要导入这个类：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>主要功能</p>
<ol>
<li><strong>解析 HTML&#x2F;XML 文档</strong> ：将 HTML 或 XML 文档解析成树形结构，便于操作。</li>
<li><strong>提取数据</strong> ：提供多种方法，如通过标签、类名、属性来查找和筛选网页内容。</li>
<li><strong>格式化输出</strong> ：可以格式化 HTML 文档，使其更易于阅读。</li>
<li><strong>修复格式问题</strong> ：它能处理不规范的 HTML 代码，并生成结构化的输出。</li>
</ol>
</li>
<li><p>常用方法</p>
<ol>
<li><code>find(tag, **kwargs)</code>：找到符合条件的第一个标签。</li>
<li><code>find_all(tag, **kwargs)</code>：找到所有符合条件的标签。</li>
<li><code>select(css_selector)</code>：通过 CSS 选择器查找元素。</li>
<li><code>get(attribute)</code>：获取标签的某个属性值。</li>
<li><code>text</code>：获取标签的文本内容。</li>
</ol>
</li>
</ul>
<h2 id="4-1-获取标签及其里的内容"><a href="#4-1-获取标签及其里的内容" class="headerlink" title="4.1 获取标签及其里的内容"></a>4.1 获取标签及其里的内容</h2><p>这里的测试文件是我们在<code>3.1 get 请求</code>章节中获得的<code>baidu</code>首页。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;course/test/baidu.html&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">html = file.read().decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">bs = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>这里向<code>BeautifulSoup</code>传入的参数有两个，第一个参数<code>html</code>表示指定文档类型，因为<code>BeautifulSoup</code>还能解析<code>json</code>、<code>xml</code>这类文件。第二个参数<code>&quot;html.parser</code>表示指定解析器的类型。返回的对象<code>bs</code>中就存储有解析后的结果，后续操作也是对<code>bs</code>进行。</p>
<ul>
<li><strong>获取标签及其里面的内容</strong></li>
</ul>
<p>比如：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bs.title)      <span class="comment"># 标签里的内容</span></span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;title&gt;百度一下，你就知道&lt;/title&gt;</span><br></pre></td></tr></table></figure></div>
<p>直接就把文档里的<code>title</code>给拿出来了。</p>
<p>再比如执行：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bs.a)</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;a class=&quot;toindex&quot; href=&quot;/&quot;&gt;百度首页&lt;/a&gt;</span><br></pre></td></tr></table></figure></div>
<p>就把文档里的<code>a</code>的内容给拿出来了。</p>
<p>我们可以发现规律，当用这种方式访问查找的时候，它会把文件中出现的 <strong>第一个</strong> 标签返回给你。</p>
<p>如果还是不清楚的话，我们可以尝试打印下该返回对象的类型：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(bs.a))</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;bs4.element.Tag&#x27;&gt;</span><br></pre></td></tr></table></figure></div>
<p>可以看出返回类型就是 <strong>标签（<code>Tag</code>）</strong> 。</p>
<p>如果我们在打印的对象后面加上限定：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bs.title.string)</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">百度一下，你就知道</span><br></pre></td></tr></table></figure></div>
<p>只会返回标签里的内容。</p>
<p>把标签里的内容以字典的方式保存：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bs.a.attrs)</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;class&#x27;: [&#x27;toindex&#x27;], &#x27;href&#x27;: &#x27;/&#x27;&#125;</span><br></pre></td></tr></table></figure></div>
<p>这是对应的找到的源文件内容的那行<code>&lt;a class=&quot;toindex&quot; href=&quot;/&quot;&gt;百度首页&lt;/a&gt;</code>，可以发现是以字典的形式返回给我们的。</p>
<h2 id="4-2-文档的遍历"><a href="#4-2-文档的遍历" class="headerlink" title="4.2 文档的遍历"></a>4.2 文档的遍历</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bs.head.contents) </span><br></pre></td></tr></table></figure></div>
<p>输出结果：返回的是一个列表，如图所示<br><a href="https://imgse.com/i/pAK8ozd"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/09/18/pAK8ozd.png"
                      alt="返回结果.png"
                ><figcaption>返回结果.png</figcaption></figure></a></p>
<p>既然我们知道返回的是一个列表，那么我们就可以通过下标来访问：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bs.head.contents[<span class="number">0</span>]) </span><br></pre></td></tr></table></figure></div>

<p>想了解更多内容可以通过在浏览器搜索 <strong>遍历文件树</strong> 获知。w</p>
<h2 id="4-3-文档的搜索"><a href="#4-3-文档的搜索" class="headerlink" title="4.3 文档的搜索"></a>4.3 文档的搜索</h2><ol>
<li><p><strong>字符串过滤：</strong> 会查找与字符串完全匹配的内容</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">t_list = bs.find_all(<span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>这表示查找所有的<code>a</code>。会把所有符合<code>a</code>标签的以列表的形式存储。</p>
</li>
<li><p><strong>正则表达式搜索：</strong> 使用<code>search</code>方法来匹配内容</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re <span class="comment"># 正则表达式解析库</span></span><br><span class="line"></span><br><span class="line">t_list = bs.find_all(re.<span class="built_in">compile</span>(<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(t_list)</span><br></pre></td></tr></table></figure></div>
<p>这种方式会把包含<code>a</code>的内容（包括标签和文本内容）以列表的形式存储。</p>
</li>
<li><p><strong>以方法形式：</strong> 传入一个函数（方法），根据函数的要求搜索</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">name_is_exist</span>(<span class="params">tag</span>):</span><br><span class="line">    <span class="keyword">return</span> tag.has_attr(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line">t_list = bs.find_all(name_is_exist)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> t_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure></div>
<p>在<code>find_all()</code>中使用自定义筛选函数时，函数会对每个标签对象进行评估。函数的返回值必须是<code>True</code>或<code>False</code>。如果函数返回<code>True</code>，这个标签会被包含在返回结果中；如果返回<code>False</code>，则跳过该标签。<code> has_attr()</code>是<code>BeautifulSoup</code>的一个方法，用于检查某个标签是否具有指定的属性。在这个例子中，<code>tag.has_attr(&quot;name&quot;)</code>用来判断标签是否有<code>name</code>属性。</p>
</li>
<li><p><strong>kwargs :</strong> 指定参数来搜索</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">t_list = bs.find_all(<span class="built_in">id</span>=<span class="string">&quot;head&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>会把<code>id=head</code>的标签存放到<code>t_list</code>列表中。</p>
</li>
</ol>
<p>还比如：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">t_list = bs.find_all(class_ =<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div>
<p>这会把所有包含<code>class</code>的标签搜索出来。为什么要写成<code>class_</code>呢？因为<code>class</code>是 Python 保留关键字，保留关键字是不能之际作为参数名来使用的。</p>
<ol start="5">
<li><p><strong>string 参数：</strong> 搜索出指定参数</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">t_list = bs.find_all(string =[<span class="string">&quot;hao123&quot;</span>, <span class="string">&quot;地图&quot;</span>, <span class="string">&quot;贴吧&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(t_list)</span><br></pre></td></tr></table></figure></div>
<p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">[&#x27;hao123&#x27;, &#x27;地图&#x27;, &#x27;贴吧&#x27;, &#x27;贴吧&#x27;, &#x27;地图&#x27;]</span><br></pre></td></tr></table></figure></div>
<p>这种方式还可以应用正则表达式来查找包含特定文本的内容，也就是标签里的字符串。<br>比如这样：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">t_list = bs.find_all(string =re.<span class="built_in">compile</span>(<span class="string">&quot;\d&quot;</span>))</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>css选择器：</strong> 用<code>select()</code>方法</p>
</li>
</ol>
<p>通过标签来查找：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">t_list = bs.select(<span class="string">&quot;title&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>通过类名来查找：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">t_list = bs.select(<span class="string">&quot;.mnav&quot;</span>) </span><br></pre></td></tr></table></figure></div>
<p>在 CSS 中，<code>.（点号）</code>表示选择具有特定类名的元素。<code>.mnav</code>表示选择所有<code>class=&quot;mnav&quot;</code>的元素。</p>
<h1 id="5-re-包讲解"><a href="#5-re-包讲解" class="headerlink" title="5.re 包讲解"></a>5.re 包讲解</h1><p>Python 的 <code>re</code> 包用于处理正则表达式（Regular Expressions），它提供了在字符串中进行模式匹配、替换、拆分等操作的功能。正则表达式是一种强大的工具，可以用来查找、匹配和操作字符串中的特定模式。</p>
<h2 id="5-1-re-包的常用方法"><a href="#5-1-re-包的常用方法" class="headerlink" title="5.1 re 包的常用方法"></a>5.1 re 包的常用方法</h2><ol>
<li><p><strong>re.match()：</strong></p>
<ul>
<li>作用：从字符串的起始位置开始匹配正则表达式。</li>
<li>如果匹配成功，返回一个 <code>Match</code> 对象；如果不匹配，返回 <code>None</code>。</li>
<li>示例：<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">result = re.<span class="keyword">match</span>(<span class="string">r&#x27;\d+&#x27;</span>, <span class="string">&#x27;123abc456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result.group())  <span class="comment"># 输出: &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>re.search()：</strong></p>
<ul>
<li>作用：扫描整个字符串，找到第一个符合正则表达式的匹配项。</li>
<li>如果匹配成功，返回一个 <code>Match</code> 对象；如果不匹配，返回 <code>None</code>。</li>
<li>示例：<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">result = re.search(<span class="string">r&#x27;\d+&#x27;</span>, <span class="string">&#x27;abc123xyz456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result.group())  <span class="comment"># 输出: &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>re.findall()：</strong></p>
<ul>
<li>作用：返回字符串中所有与正则表达式匹配的部分，结果是一个列表。</li>
<li>示例：<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">result = re.findall(<span class="string">r&#x27;\d+&#x27;</span>, <span class="string">&#x27;abc123xyz456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: [&#x27;123&#x27;, &#x27;456&#x27;]</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>re.finditer()：</strong></p>
<ul>
<li>作用：返回一个迭代器，生成字符串中所有匹配的 <code>Match</code> 对象。</li>
<li>示例：<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">matches = re.finditer(<span class="string">r&#x27;\d+&#x27;</span>, <span class="string">&#x27;abc123xyz456&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> matches:</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: &#x27;123&#x27; &#x27;456&#x27;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>re.sub()：</strong></p>
<ul>
<li>作用：将匹配的部分替换为指定的字符串。</li>
<li>示例：<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">result = re.sub(<span class="string">r&#x27;\d+&#x27;</span>, <span class="string">&#x27;NUMBER&#x27;</span>, <span class="string">&#x27;abc123xyz456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: &#x27;abcNUMBERxyzNUMBER&#x27;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>re.split()：</strong></p>
<ul>
<li>作用：根据正则表达式匹配的部分分割字符串，返回列表。</li>
<li>示例：<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">result = re.split(<span class="string">r&#x27;\d+&#x27;</span>, <span class="string">&#x27;abc123xyz456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;xyz&#x27;, &#x27;&#x27;]</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>re.compile()：</strong></p>
<ul>
<li>作用：将正则表达式编译成正则对象，以便多次复用。</li>
<li>示例：<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>)</span><br><span class="line">result = pattern.findall(<span class="string">&#x27;abc123xyz456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: [&#x27;123&#x27;, &#x27;456&#x27;]</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
<h2 id="5-2-正则表达式的常用操作符"><a href="#5-2-正则表达式的常用操作符" class="headerlink" title="5.2 正则表达式的常用操作符"></a>5.2 正则表达式的常用操作符</h2><ol>
<li><p><strong><code>.</code></strong> （点号）：匹配任意单个字符（除换行符 <code>\n</code> 之外）。</p>
<ul>
<li>示例：<code>a.b</code> 可以匹配 <code>acb</code>, <code>a9b</code>, 但不能匹配 <code>ab</code>。</li>
</ul>
</li>
<li><p><strong><code>^</code></strong> （脱字符）：匹配字符串的开头。</p>
<ul>
<li>示例：<code>^a</code> 可以匹配 <code>abc</code> 中的 <code>a</code>，但不能匹配 <code>bca</code>。</li>
</ul>
</li>
<li><p><strong><code>$</code></strong> （美元符号）：匹配字符串的末尾。</p>
<ul>
<li>示例：<code>a$</code> 可以匹配 <code>bca</code> 中的 <code>a</code>，但不能匹配 <code>abc</code>。</li>
</ul>
</li>
<li><p><strong><code>*</code></strong> （星号）：匹配前一个字符 0 次或多次。</p>
<ul>
<li>示例：<code>ab*</code> 可以匹配 <code>a</code>, <code>ab</code>, <code>abb</code>, <code>abbbbb</code>。</li>
</ul>
</li>
<li><p><strong><code>+</code></strong> （加号）：匹配前一个字符 1 次或多次。</p>
<ul>
<li>示例：<code>ab+</code> 可以匹配 <code>ab</code>, <code>abb</code>, <code>abbbbb</code>，但不能匹配 <code>a</code>。</li>
</ul>
</li>
<li><p><strong><code>?</code></strong> （问号）：匹配前一个字符 0 次或 1 次。</p>
<ul>
<li>示例：<code>ab?</code> 可以匹配 <code>a</code>, <code>ab</code>，但不能匹配 <code>abb</code>。</li>
</ul>
</li>
<li><p><strong><code>&#123;m&#125;</code></strong> ：匹配前一个字符 <strong>正好 m 次</strong>。</p>
<ul>
<li>示例：<code>a&#123;3&#125;</code> 只能匹配 <code>aaa</code>。</li>
</ul>
</li>
<li><p><strong><code>&#123;m,n&#125;</code></strong> ：匹配前一个字符 <strong>至少 m 次，至多 n 次</strong>。</p>
<ul>
<li>示例：<code>a&#123;2,4&#125;</code> 可以匹配 <code>aa</code>, <code>aaa</code>, <code>aaaa</code>。</li>
</ul>
</li>
<li><p><strong><code>[]</code></strong> （字符集）：匹配字符集中的任意一个字符。</p>
<ul>
<li>示例：<code>[abc]</code> 可以匹配 <code>a</code>, <code>b</code>, <code>c</code> 中的任意一个。</li>
</ul>
</li>
<li><p><strong><code>|</code></strong> （管道符号）：表示“或”运算符，匹配左边或右边的内容。</p>
<ul>
<li>示例：<code>a|b</code> 可以匹配 <code>a</code> 或 <code>b</code>。</li>
</ul>
</li>
<li><p><strong><code>\</code></strong> （反斜杠）：用于转义特殊字符或表示特殊序列。</p>
<ul>
<li>示例：<code>\d</code> 匹配任意数字字符，<code>\s</code> 匹配任意空白字符，<code>\w</code> 匹配任意单词字符（字母、数字、下划线）。</li>
</ul>
</li>
<li><p><strong><code>()</code></strong> （括号）：用于分组，或提取匹配的子字符串。</p>
<ul>
<li>示例：<code>(abc)+</code> 可以匹配 <code>abc</code>, <code>abcabc</code> 等。</li>
<li>提取示例：<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">result = re.search(<span class="string">r&#x27;(abc)(\d+)&#x27;</span>, <span class="string">&#x27;abc123&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result.groups())  <span class="comment"># 输出: (&#x27;abc&#x27;, &#x27;123&#x27;)</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
<h2 id="5-3-常用的特殊序列"><a href="#5-3-常用的特殊序列" class="headerlink" title="5.3 常用的特殊序列"></a>5.3 常用的特殊序列</h2><ul>
<li><strong><code>\d</code></strong> ：匹配任何数字字符，等价于 <code>[0-9]</code>。</li>
<li><strong><code>\D</code></strong> ：匹配任何非数字字符，等价于 <code>[^0-9]</code>。</li>
<li><strong><code>\s</code></strong> ：匹配任何空白字符（空格、制表符等）。</li>
<li><strong><code>\S</code></strong> ：匹配任何非空白字符。</li>
<li><strong><code>\w</code></strong> ：匹配任何单词字符（字母、数字、下划线），等价于 <code>[a-zA-Z0-9_]</code>。</li>
<li><strong><code>\W</code></strong> ：匹配任何非单词字符，等价于 <code>[^a-zA-Z0-9_]</code>。</li>
</ul>
<h2 id="5-4-实际应用示例"><a href="#5-4-实际应用示例" class="headerlink" title="5.4 实际应用示例"></a>5.4 实际应用示例</h2><ol>
<li><p><strong>匹配电子邮件地址：</strong></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">email_pattern = <span class="string">r&#x27;\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]&#123;2,&#125;\b&#x27;</span></span><br><span class="line">email = <span class="string">&quot;contact@example.com&quot;</span></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(email_pattern, email):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Valid email&quot;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>替换字符串中的数字：</strong></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;My phone number is 12345&quot;</span></span><br><span class="line">result = re.sub(<span class="string">r&#x27;\d+&#x27;</span>, <span class="string">&#x27;#####&#x27;</span>, text)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: &quot;My phone number is #####&quot;</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬虫教程 03</title>
    <url>/2024/10/17/03Python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="1-无请求头访问"><a href="#1-无请求头访问" class="headerlink" title="1.无请求头访问"></a>1.无请求头访问</h1><p>如果不构建请求头，直接向目标网站发送请求：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://spiderbuf.cn/playground/s02&quot;</span></span><br><span class="line"></span><br><span class="line">html = requests.get(url=url).text</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/02course/02.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">f.write(html)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(html)</span><br><span class="line">root = etree.HTML(html)</span><br><span class="line">trs = root.xpath(<span class="string">&#x27;//tr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/02course/data02.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">    tds = tr.xpath(<span class="string">&#x27;./td&#x27;</span>)</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> td <span class="keyword">in</span> tds:</span><br><span class="line">        <span class="comment"># print(td.text)</span></span><br><span class="line">        s = s + <span class="built_in">str</span>(td.text) + <span class="string">&#x27; | &#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s!= <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        f.write(s + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;tengine&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div>
<p>很容易被网站检测到是爬虫。</p>
<h1 id="2-添加请求头"><a href="#2-添加请求头" class="headerlink" title="2.添加请求头"></a>2.添加请求头</h1><p>所以基本上在发送请求之前都会封装一个<code>http</code>请求的头部信息：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html = requests.get(url=url, headers=headers).text</span><br></pre></td></tr></table></figure></div>

<p>有时候还需要往里面填入<code>Cookie</code>。甚至为了防止被检测到是爬虫，需要更换<code>User-Agent</code>，比如用火狐浏览器的等，或者浏览器不同版本的，这在网上可以查询到。</p>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬虫教程 04</title>
    <url>/2024/10/17/04Python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="1-测试案例"><a href="#1-测试案例" class="headerlink" title="1.测试案例"></a>1.测试案例</h1><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://spiderbuf.cn/playground/s03&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html = requests.get(url=url, headers=headers).text</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/03course/03.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">f.write(html)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(html)</span></span><br><span class="line">root = etree.HTML(html)</span><br><span class="line">trs = root.xpath(<span class="string">&#x27;//tr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/03course/data03.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">    tds = tr.xpath(<span class="string">&#x27;./td&#x27;</span>)</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> td <span class="keyword">in</span> tds:</span><br><span class="line">        s = s + <span class="built_in">str</span>(td.text) + <span class="string">&#x27; | &#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s!= <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        f.write(s + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>直接运行上面这段代码，会发现输出结果是这样的：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">1 | None | CD-82-76-71-65-75 | 堡垒机 | 服务器 | Windows10 | 80,22,443 | </span><br><span class="line">                             | </span><br><span class="line">2 | None | E6-84-22-55-44-BE | 摄像头 | 摄像头 | HUAWEI | 80,22,443 | </span><br><span class="line">                             | </span><br><span class="line">3 | None | 37-01-AE-BE-5E-C0 | 文件服务器 | 服务器 | Linux | 80,22,443 | </span><br><span class="line">                             | </span><br><span class="line">4 | None | 84-A9-97-A8-B2-99 | 交换机 | 交换机 | HUAWEI | None | </span><br><span class="line">                             | </span><br><span class="line">5 | None | 8C-94-9D-85-6C-C1 | 堡垒机 | 服务器 | Windows10 | 80,22,443 | </span><br><span class="line">                             | </span><br><span class="line">6 | None | F2-10-E3-CA-DF-DC | 数据库服务器 | 服务器 | Windows10 | 80,22,443 | </span><br><span class="line">                             | </span><br><span class="line">7 | None | 46-9A-AF-F4-DC-33 | 数据库服务器 | 服务器 | Windows10 | 80,22,443 | </span><br><span class="line">                             | </span><br><span class="line">8 | None | B5-66-A6-0C-C6-57 | 堡垒机 | 服务器 | Linux | 80,22,443 | </span><br><span class="line">                             | </span><br><span class="line">9 | None | 5C-3F-8E-6E-D9-C5 | OA服务器 | 服务器 | Linux | 80,22,443 | </span><br><span class="line">                             | </span><br><span class="line">10 | None | EC-C6-79-88-4C-BA | 测试服务器 | 服务器 | Linux | 80,22,443 | </span><br><span class="line">                             | </span><br></pre></td></tr></table></figure></div>
<p>第一列的内容都是<code>None</code>，这是为什么呢？</p>
<h1 id="2-分析页面源码结构"><a href="#2-分析页面源码结构" class="headerlink" title="2.分析页面源码结构"></a>2.分析页面源码结构</h1><p>我们先来看下我们要爬取的页面的源码结构，是这段内容：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>172.16.80.178<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>CD-82-76-71-65-75<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>堡垒机<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>服务器<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Windows10<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>80,22,443<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;green&quot;</span>&gt;</span>在线<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>可以发现有两个部分：</p>
<ul>
<li>第二个<code>td</code>：<code>&lt;td&gt;&lt;a href=&quot;#&quot;&gt;172.16.80.178&lt;/a&gt;&lt;/td&gt;</code></li>
<li>最后一个<code>td</code>：<code>&lt;td&gt;&lt;font color=&quot;green&quot;&gt;在线&lt;/font&gt;&lt;/td&gt;</code><br>这两个部分<code>&lt;td&gt;</code>里是不含内容的。要像这种<code>&lt;td&gt;文本&lt;/td&gt;</code>才说名含有内容，对于这种<code>&lt;td&gt;&lt;a&gt;文本&lt;a&gt;&lt;/td&gt;</code>是<code>&lt;a&gt;</code>含有内容，<code>&lt;td&gt;</code>不含。<br>所以我们要取出<code>&lt;a&gt;</code>节点里的内容应该怎么做呢？有一个思路是把<code>&lt;td&gt;</code>节点下的<code>&lt;a&gt;</code>节点的内容再取一遍，但这未免有点麻烦了。</li>
</ul>
<p>这里有一个简单的方法，把解析部分的代码改成这样：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">root = etree.HTML(html)</span><br><span class="line">trs = root.xpath(<span class="string">&#x27;//tr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/03course/data03.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">    tds = tr.xpath(<span class="string">&#x27;./td&#x27;</span>)</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> td <span class="keyword">in</span> tds:</span><br><span class="line">        s = s + <span class="built_in">str</span>(td.xpath(<span class="string">&#x27;string(.)&#x27;</span>)) + <span class="string">&#x27;|&#x27;</span>        <span class="comment"># 修改过后的解析操作</span></span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s!= <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        f.write(s + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p>这种方式可以获取元素及其所有子元素的完整文本，而不仅仅是直接子节点的文本。<code>.</code>表示当前节点，这里就表示把当前节点的所有文本内容（包括子节点中的文本）提取出来。</p>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬虫教程 05</title>
    <url>/2024/10/17/05Python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="1-网页分析"><a href="#1-网页分析" class="headerlink" title="1.网页分析"></a>1.网页分析</h1><p>有时候要爬取的网页是需要翻页的，如图所示：</p>
<p><a href="https://imgse.com/i/pAUAa1e"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/10/17/pAUAa1e.png"
                      alt="第一页.png"
                ><figcaption>第一页.png</figcaption></figure></a></p>
<p>设置有时候尽管网页需要翻页，但是在执行翻页操作时，地址栏（网址）没有发生变化，这时候可能隐藏在浏览器控制台的<code>network</code>中，如图所示：<br><a href="https://imgse.com/i/pAUAwXd"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/10/17/pAUAwXd.png"
                      alt="控制台.png"
                ><figcaption>控制台.png</figcaption></figure></a></p>
<h1 id="2-知道明确页数的情况"><a href="#2-知道明确页数的情况" class="headerlink" title="2.知道明确页数的情况"></a>2.知道明确页数的情况</h1><p>示例代码：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">&quot;https://www.spiderbuf.cn/playground/s04?pageno=&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现翻页爬取</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    url = base_url.<span class="built_in">format</span>(i)</span><br><span class="line">    html = requests.get(url=url, headers=headers).text</span><br><span class="line"></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/04course/04_%d.html&#x27;</span> % i, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    f.write(html)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">    root = etree.HTML(html)</span><br><span class="line">    trs = root.xpath(<span class="string">&#x27;//tr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/04course/data04_%d.txt&#x27;</span> % i, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">        tds = tr.xpath(<span class="string">&#x27;./td&#x27;</span>)</span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> td <span class="keyword">in</span> tds:</span><br><span class="line">            s = s + <span class="built_in">str</span>(td.xpath(<span class="string">&#x27;string(.)&#x27;</span>)) + <span class="string">&#x27;|&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(s)</span><br><span class="line">        <span class="keyword">if</span> s!= <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            f.write(s + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h1 id="3-不知道明确页数的情况"><a href="#3-不知道明确页数的情况" class="headerlink" title="3.不知道明确页数的情况"></a>3.不知道明确页数的情况</h1><p>可以通过查看网页源码找寻总页数，然后先用<code>xpath</code>解析网页里<code>总页数</code>的这个内容，再通过正则表达式解析出里面的数字：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> re       <span class="comment"># 正则表达式库</span></span><br><span class="line"></span><br><span class="line">base_url = <span class="string">&quot;https://www.spiderbuf.cn/playground/s04?pageno=&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html_1 = requests.get(url= base_url.<span class="built_in">format</span>(<span class="number">1</span>), headers=headers).text</span><br><span class="line">root = etree.HTML(html_1)</span><br><span class="line">pages_text = root.xpath(<span class="string">&#x27;.//li/span/text()&#x27;</span>)    <span class="comment"># 返回的是一个列表</span></span><br><span class="line"><span class="built_in">print</span>(pages_text[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 正则表达式解析，提取数字</span></span><br><span class="line">pages = re.findall(<span class="string">&#x27;[0-9]&#x27;</span>, pages_text[<span class="number">0</span>])      <span class="comment"># 返回的是一个列表</span></span><br><span class="line"><span class="built_in">print</span>(pages)</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">共5页</span><br><span class="line">[&#x27;5&#x27;]</span><br></pre></td></tr></table></figure></div>

<p>感觉这个方法并不怎么实用，因为这种情况的话是能直接在网页看到有多少页的，再解析就是多此一举了。提这个也只是为了引出正则表达式，关于正则表达式的教程，可以结合 AI 来学习。</p>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬虫教程 06</title>
    <url>/2024/10/18/06Python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="1-分析网站"><a href="#1-分析网站" class="headerlink" title="1.分析网站"></a>1.分析网站</h1><p>第一步还是要先向网站发送请求，然后获得请求的内容：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.spiderbuf.cn/playground/s05&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html = requests.get(url= url, headers=headers).text</span><br><span class="line"><span class="built_in">print</span>(html)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/05course/05.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">f.write(html)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></div>

<p>然后开始解析网页源码，在浏览器中，要爬取的网站页面点击右键，然后选择 <strong>查看网页源代码</strong> ：<br><a href="https://imgse.com/i/pAUDMm4"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/10/18/pAUDMm4.png"
                      alt="如图操作.png"
                ><figcaption>如图操作.png</figcaption></figure></a></p>
<p>找到要爬取的图片部分：<br><a href="https://imgse.com/i/pAUD8t1"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/10/18/pAUD8t1.png"
                      alt="图片部分.png"
                ><figcaption>图片部分.png</figcaption></figure></a></p>
<p>点击里面的链接可以进入到图片页面：<br><a href="https://imgse.com/i/pAUD8t1"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/10/18/pAUD8t1.png"
                      alt="图片.png"
                ><figcaption>图片.png</figcaption></figure></a></p>
<p>注意这幅图中左上角的链接<code>https://www.spiderbuf.cn/static/images/beginner/1kwfkui2.jpg</code>。这条链接分成两部分来看：<code>https://www.spiderbuf.cn</code> + <code>/static/images/beginner/1kwfkui2.jpg</code></p>
<p>也就是说，要爬取图片的话，只需要解析出后半部分的链接即可。</p>
<h1 id="2-解析图片链接"><a href="#2-解析图片链接" class="headerlink" title="2.解析图片链接"></a>2.解析图片链接</h1><p>代码示例：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">root = etree.HTML(html)</span><br><span class="line">imgs = root.xpath(<span class="string">&#x27;//img/@src&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> imgs:</span><br><span class="line">    img_data = requests.get(<span class="string">&#x27;https://www.spiderbuf.cn&#x27;</span> + item, headers=headers).content     <span class="comment"># content 表示以二进制解析内容</span></span><br><span class="line">    img = <span class="built_in">open</span>(<span class="string">&quot;./课程/05course/&quot;</span> + <span class="built_in">str</span>(item).replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;&#x27;</span>), <span class="string">&#x27;wb&#x27;</span>)   <span class="comment"># b 表示以二进制的方式写入</span></span><br><span class="line">    img.write(img_data)</span><br><span class="line">    img.close()</span><br></pre></td></tr></table></figure></div>

<p><strong>为什么这里是写成<code>//img/@src</code>，而不是<code>//img/[@src]/text()</code>？</strong></p>
<p>在 XPath 中，<code>//img/@src</code> 和 <code>//img[@src]/text()</code> 的含义和使用场景不同，主要区别在于它们提取的是元素的属性值还是元素的文本内容。</p>
<ol>
<li><code>//img/@src</code>: 提取属性值</li>
</ol>
<ul>
<li><strong>作用</strong> ：<code>//img/@src</code> 用于选择所有 <code>&lt;img&gt;</code> 标签的 <code>src</code> 属性值。</li>
<li><strong>解释</strong> ：<ul>
<li><code>//img</code>：选择文档中所有的 <code>&lt;img&gt;</code> 元素。</li>
<li><code>@src</code>：选择每个 <code>&lt;img&gt;</code> 元素的 <code>src</code> 属性值。</li>
</ul>
</li>
<li><strong>返回值</strong> ：它直接返回属性的值，比如 <code>/static/images/beginner/9cwjdins.jpg</code>，即图片的 URL。</li>
</ul>
<ol start="2">
<li><code>//img[@src]/text()</code>: 提取元素文本</li>
</ol>
<ul>
<li><strong>作用</strong> ：<code>//img[@src]/text()</code> 用于选择所有具有 <code>src</code> 属性的 <code>&lt;img&gt;</code> 元素的 <strong>文本内容</strong> 。</li>
<li><strong>解释</strong> ：<ul>
<li><code>//img[@src]</code>：选择所有带有 <code>src</code> 属性的 <code>&lt;img&gt;</code> 元素。</li>
<li><code>text()</code>：提取该元素的文本内容。</li>
</ul>
</li>
<li><strong>返回值</strong> ：它会返回元素的文本内容，而不是属性的值。</li>
</ul>
<p>在这里的<code>&lt;img&gt;</code> 标签是一个 <strong>自闭合标签</strong> ，通常不会包含任何文本内容。因此，<code>//img[@src]/text()</code> 通常不会返回任何有效的结果，因为 <code>&lt;img&gt;</code> 标签中<strong>没有文本</strong>。</p>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬虫教程 07</title>
    <url>/2024/10/19/07Python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="1-示例"><a href="#1-示例" class="headerlink" title="1.示例"></a>1.示例</h1><p>示例代码：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这条链建</span></span><br><span class="line">url = <span class="string">&quot;https://www.spiderbuf.cn/playground/s06&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html = requests.get(url=url, headers=headers).text</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/06course/06.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">f.write(html)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(html)</span><br><span class="line"></span><br><span class="line">root = etree.HTML(html)</span><br><span class="line">trs = root.xpath(<span class="string">&#x27;//tr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/06course/data06.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">    tds = tr.xpath(<span class="string">&#x27;./td&#x27;</span>)</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> td <span class="keyword">in</span> tds:</span><br><span class="line">        s = s + <span class="built_in">str</span>(td.xpath(<span class="string">&#x27;string(.)&#x27;</span>)) + <span class="string">&#x27;|&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s!= <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        f.write(s + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p>运行这段代码，会发现是解析不出我们想要的内容的。虽然<code>url</code>、解析逻辑看起来填写的都是正确的，那么问题是出在哪儿呢？其实就是出在<code>url</code>，这个<code>url</code>只是看起来正确，但并不是真正的<code>url</code>（我们想要的，包含内容的）。</p>
<h1 id="2-分析页面"><a href="#2-分析页面" class="headerlink" title="2.分析页面"></a>2.分析页面</h1><p>这时候我们来分析下网页源代码，发现在目标页面代开源码是没有我们想要的内容的，如下图所示：<br><a href="https://imgse.com/i/pAUHxVs"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/10/19/pAUHxVs.png"
                      alt="网页源码.png"
                ><figcaption>网页源码.png</figcaption></figure></a><br>那么这时候我们就得找到 <strong>真实链接</strong> 。</p>
<p>按<code>F12</code>打开浏览器控制台，选择<code>network</code>：<br><a href="https://imgse.com/i/pAUbP2T"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/10/19/pAUbP2T.png"
                      alt="控制台.png"
                ><figcaption>控制台.png</figcaption></figure></a></p>
<p>先看左边（红色框）部分，选中一个，看一下它的<code>preview</code>，如图所示：<br><a href="https://imgse.com/i/pAUbkMF"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/10/19/pAUbkMF.png"
                      alt="preview.png"
                ><figcaption>preview.png</figcaption></figure></a></p>
<p>可以发现没有我们想要的大内容，说明原始的<code>url</code>不对，我们得通过这种方式查找出包含内容的<code>url</code>。可以把后缀是<code>.js</code>和<code>.css</code>的排除掉，这些都是指网页样式。</p>
<p>如下图所示：<br><a href="https://imgse.com/i/pAUbQxO"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/10/19/pAUbQxO.png"
                      alt="pAUbQxO.png"
                ><figcaption>pAUbQxO.png</figcaption></figure></a><br>这个<code>inner</code>才是我们想要的，再看它的<code>headers</code>，我们就能找到它的正确的<code>url = https://www.spiderbuf.cn/playground/inner</code></p>
<p>把这个<code>url</code>替换掉原始<code>url</code>就行了：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&quot;https://www.spiderbuf.cn/playground/inner&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html = requests.get(url=url, headers=headers).text</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;剩余部分的代码不变......&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h1><p>如图所示：<br><a href="https://imgse.com/i/pAUb8qH"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/10/19/pAUb8qH.png"
                      alt="控制台.png"
                ><figcaption>控制台.png</figcaption></figure></a></p>
<p>可以发现在<code>html</code>下还有一个<code>html</code>，称作<code>iframe</code>。就是网页里面嵌套了一个浏览器再打开另一个网页，只有在控制台看它后台的一个请求，才能找出真实的<code>url</code>。</p>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬虫教程 08</title>
    <url>/2024/10/19/08Python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="1-解析网页"><a href="#1-解析网页" class="headerlink" title="1.解析网页"></a>1.解析网页</h1><p>解析网页的步骤与<strong>Python 爬虫教程 07</strong> 的差不多，因为直接用原始的<code>url</code>是无法爬取到数据的，还是需要通过浏览器的控制台才能找到。</p>
<p>原始的<code>url = https://www.spiderbuf.cn/playground/s07</code>。</p>
<p>代码示例：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.spiderbuf.cn/playground/iplist&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(url=url, headers=headers)</span><br><span class="line">response.encoding = <span class="string">&#x27;utf-8&#x27;</span>  <span class="comment"># 设置编码为 utf-8</span></span><br><span class="line">json_data = response.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the raw HTML to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./课程/07course/07.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(json_data)</span><br><span class="line"></span><br><span class="line">ls = json.loads(json_data)</span><br><span class="line"></span><br><span class="line">txt = <span class="built_in">open</span>(<span class="string">&#x27;./课程/07course/data07.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> ls:</span><br><span class="line">    s = <span class="string">f&#x27;<span class="subst">&#123;item[<span class="string">&#x27;ip&#x27;</span>]&#125;</span>|<span class="subst">&#123;item[<span class="string">&#x27;mac&#x27;</span>]&#125;</span>|<span class="subst">&#123;item[<span class="string">&#x27;name&#x27;</span>]&#125;</span>|<span class="subst">&#123;item[<span class="string">&#x27;type&#x27;</span>]&#125;</span>|<span class="subst">&#123;item[<span class="string">&#x27;manufacturer&#x27;</span>]&#125;</span>|<span class="subst">&#123;item[<span class="string">&#x27;ports&#x27;</span>]&#125;</span>|<span class="subst">&#123;item[<span class="string">&#x27;status&#x27;</span>]&#125;</span>\n&#x27;</span></span><br><span class="line">    txt.write(s)</span><br><span class="line"></span><br><span class="line">txt.close()</span><br></pre></td></tr></table></figure></div>

<p>可以看出爬取到的数据是<code>json</code>格式，注意这里的<code>response.encoding = &#39;utf-8&#39; </code>，不设置的话，爬取到的中文内容就是乱码。</p>
<h1 id="2-说明（补充）"><a href="#2-说明（补充）" class="headerlink" title="2.说明（补充）"></a>2.说明（补充）</h1><p><strong>AJAX</strong> （Asynchronous JavaScript and XML）是一种在网页中异步加载数据的技术，它允许在不刷新整个网页的情况下更新页面的部分内容。<strong>动态加载数据</strong> 指的是通过 AJAX 技术从服务器获取数据，并将这些数据动态地插入到当前网页中。这个过程可以是数据的初次加载或用户交互时额外加载的数据，比如滚动页面加载更多内容、点击按钮加载新的数据等。</p>
<h2 id="2-1-AJAX-动态加载数据的关键点"><a href="#2-1-AJAX-动态加载数据的关键点" class="headerlink" title="2.1 AJAX 动态加载数据的关键点"></a>2.1 AJAX 动态加载数据的关键点</h2><ol>
<li><p><strong>异步加载</strong> ：页面不需要刷新，也不会阻塞用户的其他操作。在数据请求发送后，用户可以继续操作页面，等待数据加载完成。</p>
</li>
<li><p><strong>服务器请求</strong> ：AJAX 使用 JavaScript 发起 HTTP 请求（通常是 <code>GET</code> 或 <code>POST</code> 请求）到服务器，从而获取所需的数据。获取的数据格式通常是 JSON、XML 或 HTML。</p>
</li>
<li><p><strong>动态更新</strong> ：当服务器返回数据后，JavaScript 会处理响应数据，并将其插入页面中的特定位置，更新页面的部分内容，而不会刷新整个网页。</p>
</li>
</ol>
<h2 id="2-2-工作流程"><a href="#2-2-工作流程" class="headerlink" title="2.2 工作流程"></a>2.2 工作流程</h2><ol>
<li><strong>用户操作</strong> ：用户的某些操作（如滚动、点击按钮）触发 AJAX 请求。</li>
<li><strong>发送请求</strong> ：通过 JavaScript 使用 <code>XMLHttpRequest</code> 或 <code>fetch</code> API 发送 HTTP 请求到服务器。</li>
<li><strong>服务器响应</strong> ：服务器接收到请求后处理并返回数据（如 JSON、HTML 片段等）。</li>
<li><strong>动态更新页面</strong> ：前端 JavaScript 解析服务器返回的数据，并将其动态插入页面中，使页面内容更新而不需要重新加载整个网页。</li>
</ol>
<h2 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3 示例"></a>2.3 示例</h2><p>假设一个网页有一个按钮，当用户点击按钮时，通过 AJAX 加载一段新的数据并显示在页面中。以下是一个简单的 AJAX 动态加载例子（使用 <code>fetch</code> API）：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>AJAX 动态加载示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>AJAX 动态加载示例<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>这里是初始内容。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;loadDataBtn&quot;</span>&gt;</span>加载更多内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;loadDataBtn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/get-more-data&#x27;</span>) <span class="comment">// 向服务器发送请求，这里的链接就是含有真实数据内容的 url</span></span></span><br><span class="line"><span class="language-javascript">                .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>()) <span class="comment">// 解析返回的 JSON 数据</span></span></span><br><span class="line"><span class="language-javascript">                .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 将新数据动态插入页面中</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>).<span class="property">innerHTML</span> += <span class="string">`&lt;p&gt;<span class="subst">$&#123;data.newContent&#125;</span>&lt;/p&gt;`</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;)</span></span><br><span class="line"><span class="language-javascript">                .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;加载失败:&#x27;</span>, error));</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬虫教程 09</title>
    <url>/2024/10/21/09Python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="1-代码示例"><a href="#1-代码示例" class="headerlink" title="1.代码示例"></a>1.代码示例</h1><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.spiderbuf.cn/playground/s08&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">html = requests.get(url=url, headers=headers).text</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/08course/08.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">f.write(html)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">root = etree.HTML(html)</span><br><span class="line">trs = root.xpath(<span class="string">&#x27;//tr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/08course/data08.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">    tds = tr.xpath(<span class="string">&#x27;./td&#x27;</span>)</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> td <span class="keyword">in</span> tds:</span><br><span class="line">        s = s + <span class="built_in">str</span>(td.xpath(<span class="string">&#x27;string(.)&#x27;</span>)) + <span class="string">&#x27;|&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s!= <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        f.write(s + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p>直接运行这段代码是不会解析出任何数据的，同时可以看到抓取到的网页与我们想要的不一样。</p>
<h1 id="2-网页分析"><a href="#2-网页分析" class="headerlink" title="2,网页分析"></a>2,网页分析</h1><p>打开浏览器控制台，选择<code>network</code>：<br><a href="https://imgse.com/i/pAa40dx"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/10/21/pAa40dx.png"
                      alt="控制台.png"
                ><figcaption>控制台.png</figcaption></figure></a><br>可以发现，请求方式是<code>post</code>。所以我们就得在代码中采用<code>post</code>请求方式：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.spiderbuf.cn/playground/s08&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 传入 post 请求中的数据</span></span><br><span class="line">payload = &#123;<span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;8&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># post 请求</span></span><br><span class="line">html = requests.post(url=url, headers=headers, data=payload).text</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/08course/08.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">f.write(html)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">root = etree.HTML(html)</span><br><span class="line">trs = root.xpath(<span class="string">&#x27;//tr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./课程/08course/data08.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">    tds = tr.xpath(<span class="string">&#x27;./td&#x27;</span>)</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> td <span class="keyword">in</span> tds:</span><br><span class="line">        s = s + <span class="built_in">str</span>(td.xpath(<span class="string">&#x27;string(.)&#x27;</span>)) + <span class="string">&#x27;|&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s!= <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        f.write(s + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><code>payload</code>是在这里：<br><a href="https://imgse.com/i/pAa4oY8"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/10/21/pAa4oY8.png"
                      alt="payload.png"
                ><figcaption>payload.png</figcaption></figure></a></p>
<p>可以参考这里：<a class="link"   href="https://requests.readthedocs.io/projects/cn/zh-cn/latest/user/quickstart.html#post" >更加复杂的 POST 请求<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Conda教程</title>
    <url>/2024/07/19/Conda%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、conda-指令"><a href="#一、conda-指令" class="headerlink" title="一、conda 指令"></a>一、conda 指令</h1><h2 id="1-1-查看配置"><a href="#1-1-查看配置" class="headerlink" title="1.1 查看配置"></a>1.1 查看配置</h2><div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">conda config --show channels    # 查看镜像源</span><br><span class="line">conda config --show-sources        # 查看配置文件内容</span><br></pre></td></tr></table></figure></div>

<h2 id="1-2-设置代理端口"><a href="#1-2-设置代理端口" class="headerlink" title="1.2 设置代理端口"></a>1.2 设置代理端口</h2><div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加代理地址端口</span></span><br><span class="line">conda config --set proxy_servers.http http://127.0.0.1:10809</span><br><span class="line">conda config --set proxy_servers.https http://127.0.0.1:10809</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除代理</span></span><br><span class="line">conda config --remove-key proxy_servers</span><br></pre></td></tr></table></figure></div>

<h2 id="1-3-conda环境"><a href="#1-3-conda环境" class="headerlink" title="1.3 conda环境"></a>1.3 conda环境</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建（带名字）</span></span><br><span class="line">conda create -n &lt;conda_name&gt; python=&lt;版本号&gt;</span><br><span class="line"><span class="comment"># 在指定文件路径下创建conda环境</span></span><br><span class="line">conda create --<span class="built_in">yes</span> --prefix /home/sky/桌面/pointTest/.conda python=3.11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活conda环境</span></span><br><span class="line">conda activate &lt;conda_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到base环境</span></span><br><span class="line">conda deactivate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看有哪些conda环境</span></span><br><span class="line">conda info --envs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除全部环境</span></span><br><span class="line">conda remove -n env_name --all</span><br><span class="line"><span class="comment"># 删除指定环境</span></span><br><span class="line">conda <span class="built_in">env</span> remove -n env_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名环境（将 --clone 后面的环境重命名成 -n 后面的名字）</span></span><br><span class="line">conda create -n torch --<span class="built_in">clone</span> py3      <span class="comment"># 将 py3 重命名为 torch</span></span><br></pre></td></tr></table></figure></div>
<p>注意：<code>--prefix/-p</code>不能与<code>--name/-n</code>同时使用！</p>
<h2 id="1-4-下载库"><a href="#1-4-下载库" class="headerlink" title="1.4 下载库"></a>1.4 下载库</h2><div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从 conda-forge 渠道中提供的包安装</span></span><br><span class="line">conda install -c conda-forge &lt;package_name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询 conda-forge 中的包</span></span><br><span class="line">conda search -c conda-forge &lt;package_name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装指定版本的</span></span><br><span class="line">conda install -c conda-forge &lt;package_name&gt;=&lt;版本号&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="1-4-1-安装GDAL库"><a href="#1-4-1-安装GDAL库" class="headerlink" title="1.4.1 安装GDAL库"></a>1.4.1 安装GDAL库</h3><div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 安装 gdal 的依赖库 geos 和 proj</span></span><br><span class="line">conda install geos proj</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装指定版本GDAL</span></span><br><span class="line">conda install -c conda-forge gdal=3.2.1</span><br></pre></td></tr></table></figure></div>

<h2 id="1-5-迁移-conda-环境"><a href="#1-5-迁移-conda-环境" class="headerlink" title="1.5 迁移 conda 环境"></a>1.5 迁移 conda 环境</h2><p>将要迁移的环境打包</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">conda pack -n 虚拟环境名称 -o environment.tar.gz</span><br></pre></td></tr></table></figure></div>

<p>如果报错：No command ‘conda pack’</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尝试使用</span></span><br><span class="line">conda install -c conda-forge conda-pack</span><br></pre></td></tr></table></figure></div>

<p>复制压缩文件到新的电脑环境。进到conda的安装目录：&#x2F;anaconda(或者miniconda)&#x2F;envs&#x2F;</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对于 ubuntu 可以通过 whereis conda 查看 conda的安装路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> 到 conda 的安装路径</span></span><br><span class="line">mkdir environment</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压conda环境：</span></span><br><span class="line">tar -xzvf environment.tar.gz -C  environment</span><br></pre></td></tr></table></figure></div>

<h1 id="二、pip-指令"><a href="#二、pip-指令" class="headerlink" title="二、pip 指令"></a>二、pip 指令</h1><h2 id="2-1-使用临时镜像源下载库"><a href="#2-1-使用临时镜像源下载库" class="headerlink" title="2.1 使用临时镜像源下载库"></a>2.1 使用临时镜像源下载库</h2><div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">pip install &lt;package_name&gt; -i &lt;镜像源url&gt;</span><br></pre></td></tr></table></figure></div>

<h1 id="三、镜像源"><a href="#三、镜像源" class="headerlink" title="三、镜像源"></a>三、镜像源</h1><div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">https://pypi.tuna.tsinghua.edu.cn/simple    # 清华</span><br><span class="line">https://pypi.mirrors.ustc.edu.cn/simple        # 中科大</span><br><span class="line">http://mirrors.aliyun.com/pypi/simple/        # 阿里云</span><br><span class="line">http://pypi.douban.com/simple/            # 豆瓣</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Debian 下中文乱码问题</title>
    <url>/2025/01/03/Debian%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h1 id="1-安装语言包"><a href="#1-安装语言包" class="headerlink" title="1.安装语言包"></a>1.安装语言包</h1><p>首先需要安装<code>locales</code>这个软件包：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt install locales</span><br></pre></td></tr></table></figure></div>

<p>然后执行下面命令并配置语言环境：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg-reconfigure locales</span><br></pre></td></tr></table></figure></div>

<h1 id="2-修改配置"><a href="#2-修改配置" class="headerlink" title="2.修改配置"></a>2.修改配置</h1><p>修改<code>~/.bashrc</code>文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nano ~/.bashrc</span><br></pre></td></tr></table></figure></div>

<p>添加：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">export LANG=zh_CN.UTF-8</span><br><span class="line">export LANGUAGE=zh_CN:zh</span><br><span class="line">export LC_ALL=zh_CN.UTF-8</span><br></pre></td></tr></table></figure></div>

<p>然后执行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></div>

<h1 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3.参考链接"></a>3.参考链接</h1><ul>
<li><a class="link"   href="https://developer.aliyun.com/article/1143167" >Debian配置系统中文语言及环境<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Debian 系统下，软件包更新和软件下载速度慢的问题</title>
    <url>/2024/12/03/Debian%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    <content><![CDATA[<h1 id="1-问题复现"><a href="#1-问题复现" class="headerlink" title="1.问题复现"></a>1.问题复现</h1><p>在安装后 Debian 系统后，一般第一步都是执行<code>sudo apt update</code>，此时用的是自带的官方镜像源，速度很慢，所以我们会选择切换为国内的镜像源，这里以清华镜像源为例，默认已经配置好了清华镜像源。</p>
<p>在执行更新时：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sky@DESKTOP-IU948AR:~$ <span class="built_in">sudo</span> apt update</span><br><span class="line">[<span class="built_in">sudo</span>] password <span class="keyword">for</span> sky: </span><br><span class="line">Err:1 https://security.debian.org/debian-security bookworm-security InRelease</span><br><span class="line">  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 151.101.2.132 443]</span><br><span class="line">Err:2 https://mirrors.tuna.tsinghua.edu.cn/debian bookworm InRelease</span><br><span class="line">  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 101.6.15.130 443]</span><br><span class="line">Err:3 https://mirrors.tuna.tsinghua.edu.cn/debian bookworm-updates InRelease</span><br><span class="line">  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 101.6.15.130 443]</span><br><span class="line">Err:4 https://mirrors.tuna.tsinghua.edu.cn/debian bookworm-backports InRelease</span><br><span class="line">  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 101.6.15.130 443]</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree... Done</span><br><span class="line">Reading state information... Done</span><br><span class="line">All packages are up to <span class="built_in">date</span>.</span><br><span class="line">W: https://mirrors.tuna.tsinghua.edu.cn/debian/dists/bookworm/InRelease: No system certificates available. Try installing ca-certificates.    </span><br><span class="line">W: https://security.debian.org/debian-security/dists/bookworm-security/InRelease: No system certificates available. Try installing ca-certificates.</span><br><span class="line">W: https://mirrors.tuna.tsinghua.edu.cn/debian/dists/bookworm-updates/InRelease: No system certificates available. Try installing ca-certificates.</span><br><span class="line">W: https://mirrors.tuna.tsinghua.edu.cn/debian/dists/bookworm-backports/InRelease: No system certificates available. Try installing ca-certificates.</span><br><span class="line">W: Failed to fetch https://mirrors.tuna.tsinghua.edu.cn/debian/dists/bookworm/InRelease  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 101.6.15.130 443]</span><br><span class="line">W: Failed to fetch https://mirrors.tuna.tsinghua.edu.cn/debian/dists/bookworm-updates/InRelease  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 101.6.15.130 443]    </span><br><span class="line">W: Failed to fetch https://mirrors.tuna.tsinghua.edu.cn/debian/dists/bookworm-backports/InRelease  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 101.6.15.130 443]  </span><br><span class="line">W: Failed to fetch https://security.debian.org/debian-security/dists/bookworm-security/InRelease  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 151.101.2.132 443]  </span><br><span class="line">W: Some index files failed to download. They have been ignored, or old ones used instead.</span><br><span class="line"></span><br><span class="line">sky@DESKTOP-IU948AR:~$ <span class="built_in">sudo</span> apt install ca-certificates</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree... Done</span><br><span class="line">Reading state information... Done</span><br><span class="line">Package ca-certificates is not available, but is referred to by another package.</span><br><span class="line">This may mean that the package is missing, has been obsoleted, or</span><br><span class="line">is only available from another <span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">E: Package <span class="string">&#x27;ca-certificates&#x27;</span> has no installation candidate</span><br></pre></td></tr></table></figure></div>

<p>可以看出更新失败，需要我们安装<code>ca-certificates</code>，但是又无法成功安装<code>ca-certificates</code>。</p>
<h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h1><p>这个问题的核心是系统无法验证 HTTPS 源的证书，导致无法更新包管理器的索引或安装新软件包。这可能是因为系统缺少必要的 CA 证书或某些配置问题。</p>
<h2 id="2-1-方式一：手动安装ca-certificates包"><a href="#2-1-方式一：手动安装ca-certificates包" class="headerlink" title="2.1 方式一：手动安装ca-certificates包"></a>2.1 方式一：手动安装<code>ca-certificates</code>包</h2><h3 id="2-1-1-下载-DEB-包"><a href="#2-1-1-下载-DEB-包" class="headerlink" title="2.1.1 下载 DEB 包"></a>2.1.1 下载 DEB 包</h3><ol>
<li>在另一台可以正常联网的机器上，访问 <a class="link"   href="https://packages.debian.org/" >Debian Packages<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</li>
<li>下载与系统版本匹配的 <code>ca-certificates</code> 包。例如，适用于 Bookworm 的链接可能是：<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://packages.debian.org/bookworm/all/ca-certificates/download</span><br></pre></td></tr></table></figure></div></li>
<li>使用 USB 或其他方法将下载的 <code>.deb</code> 文件复制到你的系统。</li>
</ol>
<h3 id="2-1-2-手动安装包"><a href="#2-1-2-手动安装包" class="headerlink" title="2.1.2 手动安装包"></a>2.1.2 手动安装包</h3><p>在目标机器上运行以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -i /path/to/ca-certificates*.deb</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="2-2-方式二：临时禁用-HTTPS-验证（推荐）"><a href="#2-2-方式二：临时禁用-HTTPS-验证（推荐）" class="headerlink" title="2.2 方式二：临时禁用 HTTPS 验证（推荐）"></a>2.2 方式二：临时禁用 HTTPS 验证（推荐）</h3><p>可以尝试临时禁用 HTTPS 验证以更新软件源和安装 <code>ca-certificates</code>：</p>
<p>编辑 <code>/etc/apt/apt.conf.d/99disable-https-check</code> 文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/apt/apt.conf.d/99disable-https-check</span><br></pre></td></tr></table></figure></div>

<p>添加以下内容：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquire::https::Verify-Peer &quot;false&quot;;</span><br><span class="line">Acquire::https::Verify-Host &quot;false&quot;;</span><br></pre></td></tr></table></figure></div>

<p>保存后运行以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install ca-certificates</span><br></pre></td></tr></table></figure></div>

<p>安装完 <code>ca-certificates</code> 后，删除或注释掉该配置以恢复安全性。</p>
<p>也可以直接在命令行临时禁用：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt -o Acquire::https::Verify-Peer=<span class="literal">false</span> -o Acquire::https::Verify-Host=<span class="literal">false</span> update</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Docker搭建Hexo博客</title>
    <url>/2024/07/24/Docker-Hexo/</url>
    <content><![CDATA[<h1 id="1-创建项目文件夹"><a href="#1-创建项目文件夹" class="headerlink" title="1.创建项目文件夹"></a>1.创建项目文件夹</h1><p>创建博客的工作</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/Hexo &amp;&amp; <span class="built_in">cd</span> ~/Hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建存放 Dockerfile 的文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> hexo_docker &amp;&amp; <span class="built_in">cd</span> hexo_docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Dockerfile</span></span><br><span class="line"><span class="built_in">touch</span> Dockerfile</span><br></pre></td></tr></table></figure></div>

<h1 id="2-配置-Dockerfile"><a href="#2-配置-Dockerfile" class="headerlink" title="2.配置 Dockerfile"></a>2.配置 Dockerfile</h1><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line">FROM node:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER yourname&lt;youremail@gmail.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line">WORKDIR /hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 npm 使用淘宝镜像源</span></span><br><span class="line">RUN npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Hexo</span></span><br><span class="line">RUN npm install hexo-cli -g</span><br><span class="line">RUN hexo init blog</span><br><span class="line">RUN <span class="built_in">cd</span> blog</span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置git</span></span><br><span class="line">RUN git config --global user.name <span class="string">&quot;loskyertt&quot;</span></span><br><span class="line">RUN git config --global user.email <span class="string">&quot;loskyertt0403@gmail.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 映射端口</span></span><br><span class="line">EXPOSE 4000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行命令</span></span><br><span class="line">CMD [<span class="string">&quot;/bin/bash&quot;</span>]</span><br></pre></td></tr></table></figure></div>

<p>然后构建镜像（和<code>Dockerfile</code>同目录下）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t hexo:latest .</span><br></pre></td></tr></table></figure></div>

<p>Docker 的 BuildKit 可以加速构建过程并启用更多的优化选项，在构建镜像时启用 BuildKit：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">DOCKER_BUILDKIT=1 docker build -t hexo:latest .</span><br></pre></td></tr></table></figure></div>

<h1 id="3-更新镜像"><a href="#3-更新镜像" class="headerlink" title="3.更新镜像"></a>3.更新镜像</h1><p>要在已经构建的基础镜像更新镜像，可以使用以下两种方法：</p>
<h2 id="3-1-方法一：更新现有-Dockerfile-并重建镜像"><a href="#3-1-方法一：更新现有-Dockerfile-并重建镜像" class="headerlink" title="3.1 方法一：更新现有 Dockerfile 并重建镜像"></a>3.1 方法一：更新现有 Dockerfile 并重建镜像</h2><p>更新<code>Dockerfile</code>，然后重新构建镜像。</p>
<h2 id="3-2-方法二：从已有镜像启动容器并手动添加-Hexo"><a href="#3-2-方法二：从已有镜像启动容器并手动添加-Hexo" class="headerlink" title="3.2 方法二：从已有镜像启动容器并手动添加 Hexo"></a>3.2 方法二：从已有镜像启动容器并手动添加 Hexo</h2><ol>
<li><strong>启动一个容器</strong></li>
</ol>
<p>从已有的基础镜像启动一个交互式容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it hexo:latest /bin/bash</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><p><strong>在容器内进行操作</strong></p>
</li>
<li><p><strong>提交容器为新镜像</strong></p>
</li>
</ol>
<p>退出容器（<code>exit</code> 命令），然后提交容器为新镜像：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit &lt;container_id&gt; hexo:with-hexo</span><br></pre></td></tr></table></figure></div>

<p><code>with-hexo</code>是镜像标签，可以自定义。这里的 <code>&lt;container_id&gt;</code> 是刚刚启动的容器的 ID。可以使用 <code>docker ps -a</code> 命令找到它。<br><strong>注意：</strong> 如果要把挂载的宿主机的文件提交到镜像里，需要提前做一个<code>cp</code>操作，即通过<code>docker cp</code>把宿主计内的文件复制到容器内，然后再提交。</p>
<h1 id="4-推送与备份镜像"><a href="#4-推送与备份镜像" class="headerlink" title="4.推送与备份镜像"></a>4.推送与备份镜像</h1><h2 id="4-1-推送镜像到-Docker-Hub"><a href="#4-1-推送镜像到-Docker-Hub" class="headerlink" title="4.1 推送镜像到 Docker Hub"></a>4.1 推送镜像到 Docker Hub</h2><ol>
<li><strong>登录 Docker Hub</strong></li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>标记镜像</strong></li>
</ol>
<p>将镜像标记为你的 Docker Hub 存储库。例如，将 <code>hexo:latest</code> 标记为 <code>yourusername/hexo:latest</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag hexo:latest yourusername/hexo:latest</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>推送镜像</strong></li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker push yourusername/hexo:latest</span><br></pre></td></tr></table></figure></div>

<h2 id="4-1-备份镜像到本地"><a href="#4-1-备份镜像到本地" class="headerlink" title="4.1 备份镜像到本地"></a>4.1 备份镜像到本地</h2><ol>
<li><strong>保存镜像</strong></li>
</ol>
<p>使用 <code>docker save</code> 命令将镜像保存到一个 tar 文件。例如，将 <code>hexo:latest</code> 保存到 <code>hexo_latest.tar</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o hexo_latest.tar hexo:latest</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>加载镜像</strong></li>
</ol>
<p>以后你可以使用 <code>docker load</code> 命令从 tar 文件加载镜像。例如，从 <code>hexo_latest.tar</code> 加载镜像：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i hexo_latest.tar</span><br></pre></td></tr></table></figure></div>

<h1 id="5-挂载容器文件的注意项"><a href="#5-挂载容器文件的注意项" class="headerlink" title="5.挂载容器文件的注意项"></a>5.挂载容器文件的注意项</h1><p>在构建镜像时，已经生成了<code>/hexo/blog</code>目录，如果直接执行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name=<span class="string">&quot;my-blog&quot;</span> -p 4000:4000 -v ~/Hexo/hexo:/hexo hexo:latest /bin/bash</span><br></pre></td></tr></table></figure></div>

<p>这回在主机的<code>~/Hexo/hexo</code>目录和容器内的<code>/hexo</code>目录之间创建一个卷映射。这意味着容器内的<code>/hexo</code>目录会被主机上的<code>~/Hexo</code>目录的内容覆盖。如果主机上的<code>~/Hexo</code>目录是空的或不存在，那么容器内的<code>/hexo</code>目录也会是空的。</p>
<h3 id="5-6-1-解决方法"><a href="#5-6-1-解决方法" class="headerlink" title="5.6.1 解决方法"></a>5.6.1 解决方法</h3><h4 id="方式一、确保主机目录包含内容"><a href="#方式一、确保主机目录包含内容" class="headerlink" title="方式一、确保主机目录包含内容"></a>方式一、确保主机目录包含内容</h4><p>在主机上确保 <code>~/Hexo</code> 目录存在并包含<code>Hexo</code>项目文件。如果目录不存在或为空，可以先在主机上初始化<code>hexo</code>项目：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/Hexo/hexo</span><br><span class="line"><span class="built_in">cd</span> ~/Hexo/hexo</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init .</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></div>

<h4 id="方式二、在容器内初始化-Hexo-项目"><a href="#方式二、在容器内初始化-Hexo-项目" class="headerlink" title="方式二、在容器内初始化 Hexo 项目"></a>方式二、在容器内初始化 Hexo 项目</h4><p>如果希望在容器内初始化 Hexo 项目而不是依赖主机目录，可以先启动一个临时容器，初始化项目，然后将其复制到主机目录：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it hexo:latest /bin/bash</span><br></pre></td></tr></table></figure></div>

<p>在容器内执行以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init /hexo</span><br><span class="line"><span class="built_in">cd</span> /hexo</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></div>

<p>退出容器（<code>exit</code>），然后将容器内的 <code>/hexo</code> 目录复制到主机：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> &lt;container_id&gt;:/hexo ~/Hexo</span><br></pre></td></tr></table></figure></div>

<p>这里的 <code>&lt;container_id&gt;</code> 是你刚刚启动的容器的 ID。可以使用 <code>docker ps -a</code> 命令找到它。</p>
<h1 id="6-最终步骤"><a href="#6-最终步骤" class="headerlink" title="6.最终步骤"></a>6.最终步骤</h1><p>确保主机上的 <code>~/Hexo</code> 目录存在并包含 Hexo 项目文件，然后再次运行 Docker 容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name=<span class="string">&quot;my-blog&quot;</span> -p 4000:4000 -v ~/Hexo/hexo:/hexo hexo:latest /bin/bash</span><br></pre></td></tr></table></figure></div>

<p>这时，容器内的 <code>/hexo</code> 目录将包含主机上 <code>~/Hexo/hexo</code> 目录的内容。</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 配置 MySQL 教程</title>
    <url>/2024/09/05/Docker-MySQL/</url>
    <content><![CDATA[<h1 id="1-Docker-MySQL-配置"><a href="#1-Docker-MySQL-配置" class="headerlink" title="1.Docker-MySQL 配置"></a>1.Docker-MySQL 配置</h1><h2 id="1-1-拉取镜像与创建容器"><a href="#1-1-拉取镜像与创建容器" class="headerlink" title="1.1 拉取镜像与创建容器"></a>1.1 拉取镜像与创建容器</h2><ol>
<li><p><strong>拉取 MySQL 镜像：</strong><br>通过运行 <code>docker pull mysql[:版本号]</code>，版本号可选，默认是latest。</p>
</li>
<li><p><strong>创建并运行 MySQL 容器（推荐）：</strong><br>使用以下命令来运行 MySQL 容器。这里假设想在主机上绑定3306端口，并设置一个root用户的密码：</p>
</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--name some-mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=1234 \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-v ~/docker_volume/mysql/data:/var/lib/mysql \</span><br><span class="line">-v ~/docker_volume/mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">-v ~/docker_volume/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-d mysql:&lt;版本号&gt;</span><br></pre></td></tr></table></figure></div>

<p><strong>以上命令的说明：</strong></p>
<ul>
<li><code>--name some-mysql</code>：给容器指定一个名称，比如 <code>some-mysql</code>。</li>
<li><code>-e MYSQL_ROOT_PASSWORD=1234</code>：设置root用户的密码为 <code>1234</code>。</li>
<li><code>mysql:latest</code>：使用最新版本的 MySQL 镜像。</li>
<li><code>p</code>：设置端口，<code>3306:3306</code>中，前者是宿主机的端口，可以自定义，后者是映射到容器的端口。默认是<code>TCP</code>协议。</li>
<li><code>-v</code>：挂载容器里的文件（<code>~/docker_volume/mysql/data</code>为本地目录）。<strong>注意：</strong> 要先创建好对应的文件路径！！同时本地文件夹会把容器内的文件夹完全覆盖！</li>
</ul>
<h2 id="1-2-连接到容器"><a href="#1-2-连接到容器" class="headerlink" title="1.2 连接到容器"></a>1.2 连接到容器</h2><ol>
<li><strong>连接到 MySQL 容器：</strong></li>
</ol>
<p>进入到容器内部然后进行连接：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it some-mysql bash</span><br><span class="line"></span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure></div>

<p>直接连接到容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it some-mysql mysql -uroot -p</span><br></pre></td></tr></table></figure></div>
<p>这会启动一个终端会话，并要求输入上面设置的root用户的密码 (<code>1234</code>)。</p>
<p>以上命令的说明：</p>
<ol>
<li><strong>docker exec：</strong></li>
</ol>
<ul>
<li><strong>含义：</strong> 在一个已经运行的容器内执行命令。</li>
<li><strong>用途：</strong> 允许你在运行的容器中执行新的命令。</li>
</ul>
<ol start="2">
<li><strong>-it：</strong></li>
</ol>
<ul>
<li><strong><code>-i</code> (interactive)：</strong> 保持标准输入（stdin）打开，使得你可以与容器中的进程进行交互。</li>
<li><strong><code>-t</code> (tty)：</strong> 分配一个伪终端，提供一个终端会话环境。这两个选项一起使用可以进入容器并交互。</li>
</ul>
<ol start="3">
<li><strong>some-mysql：</strong></li>
</ol>
<ul>
<li><strong>含义：</strong> 容器的名称或 ID。</li>
</ul>
<ol start="4">
<li><strong>mysql：</strong></li>
</ol>
<ul>
<li><strong>含义：</strong> 这是在容器内执行的命令。在这个例子中，是启动 MySQL 客户端。</li>
<li><strong>用途：</strong> 连接到 MySQL 数据库。</li>
</ul>
<ol start="5">
<li><strong>-uroot：</strong></li>
</ol>
<ul>
<li><strong><code>-u</code>：</strong> 指定 MySQL 客户端的用户名。</li>
<li><strong>root：</strong> MySQL 数据库的用户名。在这个例子中，使用的是 <code>root</code> 用户。</li>
</ul>
<ol start="6">
<li><strong><code>-p</code>：</strong></li>
</ol>
<ul>
<li><strong>含义：</strong> 提示输入 MySQL 用户的密码。</li>
<li><strong>用途：</strong> 在执行命令后，你会被提示输入 <code>root</code> 用户的密码。这个密码是在运行容器时通过 <code>MYSQL_ROOT_PASSWORD</code> 环境变量设置的。</li>
</ul>
<p>以上命令的 <code>-p 3306:3306</code> 会将主机的3306端口映射到容器的3306端口，这样可以从主机上的MySQL客户端连接到容器中的MySQL服务。</p>
<h2 id="1-3-更改容器信息"><a href="#1-3-更改容器信息" class="headerlink" title="1.3 更改容器信息"></a>1.3 更改容器信息</h2><h3 id="1-3-1-方法一：停止并删除现有容器"><a href="#1-3-1-方法一：停止并删除现有容器" class="headerlink" title="1.3.1 方法一：停止并删除现有容器"></a>1.3.1 方法一：停止并删除现有容器</h3><p>首先，停止并删除现有的 <code>mysql-test</code> 容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker start mysql-test        <span class="comment"># 运行</span></span><br><span class="line">docker stop mysql-test        <span class="comment"># 停止</span></span><br><span class="line">docker <span class="built_in">rm</span> mysql-test        <span class="comment"># 删除</span></span><br></pre></td></tr></table></figure></div>
<p>然后再重新创建<code>mysql-test</code>即可。</p>
<h3 id="1-3-2-方法二：不同的容器名称"><a href="#1-3-2-方法二：不同的容器名称" class="headerlink" title="1.3.2 方法二：不同的容器名称"></a>1.3.2 方法二：不同的容器名称</h3><p>可以使用不同的名称来运行容器，这样就不需要删除现有的容器。例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mysql-test-2 -e MYSQL_ROOT_PASSWORD=0403 -p 3307:3306 -d mysql:latest</span><br></pre></td></tr></table></figure></div>
<p>这样会启动一个新容器，名称为 <code>mysql-test-2</code>，并绑定主机的3307端口到容器的3306端口。</p>
<h2 id="1-4-查看容器信息"><a href="#1-4-查看容器信息" class="headerlink" title="1.4 查看容器信息"></a>1.4 查看容器信息</h2><p>查看容器或镜像内部信息（如端口，ip地址，挂载卷等）：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect &lt;容器名/容器ID/镜像名/镜像ID&gt;</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Openwrt 在 Docker 下运行并作为旁路由</title>
    <url>/2024/07/30/Docker-Openwrt/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>这几天想试着玩一下<code>Openwrt</code>来作旁路由，但是又没有软路由固件，后来考虑到<code>Openwrt</code>也是基于 Linux 的，那么在 Docker Hub 上应该有其对应的镜像吧，然后查了下果真有。于是有了后续的操作 … …</p>
<p><strong>推荐的镜像：</strong> <a class="link"   href="https://hub.docker.com/r/zzsrv/openwrt" >zzsrv&#x2F;openwrt<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h1><p>建议是在虚拟机上安装一个 Linux 系统，我在实体机上（Linux 系统）试了下，是能成功，但是在该电脑上无法访问<code>Openwrt</code>的 <code>ip</code>地址，在其它设备（比如手机）能正常访问（需要多做一些配置）。</p>
<h2 id="2-1-虚拟机安装"><a href="#2-1-虚拟机安装" class="headerlink" title="2.1 虚拟机安装"></a>2.1 虚拟机安装</h2><p>虚拟机在这里只推荐<code>VirtualBox</code>。<a class="link"   href="https://www.virtualbox.org/wiki/Downloads" >下载地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>还需要下载插件：<a class="link"   href="https://download.virtualbox.org/virtualbox/7.0.20/Oracle_VM_VirtualBox_Extension_Pack-7.0.20.vbox-extpack" >点这里<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>或者点图片这里红色方框处的下载连接：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://im.gurl.eu.org/file/15123858a31e537afcf88.png"
                      alt="图一"
                ><figcaption>图一</figcaption></figure></p>
<p>下载完后直接双击下载好后的扩展，就能自动安装到 VirtualBox 中。</p>
<h2 id="2-2-Linux安装"><a href="#2-2-Linux安装" class="headerlink" title="2.2 Linux安装"></a>2.2 Linux安装</h2><p>推荐的 Linux 发行版：</p>
<ul>
<li><a class="link"   href="https://endeavouros.com/#Download" >EndeavourOS<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> </li>
<li><a class="link"   href="https://cachyos.org/download/" >CachyOS<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，建议下载<code>Desktop Edition</code>版本</li>
<li><a class="link"   href="https://www.linuxmint.com/download.php" >LinuxMint<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，建议下载<code>Xfce Edition</code>版本</li>
</ul>
<p>前两个是<code>Arch</code>系的发行版，<code>LinuxMint</code>应该是<code>Debian</code>系的发行版。我这里用的是<code>CachyOS</code>，因为正好想尝试下这个发行版，好处是配置有国内的镜像源，下载东西嘎嘎快。<br>在安装时最好选择有桌面环境，并且桌面选择<code>xfce4</code>，毕竟轻量嘛，在虚拟机里用着也会更流畅。当然，也可以不需要桌面环境，那么在安装时就必须把语言设置为英语，因为终端界面的中文会是乱码，而且没有图形化界面也不好配置。</p>
<h2 id="2-3-虚拟机的创建"><a href="#2-3-虚拟机的创建" class="headerlink" title="2.3 虚拟机的创建"></a>2.3 虚拟机的创建</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://im.gurl.eu.org/file/bd3ae00cf631639f8637d.png"
                      alt="step1"
                ><figcaption>step1</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://im.gurl.eu.org/file/d29cd0f0a8b49c85eba19.png"
                      alt="step2"
                ><figcaption>step2</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://im.gurl.eu.org/file/5fa57afd8c3f1ce85dbaf.png"
                      alt="step3"
                ><figcaption>step3</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://im.gurl.eu.org/file/3238679faab643583e0d2.png"
                      alt="step3"
                ><figcaption>step3</figcaption></figure></p>
<h2 id="2-4-虚拟机的配置"><a href="#2-4-虚拟机的配置" class="headerlink" title="2.4 虚拟机的配置"></a>2.4 虚拟机的配置</h2><p>创建完虚拟机后，需要对其进行配置：</p>
<ul>
<li><p>网络配置：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://im.gurl.eu.org/file/c0ac4b0af36dd0d8d8669.png"
                      alt="step1"
                ><figcaption>step1</figcaption></figure></p>
</li>
<li><p>显示配置<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://im.gurl.eu.org/file/30d7d1cc582bb21af4a3e.png"
                      alt="step2"
                ><figcaption>step2</figcaption></figure></p>
</li>
<li><p>镜像挂载<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://im.gurl.eu.org/file/fe9361ef16f1efec66bf1.png"
                      alt="step3"
                ><figcaption>step3</figcaption></figure></p>
</li>
</ul>
<h2 id="2-5-安装系统"><a href="#2-5-安装系统" class="headerlink" title="2.5 安装系统"></a>2.5 安装系统</h2><p>然后就是安装 Linux 系统，网上有很多教程，就不在这里讲了。</p>
<h1 id="3-Docker-配置"><a href="#3-Docker-配置" class="headerlink" title="3.Docker 配置"></a>3.Docker 配置</h1><h2 id="3-1-安装-Docker"><a href="#3-1-安装-Docker" class="headerlink" title="3.1 安装 Docker"></a>3.1 安装 Docker</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pamcn -S docker</span><br></pre></td></tr></table></figure></div>

<p>可以通过下面指令查看是否安装成功：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker version</span><br></pre></td></tr></table></figure></div>
<p>如果输出类似下面内容就代表安装成功：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">Client:</span><br><span class="line"> Version:           27.1.1</span><br><span class="line"> API version:       1.46</span><br><span class="line"> Go version:        go1.22.5</span><br><span class="line"> Git commit:        63125853e3</span><br><span class="line"> Built:             Thu Jul 25 17:06:22 2024</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          27.1.1</span><br><span class="line">  API version:      1.46 (minimum version 1.24)</span><br><span class="line">  Go version:       go1.22.5</span><br><span class="line">  Git commit:       cc13f95251</span><br><span class="line">  Built:            Thu Jul 25 17:06:22 2024</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          v1.7.20</span><br><span class="line">  GitCommit:        8fc6bcff51318944179630522a095cc9dbf9f353.m</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.1.13</span><br><span class="line">  GitCommit:        </span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        de40ad0</span><br></pre></td></tr></table></figure></div>

<p>这里就不把当前用户组添加到<code>docker</code>了，总之记住，后续 <code>docker</code>的所有操作，都得用<code>sudo docker</code>。</p>
<h2 id="3-2-Docker-服务配置"><a href="#3-2-Docker-服务配置" class="headerlink" title="3.2 Docker 服务配置"></a>3.2 Docker 服务配置</h2><ul>
<li><p>开机自启动：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>运行<code>docker</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h1 id="4-虚拟机内的网络配置"><a href="#4-虚拟机内的网络配置" class="headerlink" title="4.虚拟机内的网络配置"></a>4.虚拟机内的网络配置</h1><h2 id="4-1-查看网络接口信息"><a href="#4-1-查看网络接口信息" class="headerlink" title="4.1 查看网络接口信息"></a>4.1 查看网络接口信息</h2><ul>
<li><p>查看网络接口：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者（不一定能用，可能没有预装 net-tools）</span></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">~</span><br><span class="line">❯ ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:ff:93:f7 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.2.23/24 brd 192.168.2.255 scope global dynamic noprefixroute enp0s3</span><br><span class="line">       valid_lft 85878sec preferred_lft 85878sec</span><br><span class="line">    inet6 fe80::d521:edc1:580f:1e00/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:8a:53:e6:cf brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>这里需要着重记下第二个<code>enp0s3</code>接口，第一个和第三个不用管。从<code>inet 192.168.2.23/24</code>可以知道虚拟机的<code>ipaddr</code>是<code>192.168.2.23</code>。</p>
<p><strong>下面是三个网络接口的详细解释：</strong></p>
<ol>
<li><strong><code>lo</code>（Loopback接口）</strong></li>
</ol>
<ul>
<li><strong>描述：</strong>  这是本地回环接口，用于主机内部的网络通信。它的IP地址是<code>127.0.0.1</code>，也被称为<code>localhost</code>。</li>
<li><strong>属性</strong>:<ul>
<li><strong>IP 地址：</strong> <code>127.0.0.1/8</code> 和 <code>::1/128</code></li>
<li><strong>用途：</strong> 允许主机内部进程进行网络通信，而不实际发送数据到网络接口外部。适用于测试和进程间通信。</li>
<li><strong>状态：</strong> 总是<code>UP</code>，表示接口始终可用。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong><code>enp0s3</code>（以太网接口）</strong></li>
</ol>
<ul>
<li><strong>描述：</strong> 这是一个物理以太网接口，通常用于连接到网络交换机或路由器。</li>
<li><strong>属性：</strong> <ul>
<li><strong>MAC 地址：</strong> <code>08:00:27:ff:93:f7</code></li>
<li><strong>IP 地址：</strong> <code>192.168.2.23/24</code>（子网掩码为255.255.255.0），它的广播地址是<code>192.168.2.255</code>。</li>
<li><strong>IPv6 地址：</strong> <code>fe80::d521:edc1:580f:1e00/64</code></li>
<li><strong>状态：</strong> <code>UP</code>，表示接口已激活并连接到网络。</li>
<li><strong>用途：</strong> 用于连接到局域网或互联网，并提供主机的网络连接。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong><code>docker0</code>（Docker虚拟网桥）</strong></li>
</ol>
<ul>
<li><strong>描述：</strong> 这是Docker默认创建的虚拟网桥，所有未指定其他网络的Docker容器默认连接到这个桥接网络。</li>
<li><strong>属性</strong>:<ul>
<li><strong>MAC 地址：</strong> <code>02:42:8a:53:e6:cf</code></li>
<li><strong>IP 地址：</strong> <code>172.17.0.1/16</code>，这是Docker的默认子网，用于容器之间的网络通信。</li>
<li><strong>状态：</strong> <code>DOWN</code>，表示虚拟网桥目前没有活动的连接。即使接口状态是<code>DOWN</code>，Docker可以在需要时自动启用它。</li>
<li><strong>用途：</strong> 提供一个虚拟的网络环境，使Docker容器能够互相通信并访问网络。</li>
</ul>
</li>
</ul>
<h2 id="4-2-开启混杂模式-promisc"><a href="#4-2-开启混杂模式-promisc" class="headerlink" title="4.2 开启混杂模式(promisc)"></a>4.2 开启混杂模式(promisc)</h2><p>开启网卡混杂模式，且虚拟机和docker里都要开启网卡混杂模式，这里网卡标记根据自己的填写：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> enp0s3 promisc on</span><br></pre></td></tr></table></figure></div>
<p>注意：在我这里是对<code>enp0s3</code>，但是每台电脑情况可能不一样，反正肯定是有<code>ipaddr</code>的这个网络接口名。</p>
<h2 id="4-3-建立-docker-子网"><a href="#4-3-建立-docker-子网" class="headerlink" title="4.3 建立 docker 子网"></a>4.3 建立 docker 子网</h2><p>专门建立一个子网，且该网络与家里的局域网在一个网段，网段和网关填自己的：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker network create -d macvlan --subnet=192.168.2.0/24 --gateway=192.168.2.1 -o parent=enp0s3 macnet</span><br></pre></td></tr></table></figure></div>
<p>参数说明：</p>
<ul>
<li><code>subnet</code>是要写你自己路由器所在的那个 <strong>网段</strong> 。</li>
<li><code>gateway</code>是要写你自己路由器所在的那个 <strong>网关</strong> ，也就是路由器的<code>ipaddr</code>。</li>
<li><code>parent</code>是虚拟（子）网卡的真实父级网卡，也就是刚才看的本地网卡（第二个网络接口）。</li>
<li><code>macnet</code>是子网名。</li>
</ul>
<p>可以查看网卡是否创建成功：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">2731fcf199c8   bridge    bridge    local</span><br><span class="line">556f62e40e30   host      host      local</span><br><span class="line">877d2632a9d1   macnet    macvlan   local</span><br><span class="line">5864881e2dd0   none      null      local</span><br></pre></td></tr></table></figure></div>

<p>解释：<br>这四个网络接口是在Docker中使用的不同类型的网络驱动程序。每个网络驱动程序具有不同的用途和功能：</p>
<ol>
<li><strong><code>bridge</code> 网络</strong></li>
</ol>
<ul>
<li><strong>驱动程序</strong> : <code>bridge</code></li>
<li><strong>作用</strong>: 默认的网络驱动程序，提供容器之间的网络通信。它创建了一个虚拟网络桥（<code>docker0</code>），所有使用<code>bridge</code>网络的容器都会连接到这个桥上。</li>
<li><strong>使用场景</strong> : 当你使用Docker创建容器并不指定自定义网络时，Docker默认会将容器连接到<code>bridge</code>网络。容器可以通过这个网络相互通信，也可以访问宿主机的网络。</li>
</ul>
<ol start="2">
<li><strong><code>host</code> 网络</strong></li>
</ol>
<ul>
<li><strong>驱动程序：</strong> <code>host</code></li>
<li><strong>作用</strong> : 将容器的网络堆栈与宿主机的网络堆栈直接连接。这意味着容器不会获得一个独立的<code>IP</code>地址，而是使用宿主机的<code>IP</code>地址。容器内的网络设置将与宿主机相同。</li>
<li><strong>使用场景</strong>: 当你需要容器与宿主机之间的网络高度集成，或者需要容器直接使用宿主机的网络接口时，使用<code>host</code>网络。常用于性能优化或特殊网络配置需求。</li>
</ul>
<ol start="3">
<li><strong><code>macnet</code> 网络</strong></li>
</ol>
<ul>
<li><strong>驱动程序：</strong> <code>macvlan</code></li>
<li><strong>作用</strong>: 提供MAC地址级别的网络隔离。每个连接到<code>macvlan</code>网络的容器可以被分配一个独立的MAC地址，从而在网络中表现为独立的物理设备。</li>
<li><strong>使用场景：</strong> 当需要在物理网络中隔离不同的容器，并且每个容器需要有一个独立的MAC地址时，使用<code>macvlan</code>网络。适用于需要直接与物理网络交换数据的容器，例如在一些网络设备上工作时。</li>
</ul>
<ol start="4">
<li><strong><code>none</code> 网络</strong></li>
</ol>
<ul>
<li><strong>驱动程序：</strong> <code>null</code></li>
<li><strong>作用：</strong> 容器不使用任何网络接口。它会创建一个没有网络连接的容器环境。</li>
<li><strong>使用场景：</strong> 当你希望容器完全隔离于网络之外，不与任何网络通信时，使用<code>none</code>网络。这适用于需要完全网络隔离的容器场景，如某些安全或测试需求。</li>
</ul>
<p>删除网卡(前提是要停止正在使用该网卡的容器)：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker network <span class="built_in">rm</span> &lt;网卡名&gt;</span><br></pre></td></tr></table></figure></div>

<h1 id="5-搭建-Openwrt"><a href="#5-搭建-Openwrt" class="headerlink" title="5.搭建 Openwrt"></a>5.搭建 Openwrt</h1><h2 id="5-1-拉取镜像"><a href="#5-1-拉取镜像" class="headerlink" title="5.1 拉取镜像"></a>5.1 拉取镜像</h2><p>可以通过阿里云镜像提升镜像拉取速度：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker pull registry.cn-hangzhou.aliyuncs.com/zzsrv/openwrt:latest</span><br></pre></td></tr></table></figure></div>

<h2 id="5-2-创建容器"><a href="#5-2-创建容器" class="headerlink" title="5.2 创建容器"></a>5.2 创建容器</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run --restart always --name opt3 -d --network macnet --ip 192.168.2.3 --privileged registry.cn-hangzhou.aliyuncs.com/zzsrv/openwrt:latest /sbin/init</span><br></pre></td></tr></table></figure></div>
<p>参数说明：</p>
<ul>
<li><code>run --restart</code>：设置容器的重启策略为“总是重启”。如果容器停止或<code>Docker</code>守护进程重启，<code>Docker</code>将自动重启这个容器。</li>
<li><code>--network macnet</code>：指定容器连接到名为<code>macnet</code>（我们刚刚创的那个子网卡）的<code>Docker</code>网络。</li>
<li><code>--ip 192.168.2.3</code>：为容器分配一个静态IP地址<code>192.168.2.3</code>，在<code>macnet</code>网络范围内。一定要确保该<code>IP</code>地址在网络的子网中并且未被其他设备占用。</li>
<li><code>/sbin/init</code>：容器启动时要执行的命令或程序。容器将运行<code>/sbin/init</code>，这是 Openwrt系统中的初始化进程，通常是启动系统的第一步。</li>
</ul>
<h2 id="5-3-容器配置"><a href="#5-3-容器配置" class="headerlink" title="5.3 容器配置"></a>5.3 容器配置</h2><p>进入容器内部：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> -it opt3 /bin/sh</span><br></pre></td></tr></table></figure></div>

<p>配置网络：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/config/network</span><br></pre></td></tr></table></figure></div>
<p>按<code>i</code>键进入编辑，<code>esc</code>键退出编辑，<code>:wq</code>保存并退出。<br>需要把<code>ipaddr</code>设置为在创建容器时设置的<code>IP</code>，即<code>192.168.2.3</code>；<code>gateway</code>和<code>dns</code>都设置为网关地址（路由器地址），我的是<code>192.168.2.1</code>。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://im.gurl.eu.org/file/5cbd9d8cdb9722e37a8eb.png"
                      alt="如图所示"
                ><figcaption>如图所示</figcaption></figure></p>
<p>重置网络使网络配置生效：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/network restart</span><br></pre></td></tr></table></figure></div>

<p>到这一步，整个流程就彻底结束了，回到主机，在浏览器输入地址<code>192.168.2.3</code>（你自己的容器设置的<code>IP</code>地址），应该就能进入<code>Openwrt</code>的登录界面了，默认是没有密码可以直接点击登录的。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://im.gurl.eu.org/file/e906fa1645fab9b347b8d.png"
                      alt="登录界面"
                ><figcaption>登录界面</figcaption></figure></p>
<p>后面我先学一下怎么用<code>OpenClash</code>，然后更新用<code>OpenClash</code>科学上网的教程。</p>
<h1 id="6-实体机中安装-docker-OpenWrt-的配置"><a href="#6-实体机中安装-docker-OpenWrt-的配置" class="headerlink" title="6.实体机中安装 docker + OpenWrt 的配置"></a>6.实体机中安装 docker + OpenWrt 的配置</h1><h2 id="6-1-问题说明"><a href="#6-1-问题说明" class="headerlink" title="6.1 问题说明"></a>6.1 问题说明</h2><p>前面的步骤与在虚拟机中的一样，但是在创建并配置好 OpenWrt 的容器后，你会发现在宿主机中无法访问<code>192.168.2.3</code>（创建的容器的ip addr），但是其它设备（前提是在同一个网关下，比如手机）是能成功访问<code>192.168.2.3</code>的。</p>
<p><strong>原因：</strong></p>
<p>在<code>Docker</code>中使用<code>macvlan</code>网络驱动时，容器和宿主机的网络栈是分离的。这意味着：</p>
<ul>
<li>容器的网络接口<code>192.168.2.3</code>是在<code>macvlan</code>网络上，而宿主机的网络接口不能直接与<code>macvlan</code>网络中的容器进行通信。</li>
<li>因为<code>macvlan</code>网络的特性，宿主机的网络接口不会自动知道<code>macvlan</code>网络中的设备。</li>
</ul>
<h2 id="6-2-解决办法"><a href="#6-2-解决办法" class="headerlink" title="6.2 解决办法"></a>6.2 解决办法</h2><h3 id="6-2-1-创建-maclan-接口"><a href="#6-2-1-创建-maclan-接口" class="headerlink" title="6.2.1 创建 maclan 接口"></a>6.2.1 创建 maclan 接口</h3><p>创建一个名为<code>macvlan0</code>的新虚拟网络接口，它基于物理接口<code>enp0s3</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> add macvlan0 <span class="built_in">link</span> enp0s3 <span class="built_in">type</span> macvlan mode bridge</span><br></pre></td></tr></table></figure></div>
<p><code>macvlan</code>允许在一个物理网络接口上创建多个虚拟网络接口，每个都有自己的 MAC 地址。桥接模式允许 macvlan 接口相互通信。</p>
<p>为这个新接口分配了 IP 地址<code>192.168.2.250</code>，使其成为<code>192.168.2.0/24</code>网络的一部分：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip addr add 192.168.2.250/24 dev macvlan0</span><br></pre></td></tr></table></figure></div>
<p>激活这个新接口，使其能够开始网络通信：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> macvlan0 up</span><br></pre></td></tr></table></figure></div>

<p>注意需要把<code>enp0s3</code>替换为自己实际的网络驱动接口。这个时候在浏览器输入<code>192.168.2.3</code>就拿正常访问了。</p>
<p>这种配置的主要用途是允许主机直接参与到<code>macvlan</code>网络中，这对于与 Docker macvlan 网络中的容器通信特别有用。它创建了一个”桥梁”，让主机能够与 macvlan 网络中的设备（如 Docker 容器）进行直接通信，而不需要通过 Docker 的网络栈。</p>
<h3 id="6-2-2-撤销创建的-macvlan-配置"><a href="#6-2-2-撤销创建的-macvlan-配置" class="headerlink" title="6.2.2 撤销创建的 macvlan 配置"></a>6.2.2 撤销创建的 macvlan 配置</h3><p>如果要删除创建的<code>macvlan</code>接口，可以进行以下操作：</p>
<ol>
<li>删除 IP 地址:<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip addr del 192.168.2.250/24 dev macvlan0</span><br></pre></td></tr></table></figure></div></li>
<li>关闭 macvlan 接口:<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> macvlan0 down</span><br></pre></td></tr></table></figure></div></li>
<li>删除 macvlan 接口:<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> del macvlan0</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>解释：</p>
<ul>
<li><code>ip addr del</code>: 删除之前添加的 IP 地址</li>
<li><code>ip link set down</code>: 关闭网络接口</li>
<li><code>ip link del</code>: 完全删除网络接口</li>
</ul>
<p>执行这些命令后，你创建的<code>macvlan</code>接口及其配置就会被完全移除。</p>
<p>额外提示：</p>
<h3 id="6-2-3-查看当前配置"><a href="#6-2-3-查看当前配置" class="headerlink" title="6.2.3  查看当前配置:"></a>6.2.3  查看当前配置:</h3><p>   在执行这些步骤之前和之后，你可以使用以下命令查看网络配置，以确保更改已经生效：<br>   <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr show</span><br><span class="line">ip <span class="built_in">link</span> show</span><br></pre></td></tr></table></figure></div></p>
<ol start="2">
<li><p>保存配置:<br>如果你经常需要切换这些配置，可以考虑创建脚本来自动化这个过程。例如，创建一个脚本来添加配置，另一个脚本来删除配置。</p>
</li>
<li><p>系统重启:<br>请注意，这些更改在系统重启后不会保持。如果你希望这些更改是永久的，需要将它们添加到网络配置文件中或创建一个系统启动脚本。</p>
</li>
<li><p>小心操作:<br>在执行这些命令时要小心，特别是如果你是通过远程连接（如 SSH）管理系统。错误的网络配置可能会导致你失去对系统的访问。</p>
</li>
</ol>
<h1 id="7-参考教程"><a href="#7-参考教程" class="headerlink" title="7.参考教程"></a>7.参考教程</h1><ul>
<li><a class="link"   href="https://www.youtube.com/watch?v=6OeGOK2-1zo&list=PL7XUZPsvfw3CKvDijuA5CO_oLbBwJCYTt&index=4" >docker + openwrt把windows变成最强软路由，游戏、翻墙两不误(Linux-Mint&#x2F;ubuntu、VirtualBox、docker、openwrt)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.youtube.com/watch?v=mlsTzDsBhLs&list=PL7XUZPsvfw3CKvDijuA5CO_oLbBwJCYTt&index=6" >Openwrt Docker 镜像 安装详细过程实现科学上网，没有设备也可以体验|软路由|旁路网关<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://hub.docker.com/r/zzsrv/openwrt" >zzsrv&#x2F;openwrt<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
        <tag>proxy</tag>
        <tag>openwrt</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile 教程</title>
    <url>/2024/09/03/Dockerfile%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-代理配置"><a href="#1-代理配置" class="headerlink" title="1.代理配置"></a>1.代理配置</h1><p>有时侯在构建镜像时，需要执行一些下载操作，没有配置国内镜像源的话，下载速度可能会很慢甚至出错，所以需要在 Dockerfile 中配置代理。</p>
<p>在 Dockerfile 中加上：</p>
<div class="code-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> http_proxy=http://your-proxy-address:port/</span><br><span class="line"><span class="keyword">ENV</span> https_proxy=http://your-proxy-address:port/</span><br></pre></td></tr></table></figure></div>

<p><code>http_proxy</code>和<code>https_proxy</code>：这两个环境变量分别用于<code>HTTP</code>和<code>HTTPS</code>的代理服务器地址。你需要将<code>your-proxy-address:port</code>替换为宿主机在当前网络下的 IP 地址和代理端口。注意这里是宿主机的实际<code>IP</code>地址，不是本地回环（<code>loop</code>）地址。同过<code>ifconfig</code>或者<code>ip a</code>查看。</p>
<p>这属于是 docker 的环境变量设置，环境变量通常不会自动写入容器中的配置文件，如<code>.bashrc</code>或<code>/etc/environment</code>，但它们会在容器启动时自动加载。</p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 搭建深度学习环境</title>
    <url>/2024/09/09/Docker%E6%90%AD%E5%BB%BADL%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="1-安裝NVIDIA-Container-Toolkit套件"><a href="#1-安裝NVIDIA-Container-Toolkit套件" class="headerlink" title="1.安裝NVIDIA Container Toolkit套件"></a>1.安裝NVIDIA Container Toolkit套件</h1><p>对于 Arch 系发行版，可以直接通过下面指令安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S nvidia-container-toolkit</span><br></pre></td></tr></table></figure></div>

<p>然后新增设定：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> nano /etc/docker/daemon.json</span><br></pre></td></tr></table></figure></div>

<p>添加：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;runtimes&quot;: &#123;</span><br><span class="line">        &quot;nvidia&quot;: &#123;</span><br><span class="line">            &quot;path&quot;: &quot;nvidia-container-runtime&quot;,</span><br><span class="line">            &quot;runtimeArgs&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>重启 Docker ：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure></div>

<p>拉取CUDA 12.1版本的镜像测试：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run --<span class="built_in">rm</span> --gpus all nvidia/cuda:12.1.0-base-ubuntu20.04 nvidia-smi</span><br></pre></td></tr></table></figure></div>
<p>检查是否能在容器中运行<code>nvidia-smi</code>：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ivonblog.com/posts/archlinux-install-nvidia-drivers/images/Screenshot_20231226_160611.webp"
                      alt="nvidia-smi"
                ><figcaption>nvidia-smi</figcaption></figure></p>
<h1 id="2-各个-CUDA-tag的区别"><a href="#2-各个-CUDA-tag的区别" class="headerlink" title="2.各个 CUDA tag的区别"></a>2.各个 CUDA <code>tag</code>的区别</h1><p>其它 CUDA 镜像可以通过在 DockerHub 找到：<a class="link"   href="https://hub.docker.com/r/nvidia/cuda" >nvidia&#x2F;cuda<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ol>
<li><strong>Base</strong> : Includes only the CUDA runtime (cudart), which is essential for running CUDA-based applications but doesn’t come with extra libraries or development tools.</li>
<li><strong>Runtime</strong> : Builds on the <code>base</code> image and adds CUDA math libraries like cuBLAS, cuFFT, and cuRAND. This version is suitable for running applications that require these additional libraries without needing to compile CUDA code.</li>
<li><strong>Devel</strong> : Builds on the <code>runtime</code> image and includes all the necessary headers and development tools like <code>nvcc</code> for compiling and building CUDA applications. This is useful for developers building or extending CUDA applications.</li>
<li><strong>CUDNN&#x2F;Devel Runtime</strong> : Adds cuDNN libraries to the runtime or devel image for working with deep learning applications.</li>
</ol>
<p>Different versions also support various operating systems like Ubuntu 20.04, 22.04, or 24.04. The <code>devel</code> tags are especially useful when you need to compile custom CUDA code, whereas the <code>runtime</code> tags are lighter and designed for deployment【76†source】【77†source】.</p>
<h1 id="3-搭建-PyTorch"><a href="#3-搭建-PyTorch" class="headerlink" title="3.搭建 PyTorch"></a>3.搭建 PyTorch</h1><p>根据需要拉取<code>PyTorch</code>镜像：<a class="link"   href="https://hub.docker.com/r/pytorch/pytorch" >pytorch&#x2F;pytorch<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>我这里以最新版为例：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull pytorch/pytorch</span><br></pre></td></tr></table></figure></div>

<p>可以先查看下镜像内容（比如端口、挂载点）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect pytorch/pytorch:latest</span><br></pre></td></tr></table></figure></div>
<p>这个镜像的默认挂载点是<code>/workspace</code>。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name=pytorch -v ~/workspace:/workspace -p 8888:8888 pytorch/pytorch:latest</span><br></pre></td></tr></table></figure></div>
<p>这里映射的端口是<code>jupyter</code>的。需要在容器里手动安装<code>jupyter</code>。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">conda install jupyter</span><br></pre></td></tr></table></figure></div>

<p>运行<code>jupyter</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter lab --ip=0.0.0.0 --no-browser --allow-root</span><br></pre></td></tr></table></figure></div>
<p>启动<code>Jupyter Lab</code>时，默认情况下它只绑定到<code>localhost</code>，并不会对外开放。所以你需要明确绑定<code>0.0.0.0</code>，以便它能从容器外部访问。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 Docker 搭建 PCL 环境</title>
    <url>/2024/11/30/Docker%E6%90%AD%E5%BB%BAPCL%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="1-在容器内部构建"><a href="#1-在容器内部构建" class="headerlink" title="1.在容器内部构建"></a>1.在容器内部构建</h1><p>个人推荐使用这种方式，用<code>Dockerfile</code>总会出奇奇怪怪的问题。</p>
<h2 id="1-1-运行容器"><a href="#1-1-运行容器" class="headerlink" title="1.1 运行容器"></a>1.1 运行容器</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name=pcl ubuntu:latest</span><br></pre></td></tr></table></figure></div>

<h2 id="1-2-容器内部配置"><a href="#1-2-容器内部配置" class="headerlink" title="1.2 容器内部配置"></a>1.2 容器内部配置</h2><p>在宿主机中创建一个<code>sources.list</code>文件，里面添加下面内容：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换</span><br><span class="line"># deb http://security.ubuntu.com/ubuntu/ noble-security main restricted universe multiverse</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu/ noble-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-proposed main restricted universe multiverse</span><br><span class="line"># # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure></div>
<p>详细配置可以见：<a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" >Ubuntu 清华镜像源<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>然后把该文件复制<code>pcl</code>到容器中：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> sources.list pcl:/etc/apt</span><br></pre></td></tr></table></figure></div>

<p>在容器内执行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure></div>

<p>如果更新失败，大概率是会报找不到<code>certificates</code>这样的错误。直接安装好<code>ca-certificates</code>即可：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt install ca-certificates</span><br></pre></td></tr></table></figure></div>

<p>然后重新执行<code>apt update</code>即可更新成功。</p>
<p>最后再执行一遍：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt upgrade</span><br></pre></td></tr></table></figure></div>

<h2 id="1-3-配置-PCL-和-C-环境"><a href="#1-3-配置-PCL-和-C-环境" class="headerlink" title="1.3 配置 PCL 和 C++ 环境"></a>1.3 配置 PCL 和 C++ 环境</h2><p><code>PCL</code>可以直接通过 Ubuntu 的软件包管理器安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y libpcl-dev</span><br></pre></td></tr></table></figure></div>
<p>这会自动安装<code>PCL</code>的核心库和常见的依赖项，如<code>Eigen</code>、<code>FLANN</code>和<code>VTK</code>。</p>
<p>验证PCL是否正确安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pkg-config --modversion pcl_common</span><br></pre></td></tr></table></figure></div>
<p>如果安装成功，会显示PCL的版本号，例如<code>1.12.1</code>。</p>
<p>如果需要<code>PCL</code>的可视化模块（基于<code>VTK</code>），可以确保安装以下依赖：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt install libvtk7-dev</span><br></pre></td></tr></table></figure></div>
<p>然后，使用<code>pcl_visualization</code>模块来实现点云的 3D 可视化。</p>
<p>安装其它工具：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt install -y cmake clang clangd libomp-dev</span><br></pre></td></tr></table></figure></div>

<p>如果不想<code>clangd</code>的语法提示出幺蛾子（避免报找不到<code>omp.h</code>的错误），最好把<code>libomp-dev</code>安装好。</p>
<p>安装<code>x11</code>服务（为了显示程序的<code>ui</code>）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt install x11-apps</span><br></pre></td></tr></table></figure></div>

<p>最后通过 VSCode 连接到容器内部即可。</p>
<h2 id="1-4-libomp-dev-是什么？（补充，可以跳过）"><a href="#1-4-libomp-dev-是什么？（补充，可以跳过）" class="headerlink" title="1.4 libomp-dev 是什么？（补充，可以跳过）"></a>1.4 libomp-dev 是什么？（补充，可以跳过）</h2><p><code>libomp-dev</code>是 OpenMP 运行时库和开发文件的 Debian&#x2F;Ubuntu 软件包。OpenMP（Open Multi-Processing）是一个用于共享内存并行编程的 API，主要用于 C、C++ 和 Fortran 语言。它允许程序员使用编译器指令和库函数来创建并行代码，充分利用多核处理器的计算能力。</p>
<p><code>libomp-dev</code> 包含：</p>
<ol>
<li>OpenMP 头文件（如 <code>omp.h</code>）</li>
<li>OpenMP 运行时库的开发文件</li>
<li>编译 OpenMP 程序所需的工具和配置</li>
</ol>
<p>安装这个包的主要目的是：</p>
<ul>
<li>允许编译器（如 GCC、Clang）支持 OpenMP 并行编程</li>
<li>提供编译 OpenMP 程序所需的头文件和库</li>
<li>启用 <code>-fopenmp</code> 编译选项</li>
</ul>
<p>典型的使用场景：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这段代码将并行执行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>编译这样的代码需要添加 <code>-fopenmp</code> 选项：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -fopenmp your_file.cpp -o your_program</span><br></pre></td></tr></table></figure></div>

<h1 id="2-通过-Dockerfile-创建"><a href="#2-通过-Dockerfile-创建" class="headerlink" title="2.通过 Dockerfile 创建"></a>2.通过 Dockerfile 创建</h1><p>还是先创建镜像源文件<code>sources.list</code>。</p>
<p>然后创建<code>Dockerfile</code>，在里面加入下面的内容：</p>
<div class="code-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像源方式</span></span><br><span class="line"><span class="comment"># COPY sources.list /etc/apt/sources.list</span></span><br><span class="line"><span class="comment"># RUN apt-get update &amp;&amp; apt-get install -y ca-certificates &amp;&amp; apt-get update &amp;&amp; apt-get -yq upgrade</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理方式</span></span><br><span class="line"><span class="keyword">ENV</span> http_proxy=http://your-proxy-address:port/</span><br><span class="line"><span class="keyword">ENV</span> https_proxy=http://your-proxy-address:port/</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get -yq upgrade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -yq install \</span></span><br><span class="line"><span class="language-bash">    libpcl-dev \</span></span><br><span class="line"><span class="language-bash">    cmake \</span></span><br><span class="line"><span class="language-bash">    clang \</span></span><br><span class="line"><span class="language-bash">    clangd \</span></span><br><span class="line"><span class="language-bash">    libomp-dev \</span></span><br><span class="line"><span class="language-bash">    x11-apps \</span></span><br><span class="line"><span class="language-bash">    language-pack-zh-hans \</span></span><br><span class="line"><span class="language-bash">    nano &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> /root/workspace &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">touch</span> /var/lib/locales/supported.d/local</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;LANG=&quot;zh_CN.UTF-8&quot;&#x27;</span> &gt;&gt; /etc/environment &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&#x27;LANGUAGE=&quot;zh_CN:zh:en_US:en&quot;&#x27;</span> &gt;&gt; /etc/environment &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&#x27;en_US.UTF-8 UTF-8&#x27;</span> &gt;&gt; /var/lib/locales/supported.d/local &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&#x27;zh_CN.UTF-8 UTF-8&#x27;</span> &gt;&gt; /var/lib/locales/supported.d/local &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&#x27;zh_CN.GBK GBK&#x27;</span> &gt;&gt; /var/lib/locales/supported.d/local &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&#x27;zh_CN GB2312&#x27;</span> &gt;&gt; /var/lib/locales/supported.d/local &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    locale-gen zh_CN.UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/workspace</span></span><br></pre></td></tr></table></figure></div>
<p>关于注释部分<code>ENV</code>说明：如果用镜像源不成功，就把设置镜像源那一行注释掉，然后设置代理来更新下载。<code>your-proxy-address</code>是宿主机的<code>IP</code>地址。</p>
<p>构建镜像：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker build --no-cache -t ubuntu-pcl:latest .</span><br></pre></td></tr></table></figure></div>

<p>如果在<code>/etc/apt/sources.list</code>中更改了 APT 源列表，而没有使用<code>--no-cache</code>，Docker 可能会使用旧的缓存层，导致源列表的更改不会反映在最终的镜像中。当使用<code>--no-cache</code>时，Docker 会忽略缓存，确保每个命令都重新执行，特别是在修改了基础文件（如<code>/etc/apt/sources.list</code>）时，确保镜像构建时使用的是新的 APT 源列表。</p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 教程</title>
    <url>/2024/07/24/Docker%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、基本指令"><a href="#一、基本指令" class="headerlink" title="一、基本指令"></a>一、基本指令</h1><h2 id="1-1-查看镜像版本"><a href="#1-1-查看镜像版本" class="headerlink" title="1.1 查看镜像版本"></a>1.1 查看镜像版本</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect &lt;镜像ID&gt; | grep -i version</span><br></pre></td></tr></table></figure></div>

<h2 id="1-2-查看镜像或容器详细信息"><a href="#1-2-查看镜像或容器详细信息" class="headerlink" title="1.2 查看镜像或容器详细信息"></a>1.2 查看镜像或容器详细信息</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 镜像</span></span><br><span class="line">docker inspect &lt;镜像名或ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器</span></span><br><span class="line">docker inspect &lt;容器名或ID&gt;</span><br></pre></td></tr></table></figure></div>
<p>可以同过这种方式查看镜像里的主要<code>workdir</code>在哪里，这样可以知道应该挂载镜像里的哪个目录。</p>
<h2 id="1-3-查看容器映射到本地的端口"><a href="#1-3-查看容器映射到本地的端口" class="headerlink" title="1.3 查看容器映射到本地的端口"></a>1.3 查看容器映射到本地的端口</h2><p>如过在创建容器时用的是<code>-P</code>（随机映射本地端口）而不是<code>-p xxxx:xxxx</code>（指定映射本地端口）</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker port &lt;容器名或ID&gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="1-4-在本地对容器内的文件进行操作"><a href="#1-4-在本地对容器内的文件进行操作" class="headerlink" title="1.4 在本地对容器内的文件进行操作"></a>1.4 在本地对容器内的文件进行操作</h2><p>可以使用 <code>docker cp</code> 命令将容器内的自己需要文件（文件或者文件夹都可以）导出到宿主机（反之亦然）。</p>
<p>从容器复制文件到宿主机:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> my_container:/path/in/container /path/on/host</span><br></pre></td></tr></table></figure></div>

<p>从宿主机复制文件到容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> /path/on/host my_container:/path/in/container</span><br></pre></td></tr></table></figure></div>

<h2 id="1-5-删除镜像或容器"><a href="#1-5-删除镜像或容器" class="headerlink" title="1.5 删除镜像或容器"></a>1.5 删除镜像或容器</h2><p>要一次性删除所有<code>Docker</code>镜像，可以通过以下步骤：</p>
<h3 id="1-5-1-停止并删除所有容器"><a href="#1-5-1-停止并删除所有容器" class="headerlink" title="1.5.1 停止并删除所有容器"></a>1.5.1 停止并删除所有容器</h3><p>首先，确保所有容器已经停止并删除。你不能删除正在使用的镜像。</p>
<ol>
<li><p>停止所有容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -aq)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除所有容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="1-5-2-删除所有镜像"><a href="#1-5-2-删除所有镜像" class="headerlink" title="1.5.2 删除所有镜像"></a>1.5.2 删除所有镜像</h3><p>在确保所有容器都已停止并删除后，可以删除所有镜像：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure></div>

<h3 id="1-5-3-详细说明"><a href="#1-5-3-详细说明" class="headerlink" title="1.5.3 详细说明"></a>1.5.3 详细说明</h3><ul>
<li><p><strong><code>docker ps -aq</code>：</strong></p>
<ul>
<li><code>docker ps</code>：列出所有运行中的容器。</li>
<li><code>-a</code>：列出所有容器，包括运行中的和已停止的。</li>
<li><code>-q</code>：只显示容器的 ID。</li>
</ul>
</li>
<li><p><strong><code>docker images -q</code>：</strong></p>
<ul>
<li><code>docker images</code>：列出所有镜像。</li>
<li><code>-q</code>：只显示镜像的 ID。</li>
</ul>
</li>
</ul>
<h3 id="1-5-4-删除所有未使用的镜像、容器、网络和卷"><a href="#1-5-4-删除所有未使用的镜像、容器、网络和卷" class="headerlink" title="1.5.4 删除所有未使用的镜像、容器、网络和卷"></a>1.5.4 删除所有未使用的镜像、容器、网络和卷</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker system prune -a</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>docker system prune -a</code>：</strong><ul>
<li><code>docker system prune</code>：清理所有未使用的容器、网络、挂载的卷和镜像。</li>
<li><code>-a</code>：删除所有未使用的镜像，不仅仅是悬空的镜像（dangling images）。</li>
</ul>
</li>
</ul>
<h2 id="1-6-网络配置"><a href="#1-6-网络配置" class="headerlink" title="1.6 网络配置"></a>1.6 网络配置</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker create --name =&lt;name&gt;  --network host image:tag </span><br></pre></td></tr></table></figure></div>
<p>使用参数<code>--network host</code>可以让容器共享主机的网络栈，通常用于需要高性能网络连接或访问主机网络的应用，也就是说容器内的端口与主机的都对应。默认是桥接模式。</p>
<h2 id="1-7-实时查看容器日志"><a href="#1-7-实时查看容器日志" class="headerlink" title="1.7 实时查看容器日志"></a>1.7 实时查看容器日志</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f  &lt;--timestamps&gt; &lt;容器ID或容器名称&gt;</span><br></pre></td></tr></table></figure></div>
<p>参数<code>--timestamps</code>可以选加，可以显示时间戳。</p>
<h2 id="1-8-指定端口的映射协议"><a href="#1-8-指定端口的映射协议" class="headerlink" title="1.8 指定端口的映射协议"></a>1.8 指定端口的映射协议</h2><p>在 Docker 中，<code>-p</code> 选项用于指定端口映射时，主要支持以下两种协议：</p>
<ul>
<li><strong>TCP</strong> ：这是 Docker 默认的协议。大多数服务和应用程序使用 TCP 协议，因此 <code>-p</code> 选项通常用于映射 TCP 端口。例如：</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 8080:80&lt;/tcp&gt; my_image</span><br></pre></td></tr></table></figure></div>

<p>这个命令将容器的 <code>80</code> 端口映射到宿主机的 <code>8080</code> 端口，使用 TCP 协议。<code>/tcp</code>可以选加,因为 Docker 的默认端口映射协议就是 TCP。</p>
<ul>
<li><strong>UDP</strong> ：如果你的应用程序使用 UDP 协议，你可以使用 <code>-p</code> 选项来映射 UDP 端口。例如：</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 8080:80/udp my_image</span><br></pre></td></tr></table></figure></div>

<p>这个命令将容器的 <code>80</code> 端口映射到宿主机的 <code>8080</code> 端口，使用 UDP 协议。</p>
<h2 id="1-9-重命名容器"><a href="#1-9-重命名容器" class="headerlink" title="1.9 重命名容器"></a>1.9 重命名容器</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker rename &lt;container_name1&gt; &lt;container_name2&gt;</span><br></pre></td></tr></table></figure></div>

<h1 id="二、容器操作"><a href="#二、容器操作" class="headerlink" title="二、容器操作"></a>二、容器操作</h1><p>这里以<code>ubutnu</code>镜像为例。</p>
<h2 id="2-1-运行并创建容器"><a href="#2-1-运行并创建容器" class="headerlink" title="2.1 运行并创建容器"></a>2.1 运行并创建容器</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --name ubuntu-test ubuntu</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong>  这里必须加上<code>-it</code>。像ubuntu这种镜像在创建容器时需要分配一个伪终端让它在后台持续运行，否则会在启动容器后立马退出运行。</p>
<h2 id="2-2-进入容器"><a href="#2-2-进入容器" class="headerlink" title="2.2 进入容器"></a>2.2 进入容器</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it ubuntu-test bash</span><br></pre></td></tr></table></figure></div>

<p>要退出正在交互模式下的容器终端，可以执行以下操作：</p>
<ol>
<li>按下 <code>Ctrl + D</code> 快捷键。</li>
<li>或者在容器终端中键入 <code>exit</code> 命令并按回车键。</li>
</ol>
<h1 id="三、容器挂载（volume）与绑定挂载（bind）的区别"><a href="#三、容器挂载（volume）与绑定挂载（bind）的区别" class="headerlink" title="三、容器挂载（volume）与绑定挂载（bind）的区别"></a>三、容器挂载（<code>volume</code>）与绑定挂载（<code>bind</code>）的区别</h1><h2 id="3-1-位置"><a href="#3-1-位置" class="headerlink" title="3.1 位置"></a>3.1 位置</h2><p>卷挂载的目录是在<code>/var/lib/docker/volumes/</code>下，绑定挂载的目录根据用户自定义。</p>
<h2 id="3-2-卷挂载-docker-volume"><a href="#3-2-卷挂载-docker-volume" class="headerlink" title="3.2 卷挂载 (docker volume)"></a>3.2 卷挂载 (<code>docker volume</code>)</h2><p>当使用 <code>docker volume create temp</code> 创建一个名为<code>temp</code>卷并将它挂载到容器时（例如 <code>-v temp:/clashmeta</code>），Docker 会自动管理这个卷。如果容器中指定的挂载目标目录（即 <code>/clashmeta</code>）已经有文件，而挂载的卷是空的，Docker 不会覆盖原有的文件。相反，Docker 会将这些文件复制到卷中，确保容器可以正常工作。这就是为什么当你使用 Docker 卷时，<code>/clashmeta</code> 的内容不会被覆盖。</p>
<h2 id="3-3-绑定挂载-bind-mount"><a href="#3-3-绑定挂载-bind-mount" class="headerlink" title="3.3 绑定挂载 (bind mount)"></a>3.3 绑定挂载 (<code>bind mount</code>)</h2><p>当使用 <code>mkdir -p ~/temp</code> 创建一个本地目录，然后将这个目录绑定到容器时（例如 <code>-v ~/temp:/clashmeta</code>），情况会有所不同。<code>bind mount</code> 是一种直接将宿主机的文件系统目录挂载到容器的方式：</p>
<ul>
<li>如果宿主机的目录已经有内容，那么容器内的目标目录将显示宿主机目录中的内容。</li>
<li>如果宿主机目录为空，那么它会 <strong>覆盖</strong> 容器内的目标目录，使得目标目录 <code>/clashmeta</code> 的原始内容不可见，宿主机的目录内容（即使为空）优先级更高。</li>
</ul>
<p>这解释了为什么当使用 <code>~/temp</code> 本地目录作为挂载点时，它会覆盖容器的 <code>/clashmeta</code> 目录的内容。</p>
<h2 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h2><ul>
<li><strong>卷挂载</strong> ：Docker 卷默认是空的，挂载到容器时不会覆盖容器内已有的数据，Docker 会将容器内的文件复制到卷中。</li>
<li><strong>绑定挂载</strong> ：绑定挂载会直接使用宿主机的目录替换容器内的目标目录，导致目标目录的内容不可见。如果宿主机目录为空，容器中的内容也会被覆盖为空。</li>
</ul>
<h1 id="4-推送与备份镜像"><a href="#4-推送与备份镜像" class="headerlink" title="4.推送与备份镜像"></a>4.推送与备份镜像</h1><h2 id="4-1-推送镜像到-Docker-Hub"><a href="#4-1-推送镜像到-Docker-Hub" class="headerlink" title="4.1 推送镜像到 Docker Hub"></a>4.1 推送镜像到 Docker Hub</h2><ol>
<li><strong>登录 Docker Hub</strong></li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker login --username=&lt;your_DockerHub_name&gt;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>标记镜像</strong></li>
</ol>
<p>将镜像标记为你的 Docker Hub 存储库。例如，将 <code>hexo:latest</code> 标记为 <code>yourusername/hexo:latest</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag hexo:latest yourusername/hexo:latest</span><br></pre></td></tr></table></figure></div>

<p>或者通过提交容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit &lt;container_name/id&gt; yourusername/&lt;image_name&gt;:tag</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>推送镜像</strong></li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker push yourusername/&lt;image_name&gt;:tag</span><br></pre></td></tr></table></figure></div>

<h2 id="4-1-备份镜像到本地"><a href="#4-1-备份镜像到本地" class="headerlink" title="4.1 备份镜像到本地"></a>4.1 备份镜像到本地</h2><ol>
<li><strong>保存镜像</strong></li>
</ol>
<p>使用 <code>docker save</code> 命令将镜像保存到一个 tar 文件。例如，将 <code>hexo:latest</code> 保存到 <code>hexo_latest.tar</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o hexo_latest.tar hexo:latest</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>加载镜像</strong></li>
</ol>
<p>以后可以使用 <code>docker load</code> 命令从 tar 文件加载镜像。例如，从 <code>hexo_latest.tar</code> 加载镜像：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i hexo_latest.tar</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker时的问题汇总和解决方式</title>
    <url>/2024/07/24/Docker%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="1-启动-Docker-失败"><a href="#1-启动-Docker-失败" class="headerlink" title="1.启动 Docker 失败"></a>1.启动 Docker 失败</h1><p>如果发现<code>docker</code>启动失败，可以通过以下命令输出<code>docker</code>运行日志来定位问题所在：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> journalctl -u docker.service --no-pager | <span class="built_in">tail</span> -n 50</span><br></pre></td></tr></table></figure></div>

<p>如果问题仍无法解决，可以尝试更彻底的方法：</p>
<ol>
<li>卸载 Docker：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -R docker</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>删除 Docker 相关的所有数据和配置：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf ~/.docker</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>重新安装 Docker：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S docker</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>启动 Docker 服务：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>检查 Docker 服务状态：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status docker</span><br></pre></td></tr></table></figure></div>

<h2 id="1-1-网络冲突导致启动失败"><a href="#1-1-网络冲突导致启动失败" class="headerlink" title="1.1 网络冲突导致启动失败"></a>1.1 网络冲突导致启动失败</h2><p>日志内容如下：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">failed to start daemon: Error initializing network controller: error creating default &quot;bridge&quot; network: cannot create network c13e4912d03075485921194eecec303af8f714e77ad529759990f5b7ca155c68 (docker0): conflicts with network 1b9dcc9575e5af33281149149481d0eca4a5d60de0fac2f9264f0b265ab955db (docker0): networks have same bridge name</span><br></pre></td></tr></table></figure></div>
<p>这个错误表明 Docker 试图创建默认的 bridge 网络，但是遇到了冲突，因为已经存在一个同名的网络。</p>
<p><strong>解决办法：</strong></p>
<ol>
<li>停止 Docker 服务：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop docker</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>删除现有的 Docker 网络配置：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker/network</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>删除 docker0 网桥：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> delete docker0</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>重新启动 Docker 服务：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>检查 Docker 服务状态：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status docker</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Docker 容器中使用宿主机的代理</title>
    <url>/2024/08/16/Dokcer%E5%AE%B9%E5%99%A8%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="1-拉取镜像"><a href="#1-拉取镜像" class="headerlink" title="1.拉取镜像"></a>1.拉取镜像</h1><p>这里以<code>ubuntu</code>镜像为例子：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure></div>

<h1 id="2-容器内配置代理的方式"><a href="#2-容器内配置代理的方式" class="headerlink" title="2.容器内配置代理的方式"></a>2.容器内配置代理的方式</h1><h2 id="2-1-方式一（host-模式）"><a href="#2-1-方式一（host-模式）" class="headerlink" title="2.1 方式一（host 模式）"></a>2.1 方式一（host 模式）</h2><p>运行完后退出容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker  run -it --name=<span class="built_in">test</span> --network=host ubuntu</span><br></pre></td></tr></table></figure></div>

<p>因为在容器里默认是没有安装编辑器的，要么通过在容器内下载（<code>apt install vi</code>），要么通过在宿主机里对文件进行编辑后再通过<code>docker cp</code>复制到容器里。</p>
<p>编辑宿主机的<code>.bashrc</code>文件，在里面添加代理配置：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">kate ~/.bashrc</span><br></pre></td></tr></table></figure></div>

<p>打开后在里面添加：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line"># where proxy</span><br><span class="line">proxy()&#123;</span><br><span class="line">  export http_proxy=&quot;http://127.0.0.1:7890&quot;</span><br><span class="line">  export https_proxy=&quot;http://127.0.0.1:7890&quot;</span><br><span class="line">  echo &quot;HTTP Proxy on&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># where noproxy</span><br><span class="line">noproxy()&#123;</span><br><span class="line">  unset http_proxy</span><br><span class="line">  unset https_proxy</span><br><span class="line">  echo &quot;HTTP Proxy off&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>7890</code>是<code>clash</code>的代理端口。</p>
<p>然后把<code>.bashrc</code>复制到<code>test</code>容器的<code>/root</code>下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> ~/.bashrc <span class="built_in">test</span>:/root/</span><br></pre></td></tr></table></figure></div>

<p>可以重启下容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart <span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>

<p>进入容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">test</span> bash</span><br></pre></td></tr></table></figure></div>

<p>开启并查看代理：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启代理</span></span><br><span class="line">proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看代理</span></span><br><span class="line"><span class="built_in">env</span> | grep -i proxy</span><br></pre></td></tr></table></figure></div>

<h3 id="2-1-1-原理"><a href="#2-1-1-原理" class="headerlink" title="2.1.1 原理"></a>2.1.1 原理</h3><p><em><strong>一、<code>host</code> 网络模式的特点</strong></em></p>
<ol>
<li><p><strong>共享网络堆栈</strong> ：</p>
<ul>
<li>容器与宿主机共享网络堆栈，因此容器和宿主机的网络接口和端口是直接共享的。</li>
<li>容器中的服务可以直接通过宿主机的 IP 地址和端口访问，不需要额外的端口映射。</li>
</ul>
</li>
<li><p><strong>无需端口映射</strong>：</p>
<ul>
<li>在 <code>host</code> 网络模式下，你不需要使用 <code>-p</code> 或 <code>--publish</code> 选项来映射端口。</li>
<li>容器中的服务将直接监听宿主机的端口，可以通过宿主机的 IP 地址直接访问。</li>
</ul>
</li>
<li><p><strong>网络性能</strong> ：</p>
<ul>
<li>由于没有虚拟网络桥接的开销，<code>host</code> 网络模式通常提供更高的网络性能。</li>
</ul>
</li>
<li><p><strong>网络隔离</strong> ：</p>
<ul>
<li>使用 <code>host</code> 网络模式时，容器与宿主机网络没有隔离，这意味着容器可以访问宿主机上所有可访问的网络资源，也可能对宿主机网络造成安全风险。</li>
</ul>
</li>
</ol>
<p><em><strong>二、注意事项</strong></em></p>
<ul>
<li><strong>安全性</strong> ：由于容器与宿主机共享网络，容器可能会有更大的安全风险，因为它可以直接访问宿主机的网络资源。</li>
<li><strong>网络冲突</strong> ：如果容器和宿主机上的应用程序尝试监听相同的端口，可能会发生端口冲突。</li>
</ul>
<h2 id="2-2-方式二（bridge-模式）"><a href="#2-2-方式二（bridge-模式）" class="headerlink" title="2.2 方式二（bridge 模式）"></a>2.2 方式二（bridge 模式）</h2><h3 id="2-2-1-通过修改容器内的终端配置文件"><a href="#2-2-1-通过修改容器内的终端配置文件" class="headerlink" title="2.2.1 通过修改容器内的终端配置文件"></a>2.2.1 通过修改容器内的终端配置文件</h3><p>运行完后退出容器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name=<span class="built_in">test</span> ubuntu</span><br></pre></td></tr></table></figure></div>

<p>这里同样需要修改<code>.bashrc</code>文件，但是代理地址不再是宿主机的本地回环地址了，惹事宿主机的实际 <code>ip</code>地址。</p>
<p>查询宿主机的<code>ip</code>地址：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure></div>

<p>编辑<code>.bashrc</code>文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">kate ~/.bashrc</span><br></pre></td></tr></table></figure></div>

<p>打开后在里面添加：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line"># where proxy</span><br><span class="line">proxy()&#123;</span><br><span class="line">  export http_proxy=&quot;http://&lt;宿主机的 ip 地址&gt;:7890&quot;</span><br><span class="line">  export https_proxy=&quot;http://&lt;宿主机的 ip 地址&gt;:7890&quot;</span><br><span class="line">  echo &quot;HTTP Proxy on&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># where noproxy</span><br><span class="line">noproxy()&#123;</span><br><span class="line">  unset http_proxy</span><br><span class="line">  unset https_proxy</span><br><span class="line">  echo &quot;HTTP Proxy off&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-2-2-直接在docker-run命令中指定代理"><a href="#2-2-2-直接在docker-run命令中指定代理" class="headerlink" title="2.2.2 直接在docker run命令中指定代理"></a>2.2.2 直接在<code>docker run</code>命令中指定代理</h3><p>使用<code>--env</code>参数设置代理环境变量：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name=my-container \</span><br><span class="line">    --<span class="built_in">env</span> HTTP_PROXY=http://your-proxy-server:port \</span><br><span class="line">    --<span class="built_in">env</span> HTTPS_PROXY=http://your-proxy-server:port \</span><br><span class="line">    my-image</span><br></pre></td></tr></table></figure></div>
<p><code>your-proxy-server</code>需要替换为代理服务器或者宿主机的<code>ip</code>地址，<code>port</code>是代理端口。</p>
<h3 id="2-2-3-原理"><a href="#2-2-3-原理" class="headerlink" title="2.2.3 原理"></a>2.2.3 原理</h3><p>如果是在桥接模式下在容器中使用 <code>127.0.0.1</code> 来访问宿主机的服务（如代理服务），这个 IP 地址将指向容器本身，而不是宿主机。因此要让容器访问宿主机上的服务（例如宿主机上的代理服务），应该使用宿主机的实际 IP 地址，或者在 Docker 中使用特定的地址来实现宿主机的访问。</p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>EndeavourOS 使用记录</title>
    <url>/2024/07/18/EndeavourOS/</url>
    <content><![CDATA[<h1 id="一、N卡驱动"><a href="#一、N卡驱动" class="headerlink" title="一、N卡驱动"></a>一、N卡驱动</h1><p><code>EndeavourOS</code>对N卡用户的支持比较友好，在安装该系统时，选择有<code>Nvidia</code>那一行的进行安装即可，会自动安装最新的适应当前显卡的闭源驱动。如果是<code>Arch Linux</code>，建议看这篇文章，同时提到有双显卡如何进行切换 <a class="link"   href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/" >Arch Linux 安装使用教程<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，如果是<code>Arch</code>系其它发行版（像<code>Manjaro</code>），请自行找教程，这里提到的方式不一定适用你。</p>
<p>CUDA 安装参考这篇教程：<a class="link"   href="https://ivonblog.com/posts/archlinux-install-nvidia-drivers/" >教你在Arch Linux安裝Nvidia、CUDA、cuDNN、TensorRT专有驱动程序<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="1-1-安装方式一"><a href="#1-1-安装方式一" class="headerlink" title="1.1 安装方式一"></a>1.1 安装方式一</h2><ul>
<li><strong>全面更新系统以及安装依赖工具</strong></li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Syu base-devel dkms</span><br></pre></td></tr></table></figure></div>

<p>对于新版本的显卡型号，直接运行下面这条指令即可：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 必须安装</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S nvidia nvidia-settings nvidia-utils</span><br></pre></td></tr></table></figure></div>
<p>如果有切换内核的需求，那么把<code>nvidia</code>换成<code>nvidia-dkms</code>即可。</p>
<h2 id="1-2-安装方式二"><a href="#1-2-安装方式二" class="headerlink" title="1.2 安装方式二"></a>1.2 安装方式二</h2><p>如果安装有<code>mwhd</code>工具，可以使用以下方法：</p>
<ul>
<li><p><strong>自动安装推荐的开源驱动程序</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mhwd -a pci free 0300</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>自动安装推荐的闭源驱动程序：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mhwd -a pci nonfree 0300</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>终端输入：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure></div>
<p>如果有返回信息，表示安装成功。</p>
<h2 id="1-3-查看显卡信息"><a href="#1-3-查看显卡信息" class="headerlink" title="1.3 查看显卡信息"></a>1.3 查看显卡信息</h2><p>简单的过滤，显示有关 VGA 设备的基本信息。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">lspci -vnn | grep VGA</span><br></pre></td></tr></table></figure></div>

<p>提供更详细的信息，包括驱动程序信息。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">lspci -k | grep -EA3 <span class="string">&#x27;VGA|3D&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>提供非常详细且易读的图形信息，适合快速了解系统图形设备和驱动状态。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">inxi -G</span><br></pre></td></tr></table></figure></div>

<p>手动安装的话，从官网下载对应型号的驱动，一定要把下载好的驱动文件放到主文件夹（<code>~</code>）下！在<code>BIOS</code>终端界面，中文会显示乱码。</p>
<h2 id="1-4-补充"><a href="#1-4-补充" class="headerlink" title="1.4 补充"></a>1.4 补充</h2><ul>
<li><strong><code>nvidia-hook</code>, <code>nvidia-inst</code>, <code>nvidia-utils</code> 的用途：</strong></li>
</ul>
<h3 id="1-4-1-nvidia-hook"><a href="#1-4-1-nvidia-hook" class="headerlink" title="1.4.1 nvidia-hook"></a>1.4.1 nvidia-hook</h3><p><code>nvidia-hook</code> 是一个 Pacman 钩子脚本，用于在内核更新时自动重新生成 NVIDIA 内核模块。这可以确保你的 NVIDIA 驱动程序在内核更新后继续正常工作，而无需手动干预。</p>
<p><strong>功能：</strong></p>
<ul>
<li>自动在内核更新后重新生成 NVIDIA 内核模块。</li>
<li>提高系统更新的便利性，减少因驱动兼容性问题导致的系统启动问题。</li>
</ul>
<h3 id="1-4-2-nvidia-inst"><a href="#1-4-2-nvidia-inst" class="headerlink" title="1.4.2 nvidia-inst"></a>1.4.2 nvidia-inst</h3><p><code>nvidia-inst</code> 是 EndeavourOS 提供的一个脚本，用于安装和配置 NVIDIA 驱动程序。它简化了在 EndeavourOS 系统上安装 NVIDIA 驱动的过程。</p>
<p><strong>功能：</strong></p>
<ul>
<li>自动检测你的显卡型号。</li>
<li>安装合适版本的 NVIDIA 驱动程序。</li>
<li>配置系统以使用新的驱动程序。</li>
</ul>
<h3 id="1-4-3-nvidia-utils"><a href="#1-4-3-nvidia-utils" class="headerlink" title="1.4.3 nvidia-utils"></a>1.4.3 nvidia-utils</h3><p><code>nvidia-utils</code> 包含 NVIDIA 驱动程序的核心用户空间组件和实用工具。这个包提供了运行 NVIDIA 驱动程序所需的库和命令行工具。</p>
<p><strong>功能：</strong></p>
<ul>
<li>提供核心的 NVIDIA 驱动库。</li>
<li>包含用于查询和配置 NVIDIA 显卡的命令行工具，如 <code>nvidia-smi</code>。</li>
<li>包含 OpenGL 库和 Vulkan 库，用于支持高性能图形渲染。</li>
</ul>
<p> <code>nvidia-hook</code>, <code>nvidia-inst</code>, <code>nvidia-utils</code> 不能完全替代 <code>nvidia-settings</code> 和 <code>lib32-nvidia-utils</code>。</p>
<h3 id="1-4-4-nvidia-settings"><a href="#1-4-4-nvidia-settings" class="headerlink" title="1.4.4 nvidia-settings"></a>1.4.4 nvidia-settings</h3><p><code>nvidia-settings</code> 是一个独立的图形化配置工具，用于调整和配置 NVIDIA 显卡的各种设置。它提供了一个图形界面，允许用户进行以下操作：</p>
<ul>
<li>配置显示器布局（多显示器设置）。</li>
<li>调整显卡性能参数（如风扇速度、功率模式）。</li>
<li>配置 OpenGL 设置。</li>
<li>管理显示器色彩和亮度设置。</li>
</ul>
<p><strong>替代情况：</strong></p>
<ul>
<li><code>nvidia-utils</code> 提供了一些命令行工具，但没有图形界面和用户友好的配置选项。</li>
<li><code>nvidia-settings</code> 提供了更丰富和直观的配置选项，尤其适用于需要频繁调整显卡设置的用户。</li>
</ul>
<h3 id="1-4-5-lib32-nvidia-utils"><a href="#1-4-5-lib32-nvidia-utils" class="headerlink" title="1.4.5 lib32-nvidia-utils"></a>1.4.5 lib32-nvidia-utils</h3><p><code>lib32-nvidia-utils</code> 是 32 位 NVIDIA 驱动程序库的集合，用于在 64 位系统上运行 32 位应用程序（如一些旧版游戏和软件）。这些库对于兼容 32 位应用程序至关重要。</p>
<p><strong>替代情况：</strong></p>
<ul>
<li><code>nvidia-utils</code> 包含 64 位库，不包括 32 位库。</li>
<li>如果你需要运行 32 位应用程序，仍然需要安装 <code>lib32-nvidia-utils</code>。</li>
</ul>
<h1 id="二、中文输入法配置"><a href="#二、中文输入法配置" class="headerlink" title="二、中文输入法配置"></a>二、中文输入法配置</h1><h2 id="2-1-推荐方式"><a href="#2-1-推荐方式" class="headerlink" title="2.1 推荐方式"></a>2.1 推荐方式</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">yay -Sy fcitx-im fcitx-configtool</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">kate ~/.xprofile</span><br></pre></td></tr></table></figure></div>
<p>输入以下内容：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure></div>

<p>如果在<code>~</code>目录创建的<code>.xprofile</code>配置文件没有生效，可以这样做：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">kate /etc/environment</span><br></pre></td></tr></table></figure></div>

<p>然后在里面加入：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure></div>

<p>如果是安装<code>fcitx5</code>，参照官网<a class="link"   href="https://wiki.archlinuxcn.org/wiki/Fcitx5" >fcitx5 Arch wiki<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h2 id="2-2-其它（没试过）"><a href="#2-2-其它（没试过）" class="headerlink" title="2.2 其它（没试过）"></a>2.2 其它（没试过）</h2><p><strong>方式一：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装fcitx5</span></span><br><span class="line"><span class="comment">#基础包组</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S fcitx5-im</span><br><span class="line"><span class="comment">#官方中文输入引擎</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S fcitx5-chinese-addons</span><br><span class="line"><span class="comment">#日文输入引擎</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S fcitx5-anthy</span><br><span class="line"><span class="comment">#萌娘百科词库（挂梯子）</span></span><br><span class="line">yay -S fcitx5-pinyin-moegirl</span><br><span class="line"><span class="comment">#中文维基百科词库</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S fcitx5-pinyin-zhwiki</span><br><span class="line"><span class="comment">#主题</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S fcitx5-material-color</span><br></pre></td></tr></table></figure></div>

<p>编辑配置文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">kate /etc/environment</span><br></pre></td></tr></table></figure></div>

<p>输入以下内容：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br></pre></td></tr></table></figure></div>

<h1 id="三、问题汇总"><a href="#三、问题汇总" class="headerlink" title="三、问题汇总"></a>三、问题汇总</h1><h2 id="3-1-安装软件时的证书问题"><a href="#3-1-安装软件时的证书问题" class="headerlink" title="3.1 安装软件时的证书问题"></a>3.1 安装软件时的证书问题</h2><ol>
<li>首先，更新你的系统证书:</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-ca-trust</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>如果上面的方法不起作用，你可以尝试临时禁用SSL验证。这不是一个安全的长期解决方案，但可以帮助你确定问题是否确实与证书有关:</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">makepkg -si --skippgpcheck</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>最后，确保你的系统时间是正确的，因为时间不正确也可能导致SSL证书验证失败:</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl status</span><br></pre></td></tr></table></figure></div>

<p>如果时间不正确，可以同步:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> timedatectl set-ntp <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>

<h2 id="3-2-镜像源问题"><a href="#3-2-镜像源问题" class="headerlink" title="3.2 镜像源问题"></a>3.2 镜像源问题</h2><p>如果下载或者更新速度较慢，可以用 Arch 清华镜像源：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">kate /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure></div>
<p>然后在首行加上：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line"># arch 清华镜像源</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line"># arch 稳定镜像源</span><br><span class="line">Server = https://mirror.archlinux.org/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.kernel.org/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure></div>

<p><strong>如果是在线安装系统的话，建议在<code>live</code>版镜像中，先改下镜像源配置：</strong></p>
<p>进入<code>root</code>用户：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> su</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure></div>
<p>然后把镜像源加进去。</p>
<p>如果要添加<code>aurcn</code>源，参照 <strong>清华镜像源镜像</strong> 即可。</p>
<h2 id="3-3-签名验证问题"><a href="#3-3-签名验证问题" class="headerlink" title="3.3 签名验证问题"></a>3.3 签名验证问题</h2><p><strong>建议先参考这篇官方文章：</strong> <a class="link"   href="https://discovery.endeavouros.com/signature-and-keyring/pacman-keyring-issues/2021/03/" >Signature and keyring<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">(735/735) 正在检查软件包完整性                        [------------------------------------] 100% **错误：**libinstpatch: 来自 &quot;Brett Cornwall &lt;brett@i--b.com&gt;&quot; 的签名是未知信任的- **:: 文件 /var/cache/pacman/pkg/libinstpatch-1.1.6-3-x86_64.pkg.tar.zst 已损坏 (无效或已损坏的软件包 (PGP 签名))**. **打算删除吗？ [Y/n] ** **错误：**fluidsynth: 来自 &quot;Brett Cornwall &lt;brett@i--b.com&gt;&quot; 的签名是未知信任的**坏** **:: 文件 /var/cache/pacman/pkg/fluidsynth-2.3.6-1-x86_64.pkg.tar.zst 已损坏 (无效或已损坏的软件包 (PGP 签名)).** **打算删除吗？ [Y/n]</span><br></pre></td></tr></table></figure></div>

<p>如果遇到以上这种问题（比如在执行<code>sudo pacman -Syu</code>时），可以这样做：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">kate /etc/pacman.conf</span><br></pre></td></tr></table></figure></div>

<p>然后找到<code>SigLevel</code>那一行，暂时禁用签名检查（这是一个临时的、有风险的解决方案），修改为：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">SigLevel = Never</span><br></pre></td></tr></table></figure></div>
<p>为了保证主机安全，在安装好后记得要修改回来！！！</p>
<h2 id="3-4-文件未通过校验"><a href="#3-4-文件未通过校验" class="headerlink" title="3.4 文件未通过校验"></a>3.4 文件未通过校验</h2><p>比如在构建包时有类似的如下报错信息：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">正在验证 source 文件，</span><br><span class="line">使用sha512sums... </span><br><span class="line"> nekoray ... 通过</span><br><span class="line"> nekobox.sh ... 通过</span><br><span class="line"> nekobox.desktop ... 通过</span><br><span class="line"> 1350.patch ... 失败. ==&gt; 错误： 一个或多个文件没有通过有效性检查！0</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p><strong>清理之前的构建：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">makepkg --clean</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>更新 PKGBUILD 文件中的校验和。进入构建文件的目录，然后使用以下命令：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">updpkgsums</span><br></pre></td></tr></table></figure></div>
<p>它会自动下载源文件（如果需要），计算新的校验和，并更新 PKGBUILD 文件。</p>
</li>
<li><p><strong>重新构建：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">makepkg -si</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h1 id="四、美化（KDE-Plasma6）"><a href="#四、美化（KDE-Plasma6）" class="headerlink" title="四、美化（KDE Plasma6）"></a>四、美化（KDE Plasma6）</h1><p>注意下的主题和组件需要是<code>plasma6</code>的，作者一般会说明。</p>
<h2 id="4-1-全局主题"><a href="#4-1-全局主题" class="headerlink" title="4.1 全局主题"></a>4.1 全局主题</h2><p>建议去 KDE Store 下载主题，然后把下载的 <strong>全局主题</strong> 解压后，放到<code>~/.local/share/plasma/look-and-feel</code>目录下。</p>
<p>壁纸和全局主题推荐<code>Utterly Nord</code>，图标推荐<code>Dracula Circle</code>。</p>
<p>参考图：<br><a href="https://imgse.com/i/pAkSS6H"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/08/25/pAkSS6H.png"
                      alt="Utterly Nord"
                ><figcaption>Utterly Nord</figcaption></figure></a></p>
<h2 id="4-2-组件"><a href="#4-2-组件" class="headerlink" title="4.2 组件"></a>4.2 组件</h2><p><a class="link"   href="https://store.kde.org/p/2186442" >musicWaves<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://www.pling.com/p/2148472/" >thot CPU Plasma 6<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>解压后，把文件夹移动到<code>~/.local/share/plasma/plasmoids/</code>目录下。</p>
<p>参考图：<br><a href="https://imgse.com/i/pAksXO1"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/08/27/pAksXO1.md.png"
                      alt="Desktop Widgets"
                ><figcaption>Desktop Widgets</figcaption></figure></a></p>
<h2 id="4-3-Login-SDDM"><a href="#4-3-Login-SDDM" class="headerlink" title="4.3 Login SDDM"></a>4.3 Login SDDM</h2><p>建议先在<code>KDE Store</code>下载好，然后解压到存放登录界面的目录下。</p>
<p><a class="link"   href="https://www.pling.com/p/2144235/" >Nordic sddm Plasma 6<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>把解压后的文件移到<code>/usr/share/sddm/themes/</code>目录下。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Git教程</title>
    <url>/2024/07/19/Git%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、-SSH-连接"><a href="#一、-SSH-连接" class="headerlink" title="一、 SSH 连接"></a>一、 SSH 连接</h1><p>需要提前安装好<code>OpenSSH</code>:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S openssh</span><br></pre></td></tr></table></figure></div>

<h2 id="1-1-生成-SSH-密钥"><a href="#1-1-生成-SSH-密钥" class="headerlink" title="1.1 生成 SSH 密钥"></a>1.1 生成 SSH 密钥</h2><p>如果还没有 SSH 密钥，可以生成一个：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐</span></span><br><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>或者</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>按照提示完成生成过程，默认会在 <code>~/.ssh/</code> 目录下生成 <code>id_ed25519</code>（不能告诉别人）和<code>id_ed25519.pub</code>（公有的） 文件。第二种生成密钥的方式对应的文件是<code>id_rsa</code> 和 <code>id_rsa.pub</code>。</p>
<h2 id="1-2-添加-SSH-密钥到-GitHub"><a href="#1-2-添加-SSH-密钥到-GitHub" class="headerlink" title="1.2 添加 SSH 密钥到 GitHub"></a>1.2 添加 SSH 密钥到 GitHub</h2><ol>
<li>将生成的公钥添加到 GitHub。在终端中运行：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_ed25519.pub</span><br></pre></td></tr></table></figure></div>

<p>输出示例：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-ed25519 AAAAC3NzANDAKlZDI1NTE5AAAaaaN/oaWb4GZetVkiI5/8d1gezLHWpT46mnaAnkJAbwXpp loskyertt0403@gmail.com</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>复制输出的公钥内容（从 ssh-ed25519 开始，直到邮箱地址结束）。（或者打开<code>sh/id_rsa.pub</code> 文件，复制其中的内容。）</li>
<li>登录到 GitHub，导航到“Settings”。</li>
<li>在左侧菜单中选择“<a class="link"   href="https://github.com/settings/keys" >SSH and GPG keys 设置页面<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>”。</li>
<li>点击“New SSH key”，粘贴你的公钥并保存。</li>
</ol>
<h2 id="1-3-连接验证"><a href="#1-3-连接验证" class="headerlink" title="1.3 连接验证"></a>1.3 连接验证</h2><p>用于检查是否能与远程的 GitHub 仓库进行连接。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></div>
<p>加上<code>-v</code>参数可以显示更详细的连接信息。</p>
<h2 id="1-3-配置仓库使用-SSH-URL"><a href="#1-3-配置仓库使用-SSH-URL" class="headerlink" title="1.3 配置仓库使用 SSH URL"></a>1.3 配置仓库使用 SSH URL</h2><ol>
<li>更新远程仓库的 URL 以使用 SSH：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin git@github.com:loskyertt/Recorder_Backup.git</span><br></pre></td></tr></table></figure></div>

<h2 id="1-4-无法连接"><a href="#1-4-无法连接" class="headerlink" title="1.4 无法连接"></a>1.4 无法连接</h2><p>当使用<code>ssh -T git@github.com</code>迟迟未返回连接的信息，这种情况可能是<code>~/.ssh/config</code>配置文件发生损坏或者没有该配置文件。</p>
<p>修改或创建<code>config</code>配置文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nano ~/.ssh/config</span><br></pre></td></tr></table></figure></div>

<p>添加下面内容：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  Port 22</span><br><span class="line">  User git</span><br></pre></td></tr></table></figure></div>
<p><code>22</code>端口如果不行，可以改成<code>443</code>端口。</p>
<h1 id="二、个人访问令牌（Personal-Access-Token，PAT）"><a href="#二、个人访问令牌（Personal-Access-Token，PAT）" class="headerlink" title="二、个人访问令牌（Personal Access Token，PAT）"></a>二、个人访问令牌（Personal Access Token，PAT）</h1><p>这种方式主要用于临时快速修改仓库，或者当 SSH 连接不可使用时使用。</p>
<ol>
<li><p><strong>生成个人访问令牌：</strong></p>
<ul>
<li>登录到你的 GitHub 账户。</li>
<li>进入 <a class="link"   href="https://github.com/settings/tokens" >GitHub 个人访问令牌设置页面<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</li>
<li>点击 <code>Generate new token</code> 按钮。</li>
<li>选择 “Personal access tokens” 然后点击 “Generate new token”。</li>
<li>给令牌一个描述性的名称，选择适当的权限范围（至少需要<code>repo</code>权限）。</li>
<li>生成令牌并复制（注意： <strong>令牌只会显示一次，请务必保存</strong> ）。</li>
</ul>
</li>
<li><p><strong>使用个人访问令牌进行认证：</strong></p>
<ul>
<li>当 Git 提示输入密码时，使用您刚刚创建的个人访问令牌而不是密码。</li>
</ul>
</li>
<li><p><strong>存储凭证（可选但推荐）：</strong><br>为了避免每次都输入令牌，您可以让 Git 记住你的凭证：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure></div>
<p>然后，下一次当您输入令牌时，Git 会记住它。</p>
</li>
<li><p><strong>更新远程 URL（如果需要）：</strong><br>如果SSH持续出现问题,您可以暂时使用 HTTPS 方式进行操作。可以通过以下命令将仓库的远程URL改为HTTPS:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin &lt;https://remote-url&gt;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>一定要记住，个人访问令牌与密码具有相同的权限，因此要像对待密码一样谨慎地保护它。如果你认为令牌可能已经泄露，可以随时在 GitHub 设置中撤销它并生成一个新的。</p>
<h1 id="三、git基本配置"><a href="#三、git基本配置" class="headerlink" title="三、git基本配置"></a>三、git基本配置</h1><h2 id="3-1-设置用户信息"><a href="#3-1-设置用户信息" class="headerlink" title="3.1 设置用户信息"></a>3.1 设置用户信息</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;邮箱&quot;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="3-2-代理设置"><a href="#3-2-代理设置" class="headerlink" title="3.2 代理设置"></a>3.2 代理设置</h2><p><strong>注：<code>linux</code>只需要在终端配置代理即可。</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:<span class="string">&quot;端口&quot;</span></span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:<span class="string">&quot;端口&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>如果要取消代理：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 和 Windows 双系统下的 grub 引导修复</title>
    <url>/2024/10/28/Grub%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="1-出现的问题"><a href="#1-出现的问题" class="headerlink" title="1.出现的问题"></a>1.出现的问题</h1><p>如下图所示：<br><a href="https://imgse.com/i/pA05Jit"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/10/28/pA05Jit.jpg"
                      alt="引导出错.jpg"
                ><figcaption>引导出错.jpg</figcaption></figure></a><br>提示找不到<code>/efi/Microsoft/Boot/bootmgfw.efi</code>，<code>no such device: 4458-2764</code>。后面这一串数据其实是<code>Windows</code>引导分区的<code>UUID</code>。一般情况下是因为重装系统，导致<code>UUID</code>改变了，但是 Linux 下的 Grub 引导并没有进行修改，这时候是需要手动修改的。</p>
<h1 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h1><p>首先需要知道 Windows 的引导分区是否存在：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure></div>
<p>或者使用：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fdisk -l</span><br></pre></td></tr></table></figure></div>
<p>显示的信息更详细。</p>
<p>输出：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">nvme1n1     259:0    0 476.9G  0 disk </span><br><span class="line">├─nvme1n1p1 259:1    0   300M  0 part </span><br><span class="line">├─nvme1n1p2 259:2    0    16M  0 part </span><br><span class="line">├─nvme1n1p3 259:3    0   100G  0 part </span><br><span class="line">└─nvme1n1p4 259:4    0 376.6G  0 part </span><br><span class="line">nvme0n1     259:5    0 238.5G  0 disk </span><br><span class="line">├─nvme0n1p1 259:6    0   301M  0 part /boot/efi</span><br><span class="line">└─nvme0n1p2 259:7    0 238.2G  0 part /</span><br></pre></td></tr></table></figure></div>
<p>根据自己电脑磁盘情况查找，我的是<code>nvme1n1p1</code>（一般都是<code>300M</code>的那个分区）。然后记住这个分区名。</p>
<p>查看分区<code>UUID</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> blkid /dev/nvme1n1p1</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">/dev/nvme1n1p1: UUID=&quot;9252-7D2A&quot; BLOCK_SIZE=&quot;512&quot; TYPE=&quot;vfat&quot; PARTLABEL=&quot;EFI system partition&quot; PARTUUID=&quot;c9ce23fc-7bde-40a9-8cce-8da0df9079cb&quot;</span><br></pre></td></tr></table></figure></div>

<p>把这个<code>UUID</code>记下，我的这里是<code>9252-7D2A</code>。</p>
<p>打开并编辑<code>/boot/grub/grub.cfg</code>文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></div>

<p>找到这样的一个内容：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">menuentry &#x27;Windows Boot Manager (on /dev/nvme0n1p1)&#x27; --class windows --class os $menuentry_id_option &#x27;osprober-efi-4458-2764&gt;</span><br><span class="line">        insmod part_gpt</span><br><span class="line">        insmod fat</span><br><span class="line">        search --no-floppy --fs-uuid --set=root 9252-7D2A</span><br><span class="line">        chainloader /efi/Microsoft/Boot/bootmgfw.efi</span><br></pre></td></tr></table></figure></div>
<p>把<code>--set=root</code>后面的<code>UUID</code>改为你自己电脑的，然后重启电脑就行了。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下 Grub 引导配置教程以及更换内核</title>
    <url>/2024/09/03/Grub%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="1-基本说明"><a href="#1-基本说明" class="headerlink" title="1.基本说明"></a>1.基本说明</h1><p><code>GRUB</code>（GRand Unified Bootloader）的配置文件 是<code>/etc/default/grub</code>，用于配置 GRUB 引导加载器的行为。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/default/grub</span><br></pre></td></tr></table></figure></div>

<p>如果卡在启动界面时（满屏代码的界面，大概率是N卡驱动问题），可以同时按住<code>ctrl</code>+<code>alt</code>+<code>F2</code>（也可能是<code>F3</code>）进入<code>tty</code>，然后输入账户名和密码。</p>
<h1 id="2-文件内容说明"><a href="#2-文件内容说明" class="headerlink" title="2.文件内容说明"></a>2.文件内容说明</h1><h2 id="2-1-基本选项"><a href="#2-1-基本选项" class="headerlink" title="2.1 基本选项"></a>2.1 基本选项</h2><ol>
<li><p><strong><code>GRUB_DEFAULT=&#39;0&#39;</code>:</strong></p>
<ul>
<li>指定默认启动的菜单项编号。<code>0</code> 表示默认启动第一个菜单项（通常是最新的内核版本）。</li>
<li>如果你想让 GRUB 记住上次选择的内核，可以将这个值改为 <code>&#39;saved&#39;</code> 并取消下面的 <code>GRUB_SAVEDEFAULT=true</code>。</li>
</ul>
</li>
<li><p><strong><code>GRUB_TIMEOUT=&#39;5&#39;</code>:</strong></p>
<ul>
<li>设置 GRUB 菜单在引导时等待用户选择的超时时间（以秒为单位）。<code>5</code> 意味着在 5 秒后，如果没有用户干预，系统将启动默认选项。</li>
</ul>
</li>
<li><p><strong><code>GRUB_DISTRIBUTOR=&#39;EndeavourOS&#39;</code>:</strong></p>
<ul>
<li>设置 GRUB 在启动菜单中显示的发行版名称，我这里的是 <code>EndeavourOS</code>。</li>
</ul>
</li>
<li><p><strong><code>GRUB_CMDLINE_LINUX_DEFAULT=&#39;nowatchdog nvme_load=YES nvidia_drm.modeset=1 loglevel=3&#39;</code>:</strong></p>
<ul>
<li>为 Linux 内核指定启动参数：<ul>
<li><code>nowatchdog</code>：禁用硬件看门狗（防止系统重启）。</li>
<li><code>nvme_load=YES</code>：确保 NVMe 驱动程序加载（通常用于 NVMe SSD）。</li>
<li><code>nvidia_drm.modeset=1</code>：启用 NVIDIA DRM 模式设置，用于支持 Wayland 或改进图形性能。</li>
<li><code>loglevel=3</code>：设置内核日志级别，<code>3</code> 意味着只显示错误信息，减少日志输出。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>GRUB_CMDLINE_LINUX=&quot;&quot;</code>:</strong></p>
<ul>
<li>这是为 Linux 内核指定的额外引导参数，当前没有设置任何额外的参数。</li>
</ul>
</li>
</ol>
<h2 id="2-2-模块和加密相关"><a href="#2-2-模块和加密相关" class="headerlink" title="2.2 模块和加密相关"></a>2.2 模块和加密相关</h2><ol start="6">
<li><p><strong><code>GRUB_PRELOAD_MODULES=&quot;part_gpt part_msdos&quot;</code>:</strong></p>
<ul>
<li>预加载 GRUB 的模块，以便支持 GPT 和 MBR 分区表。这样可以确保 GRUB 能识别各种分区类型，无论是 GPT（GUID Partition Table）还是 MBR（Master Boot Record）。</li>
</ul>
</li>
<li><p><strong><code>#GRUB_ENABLE_CRYPTODISK=y</code>（已注释）:</strong></p>
<ul>
<li>如果取消注释并设为 <code>y</code>，GRUB 将启用对 LUKS 加密磁盘的支持。</li>
</ul>
</li>
</ol>
<h2 id="2-3-超时样式和终端设置"><a href="#2-3-超时样式和终端设置" class="headerlink" title="2.3 超时样式和终端设置"></a>2.3 超时样式和终端设置</h2><ol start="8">
<li><p><strong><code>GRUB_TIMEOUT_STYLE=menu</code>:</strong></p>
<ul>
<li>设置 GRUB 菜单的超时样式。<code>menu</code> 表示显示菜单，并允许用户进行选择。</li>
</ul>
</li>
<li><p><strong><code>GRUB_TERMINAL_INPUT=console</code>:</strong></p>
<ul>
<li>启用基本控制台输入，即通过键盘输入。</li>
</ul>
</li>
<li><p><strong><code>#GRUB_TERMINAL_OUTPUT=console</code>（已注释）:</strong></p>
</li>
</ol>
<ul>
<li>取消注释后，GRUB 将禁用图形模式，改用基本的文本输出模式。这是用于系统中没有图形显示器或需要调试的情况。</li>
</ul>
<h2 id="2-4-图形相关"><a href="#2-4-图形相关" class="headerlink" title="2.4 图形相关"></a>2.4 图形相关</h2><ol start="11">
<li><strong><code>GRUB_GFXMODE=auto</code>:</strong></li>
</ol>
<ul>
<li>设置 GRUB 的图形模式为 <code>auto</code>，让 GRUB 自动选择适合当前显示器和显卡的分辨率。</li>
</ul>
<ol start="12">
<li><strong><code>GRUB_GFXPAYLOAD_LINUX=keep</code>:</strong></li>
</ol>
<ul>
<li>让内核继承 GRUB 使用的分辨率，而不是在加载内核后改变分辨率。</li>
</ul>
<h2 id="2-5-高级和恢复模式"><a href="#2-5-高级和恢复模式" class="headerlink" title="2.5 高级和恢复模式"></a>2.5 高级和恢复模式</h2><ol start="13">
<li><strong><code>GRUB_DISABLE_LINUX_UUID=true</code>（已注释）:</strong></li>
</ol>
<ul>
<li>如果取消注释，GRUB 将使用传统的 <code>/dev/sdX</code> 设备标识符代替 UUID（全局唯一标识符）来指定启动分区。</li>
</ul>
<ol start="14">
<li><strong><code>GRUB_DISABLE_RECOVERY=&#39;true&#39;</code>:</strong></li>
</ol>
<ul>
<li>禁用 GRUB 菜单中的恢复模式条目，这可以减少启动菜单的选项，并且在不需要恢复模式时保持简洁。</li>
</ul>
<h2 id="2-6-外观设置"><a href="#2-6-外观设置" class="headerlink" title="2.6 外观设置"></a>2.6 外观设置</h2><ol start="15">
<li><strong><code>GRUB_BACKGROUND=&#39;/usr/share/endeavouros/splash.png&#39;</code>:</strong></li>
</ol>
<ul>
<li>设置 GRUB 启动菜单的背景图片，这里指定了 EndeavourOS 的启动背景图片路径 <code>/usr/share/endeavouros/splash.png</code>。</li>
</ul>
<ol start="16">
<li>**<code>#GRUB_THEME=&quot;/path/to/gfxtheme&quot;</code>**（已注释）：</li>
</ol>
<ul>
<li>允许设置一个主题文件，用于美化 GRUB 菜单。取消注释并指定主题路径即可。</li>
<li>推荐的主题：<a class="link"   href="https://www.pling.com/p/2025649/" >GradientGuy<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，下载好后解压到<code>/boot/grub/themes/ </code>下，然后找到<code>GradientGuy</code>主题文件中的<code>theme.txt</code>，把完整路径<code>/boot/grub/themes/GradientGuy/theme.txt</code>填入到<code>GRUB_THEME</code>。</li>
</ul>
<h2 id="2-7-其他选项"><a href="#2-7-其他选项" class="headerlink" title="2.7 其他选项"></a>2.7 其他选项</h2><ol start="17">
<li><strong><code>#GRUB_INIT_TUNE=&quot;480 440 1&quot;</code>（已注释）:</strong></li>
</ol>
<ul>
<li>如果取消注释并设置音调、频率和持续时间，可以让 GRUB 在启动时发出蜂鸣声。</li>
</ul>
<ol start="18">
<li><strong><code>#GRUB_SAVEDEFAULT=true</code>（已注释）:</strong></li>
</ol>
<ul>
<li>如果取消注释并启用，同时将 <code>GRUB_DEFAULT</code> 设置为 <code>&#39;saved&#39;</code>，GRUB 将记住上次选择的启动选项。</li>
</ul>
<ol start="19">
<li><strong><code>GRUB_DISABLE_SUBMENU=&#39;false&#39;</code>:</strong></li>
</ol>
<ul>
<li>禁用子菜单选项。如果设置为 <code>&#39;true&#39;</code>，则 GRUB 将不显示内核的子菜单项，例如高级选项菜单。</li>
</ul>
<ol start="20">
<li><strong><code>#GRUB_DISABLE_OS_PROBER=false</code>（已注释）:</strong></li>
</ol>
<ul>
<li>取消注释并将其设置为 <code>false</code> 时，GRUB 会启用操作系统探测器（os-prober），从而在 GRUB 菜单中显示其他已安装的操作系统（例如 Windows 或其他 Linux 发行版）。</li>
</ul>
<ol start="21">
<li><strong><code>GRUB_EARLY_INITRD_LINUX_STOCK=&#39;&#39;</code>:</strong></li>
</ol>
<ul>
<li>指定提前加载的 <code>initrd</code>，通常用于特定硬件或驱动程序初始化。当前设置为空，表示未指定。</li>
</ul>
<h1 id="3-内核更换"><a href="#3-内核更换" class="headerlink" title="3.内核更换"></a>3.内核更换</h1><p>下载内核，这里以<code>linux-zen</code>内核为例，我的系统默认是<code>6.10.7-arch1-1</code>内核</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S linux-zen linux-zen-header</span><br></pre></td></tr></table></figure></div>
<p>如果原来的 N 卡驱动是<code>nvidia</code>，需要卸载了换成<code>nvidia-dkms</code>。</p>
<p>然后修改<code>grub</code>配置文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/default/grub</span><br></pre></td></tr></table></figure></div>

<p>主要修改三个地方：</p>
<ul>
<li><code>GRUB_DEFAULT=&#39;0&#39;</code>改为<code>GRUB_DEFAULT=saved</code></li>
<li><code>#GRUB_SAVEDEFAULT=true</code>取消前面的<code>#</code></li>
<li><code>GRUB_DISABLE_SUBMENU=&#39;false&#39;</code>改为<code>GRUB_DISABLE_SUBMENU=&#39;true&#39;</code>或者<code>GRUB_DISABLE_SUBMENU=y</code>（反正都一个意思）</li>
</ul>
<p>保存并退出后，生成（或更新）GRUB 配置文件</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></div>
<p>重启电脑就能看到生效了。</p>
<h1 id="4-切换内核的注意点"><a href="#4-切换内核的注意点" class="headerlink" title="4.切换内核的注意点"></a>4.切换内核的注意点</h1><p>可能会遇到驱动程序（尤其是 N 卡驱动）不兼容的情况，如果卡在加载界面，只能进入<code>tty</code>（按住键盘<code>ctrl</code>+<code>alt</code>+<code>F2</code>进入&lt;也可能是<code>F3</code>&gt;，把<code>F2</code>换成<code>F1</code>退出）进行排查问题，或者重启选择原来的内核（所以不要随便删原来默认的内核）。要卸载内核的话需要谨慎，因为有些依赖包可能只能依赖特定内核使用，所以卸载之前建议做好备份。</p>
<h1 id="4-参考教程"><a href="#4-参考教程" class="headerlink" title="4.参考教程"></a>4.参考教程</h1><ul>
<li><a class="link"   href="https://www.youtube.com/watch?v=1vLGebdIPZ8&list=PL7XUZPsvfw3DfZDpU3bqNYZWzKroAWaT5&index=6" >How to Change the Default Grub Bootlaoder Theme in Arch Linux!<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.youtube.com/watch?v=KbcUmAlQCHs&list=PL7XUZPsvfw3DfZDpU3bqNYZWzKroAWaT5&index=5" >How to Switch Arch Linux Kernels - LTS, Zen, Hardened<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 环境下配置 Docker</title>
    <url>/2024/07/20/Linux-Docker/</url>
    <content><![CDATA[<h1 id="1、Docker-配置"><a href="#1、Docker-配置" class="headerlink" title="1、Docker 配置"></a>1、Docker 配置</h1><h2 id="1-1-安装-Docker"><a href="#1-1-安装-Docker" class="headerlink" title="1.1 安装 Docker"></a>1.1 安装 Docker</h2><ul>
<li><strong>安装方式一（推荐）：</strong></li>
</ul>
<p>通过<code>yay</code>直接安装（全局安装）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">yay -Sy docker docker-compose</span><br></pre></td></tr></table></figure></div>
<p><code>docker-compose</code>可选安装，它可以通过配置文件<code>Dockerfile</code>来构建镜像。</p>
<ul>
<li><strong>安装方式二：</strong></li>
</ul>
<p>通过<code>conda</code>安装（局部安装，可全局使用）：</p>
<p>首先需要创建虚拟环境用于存储安装的<code>docker</code>和<code>docker-compose</code>。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">conda create --name docker python=3.12</span><br></pre></td></tr></table></figure></div>
<p>Python版本可自己选择。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">conda install docker docker-compose -c conda-forge</span><br></pre></td></tr></table></figure></div>

<p>这里的<code>-c conda-forge</code>一定要加，默认的<code>conda.org</code>源没有<code>docker</code>。</p>
<p>安装好的<code>docker</code>和<code>docker-compose</code>是在该路径下：<br><code>~/.conda/envs/docker/bin/docker</code><br><code>~/.conda/envs/docker/bin/docker-compose</code></p>
<h2 id="1-2-docker-基本操作"><a href="#1-2-docker-基本操作" class="headerlink" title="1.2 docker 基本操作"></a>1.2 docker 基本操作</h2><h3 id="1-2-1-docker-服务"><a href="#1-2-1-docker-服务" class="headerlink" title="1.2.1 docker 服务"></a>1.2.1 docker 服务</h3><ul>
<li><p>启动docker服务</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>关闭docker服务</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop docker.service docker.socket</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>检查<code>docker</code>服务状态</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status docker</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>开机自启动设置</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-2-2-添加用户到-docker-组"><a href="#1-2-2-添加用户到-docker-组" class="headerlink" title="1.2.2 添加用户到 docker 组"></a>1.2.2 添加用户到 docker 组</h3><p>为了避免每次运行<code>docker</code>命令时都需要使用 <code>sudo</code>，可以将当前用户添加到 <code>docker</code> 组：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></div>

<p>然后，重新登录以使更改生效，或者重新加载用户组信息：</p>
<p>登录：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">newgrp docker</span><br></pre></td></tr></table></figure></div>

<p>退出：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></div>

<p>可能需要重启系统来让配置生效。</p>
<h2 id="1-3-代理配置（一定要配置）"><a href="#1-3-代理配置（一定要配置）" class="headerlink" title="1.3 代理配置（一定要配置）"></a>1.3 代理配置（一定要配置）</h2><p>1.创建<code>docker</code>相关的<code>systemd</code>目录，这个目录下的配置将覆盖<code>docker</code>的默认配置：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure></div>

<p>2.新建配置文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">kate /etc/systemd/system/docker.service.d/proxy.conf</span><br></pre></td></tr></table></figure></div>

<p>将以下内容复制到<code>proxy.conf</code>中：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://127.0.0.1:7890&quot;</span><br><span class="line">Environment=&quot;HTTPS_PROXY=http://127.0.0.1:7890&quot;</span><br></pre></td></tr></table></figure></div>

<p>这里需要根据自己实际的代理端口填写。</p>
<p>3.如果自己建了私有的镜像仓库，需要<code>docker</code>绕过代理服务器直连，那么配置<code>NO_PROXY</code>变量：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://127.0.0.1:7890&quot;</span><br><span class="line">Environment=&quot;HTTPS_PROXY=http://127.0.0.1:7890&quot;</span><br><span class="line">Environment=&quot;NO_PROXY=your-registry.com,10.10.10.10,*.example.com&quot;</span><br></pre></td></tr></table></figure></div>

<p>多个<code>NO_PROXY</code>变量的值用逗号分隔，而且可以使用通配符（*），极端情况下，如果<code>NO_PROXY=*</code>，那么所有请求都将不通过代理服务器。</p>
<p>4.重新加载配置文件，重启<code>docker</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure></div>

<p>5.检查确认环境变量已经正确配置：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl show --property=Environment docker</span><br></pre></td></tr></table></figure></div>

<p>像输出以下内容就成功了：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Environment=HTTP_PROXY=http://127.0.0.1:7890 HTTPS_PROXY=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure></div>

<h2 id="1-4-命令简化配置"><a href="#1-4-命令简化配置" class="headerlink" title="1.4 命令简化配置"></a>1.4 命令简化配置</h2><p><strong>以下推荐加到.bashrc或者.zshrc中。</strong></p>
<ol>
<li>格式化查看容器：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>命令简化：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">alias dps=&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>查看网络配置：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.HostConfig.NetworkMode&#125;&#125;&#x27;</span> &lt;容器名/容器ID&gt;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>命令简化：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">alias din=&#x27;docker inspect --format=&#x27;&#123;&#123;.HostConfig.NetworkMode&#125;&#125;&#x27;&#x27;</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(EndeavourOS) 下给 Steam 设置代理</title>
    <url>/2024/07/24/Linux-Steam/</url>
    <content><![CDATA[<h1 id="1-解决"><a href="#1-解决" class="headerlink" title="1.解决"></a>1.解决</h1><ol>
<li><p>打开 Steam 大屏模式（ <strong>一定是大屏模式！</strong> ）。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://nyalog.oss-cn-hongkong.aliyuncs.com/NyaLog/articles/Steam%20Linux%20%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/Steam-BigScreen-min.png"
                      alt="大屏模式"
                ><figcaption>大屏模式</figcaption></figure></p>
</li>
<li><p>然后在设置里进入网络设置界面，然后点开填入自己的代理地址和端口。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://nyalog.oss-cn-hongkong.aliyuncs.com/NyaLog/articles/Steam%20Linux%20%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/Steam-proxy-min.png"
                      alt="设置界面"
                ><figcaption>设置界面</figcaption></figure></p>
</li>
<li><p>设置成功后退出重启 Steam 即可。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>steam</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下配置 conda 环境</title>
    <url>/2024/08/19/Linux-conda/</url>
    <content><![CDATA[<h1 id="一、miniconda3-配置"><a href="#一、miniconda3-配置" class="headerlink" title="一、miniconda3 配置"></a>一、miniconda3 配置</h1><p><strong>注：</strong> 如果用的是<code>miniforge</code>，操作方式与此类似。</p>
<h2 id="1-1-把conda集成到zsh终端中"><a href="#1-1-把conda集成到zsh终端中" class="headerlink" title="1.1 把conda集成到zsh终端中"></a>1.1 把<code>conda</code>集成到<code>zsh</code>终端中</h2><h3 id="1-1-1-详细步骤"><a href="#1-1-1-详细步骤" class="headerlink" title="1.1.1 详细步骤"></a>1.1.1 详细步骤</h3><ol>
<li><strong>添加<code>conda</code>环境变量：</strong></li>
</ol>
<p>把这行代码加入到<code>.zshrc</code>中：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">export PATH=/opt/miniconda3/bin:$PATH</span><br></pre></td></tr></table></figure></div>

<p>终端输入这行可以防止conda自动激活环境（建议加上）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>重新加载 <code>~/.zshrc</code> 文件：</strong></li>
</ol>
<p>在终端中运行以下命令重新加载配置文件：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>运行 <code>conda init</code>：</strong></li>
</ol>
<p>初始化 conda 环境：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是conda默认安装的位置</span></span><br><span class="line">/opt/miniconda3/bin/conda init zsh</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li><strong>再次重新加载 <code>~/.zshrc</code> 文件：</strong></li>
</ol>
<p>再次运行以下命令重新加载配置文件：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></div>

<h3 id="1-1-2-验证"><a href="#1-1-2-验证" class="headerlink" title="1.1.2 验证"></a>1.1.2 验证</h3><p>验证 conda 是否配置好：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure></div>

<h3 id="1-1-3-一步到位操作"><a href="#1-1-3-一步到位操作" class="headerlink" title="1.1.3 一步到位操作"></a>1.1.3 一步到位操作</h3><p>可以不用管以上操作，直接把这段复制到<code>.zshrc</code>中，注意安装miniconda的路径：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span><br><span class="line"># !! Contents within this block are managed by &#x27;conda init&#x27; !!</span><br><span class="line">__conda_setup=&quot;$(&#x27;/opt/miniconda3/bin/conda&#x27; &#x27;shell.zsh&#x27; &#x27;hook&#x27; 2&gt; /dev/null)&quot;</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    eval &quot;$__conda_setup&quot;</span><br><span class="line">else</span><br><span class="line">    if [ -f &quot;/opt/miniconda3/etc/profile.d/conda.sh&quot; ]; then</span><br><span class="line">        . &quot;/opt/miniconda3/etc/profile.d/conda.sh&quot;</span><br><span class="line">    else</span><br><span class="line">        export PATH=&quot;/opt/miniconda3/bin:$PATH&quot;</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line">unset __conda_setup</span><br><span class="line"># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span><br><span class="line">export CRYPTOGRAPHY_OPENSSL_NO_LEGACY=1</span><br></pre></td></tr></table></figure></div>

<h2 id="1-2-问题汇总"><a href="#1-2-问题汇总" class="headerlink" title="1.2 问题汇总"></a>1.2 问题汇总</h2><h3 id="1-2-1-OpenSSL-问题"><a href="#1-2-1-OpenSSL-问题" class="headerlink" title="1.2.1  OpenSSL 问题"></a>1.2.1  OpenSSL 问题</h3><p>当运行<code>conda activate base</code>时，可能出现下面问题：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line"> $ conda activate base</span><br><span class="line">Error while loading conda entry point: conda-content-trust (OpenSSL 3.0&#x27;s legacy provider failed to load. This is a fatal error by default, but cryptography supports running without legacy algorithms by setting the environment variable CRYPTOGRAPHY_OPENSSL_NO_LEGACY. If you did not expect this error, you have likely made a mistake with your OpenSSL configuration.)</span><br><span class="line"></span><br><span class="line">CondaError: Run &#x27;conda init&#x27; before &#x27;conda activate&#x27;</span><br></pre></td></tr></table></figure></div>

<p>根据该的错误信息，问题可能与 OpenSSL 版本有关。OpenSSL 3.0 引入了一些变化，可能导致与某些软件包的兼容性问题。在此情况下，设置环境变量<code>CRYPTOGRAPHY_OPENSSL_NO_LEGACY</code>可能会解决问题。</p>
<ul>
<li><strong>解决方法：</strong></li>
</ul>
<p>编辑 <code>~/.zshrc</code> 文件，添加以下行到 <code>~/.zshrc</code> 文件：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">export CRYPTOGRAPHY_OPENSSL_NO_LEGACY=1</span><br></pre></td></tr></table></figure></div>

<p>保存并退出编辑器，然后执行<code>source ~/.zshrc</code>。</p>
]]></content>
      <tags>
        <tag>conda</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 命令行工具推荐</title>
    <url>/2025/01/11/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="1-tldr"><a href="#1-tldr" class="headerlink" title="1.tldr"></a>1.tldr</h1><p>仓库地址：<a href="https://github.com/tldr-pages/tldr"><code>tldr</code>下载</a></p>
<p>安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S tldr</span><br></pre></td></tr></table></figure></div>

<p>安装好后建议先执行下面这条命令来更新缓存：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tldr --update</span><br></pre></td></tr></table></figure></div>

<p>这个工具可以方便查询各个命令的使用方法，比如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tldr find</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tldr find     </span><br><span class="line"></span><br><span class="line">  find</span><br><span class="line"></span><br><span class="line">  Find files or directories under a directory tree, recursively.</span><br><span class="line">  More information: https://manned.org/find.</span><br><span class="line"></span><br><span class="line">  - Find files by extension:</span><br><span class="line">    find root_path -name <span class="string">&#x27;*.ext&#x27;</span></span><br><span class="line"></span><br><span class="line">  - Find files matching multiple path/name patterns:</span><br><span class="line">    find root_path -path <span class="string">&#x27;**/path/**/*.ext&#x27;</span> -or -name <span class="string">&#x27;*pattern*&#x27;</span></span><br><span class="line"></span><br><span class="line">  - Find directories matching a given name, <span class="keyword">in</span> case-insensitive mode:</span><br><span class="line">    find root_path -<span class="built_in">type</span> d -iname <span class="string">&#x27;*lib*&#x27;</span></span><br><span class="line"></span><br><span class="line">  - Find files matching a given pattern, excluding specific paths:</span><br><span class="line">    find root_path -name <span class="string">&#x27;*.py&#x27;</span> -not -path <span class="string">&#x27;*/site-packages/*&#x27;</span></span><br><span class="line"></span><br><span class="line">  - Find files matching a given size range, limiting the recursive depth to <span class="string">&quot;1&quot;</span>:</span><br><span class="line">    find root_path -maxdepth 1 -size +500k -size -10M</span><br><span class="line"></span><br><span class="line">  - Run a <span class="built_in">command</span> <span class="keyword">for</span> each file (use `&#123;&#125;` within the <span class="built_in">command</span> to access the filename):</span><br><span class="line">    find root_path -name <span class="string">&#x27;*.ext&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">wc</span> -l &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">  - Find all files modified today and pass the results to a single <span class="built_in">command</span> as arguments:</span><br><span class="line">    find root_path -daystart -mtime -1 -<span class="built_in">exec</span> tar -cvf archive.tar &#123;&#125; \+</span><br><span class="line"></span><br><span class="line">  - Find empty files (0 byte) or directories and delete them verbosely:</span><br><span class="line">    find root_path -<span class="built_in">type</span> f|d -empty -delete -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line">Found 2 pages with the same name under the platforms: windows, windows.</span><br></pre></td></tr></table></figure></div>

<h1 id="2-fd"><a href="#2-fd" class="headerlink" title="2.fd"></a>2.fd</h1><p>仓库地址：<a href="https://github.com/sharkdp/fd"><code>fd</code>下载</a></p>
<p>安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S fd</span><br></pre></td></tr></table></figure></div>

<p>这是一款代替<code>find</code>命令的工具，语法简单且搜索效率很高。具体使用方式见仓库介绍。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Linux 下安装第三方字体</title>
    <url>/2025/01/11/Linux%E5%AE%89%E8%A3%85%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<h1 id="1-系统级字体目录"><a href="#1-系统级字体目录" class="headerlink" title="1.系统级字体目录"></a>1.系统级字体目录</h1><p>系统级字体目录通常位于 <code>/usr/share/fonts/</code> 下。你可以将字体文件复制到这个目录中，这样所有用户都可以使用这些字体。</p>
<ol>
<li><p>创建字体目录<br>如果没有找到合适的子目录，可以创建一个新的子目录来存放你的字体文件。例如，创建一个名为 <code>myfonts</code> 的目录：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /usr/share/fonts/myfonts</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>复制字体文件<br>将字体文件（如 <code>.ttf</code> 或 <code>.otf</code> 文件）复制到这个目录中：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /path/to/your/font.ttf /usr/share/fonts/myfonts/</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>更新字体缓存<br>安装字体后，需要更新字体缓存，以便系统能够识别新安装的字体：</p>
</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fc-cache -fv</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>fc-cache</code>：更新字体缓存。</li>
<li><code>-f</code>：强制更新缓存。</li>
<li><code>-v</code>：显示详细信息。</li>
</ul>
<h1 id="2-用户级字体目录"><a href="#2-用户级字体目录" class="headerlink" title="2.用户级字体目录"></a>2.用户级字体目录</h1><p>如果只想为当前用户安装字体，可以将字体文件复制到用户级字体目录中。用户级字体目录通常位于 <code>~/.local/share/fonts/</code>。</p>
<ol>
<li><p>创建字体目录<br>如果目录不存在，创建它：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.local/share/fonts</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>复制字体文件<br>将字体文件复制到这个目录中：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /path/to/your/font.ttf ~/.local/share/fonts/</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>更新字体缓存：<br>更新用户级字体缓存：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">fc-cache -fv ~/.local/share/fonts</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>如果没有<code>fc-cache</code>命令，记得安装<code>fontconfig</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S fontconfig</span><br></pre></td></tr></table></figure></div>

<p>Ubuntu 下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install fontconfig</span><br></pre></td></tr></table></figure></div>

<h1 id="3-验证字体是否安装成功"><a href="#3-验证字体是否安装成功" class="headerlink" title="3.验证字体是否安装成功"></a>3.验证字体是否安装成功</h1><p>你可以使用 <code>fc-list</code> 命令来验证字体是否安装成功：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">fc-list | grep FontName</span><br></pre></td></tr></table></figure></div>

<p>将 <code>FontName</code> 替换为你安装的字体名称。如果字体安装成功，你应该能看到字体的名称和路径。</p>
<h1 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h1><ul>
<li><strong>权限问题</strong> ：在系统级字体目录中安装字体时，可能需要管理员权限（使用 <code>sudo</code>）。</li>
<li><strong>字体格式</strong> ：确保你复制的字体文件是有效的字体格式（如 <code>.ttf</code>、<code>.otf</code>）。</li>
<li><strong>字体缓存</strong> ：每次安装或删除字体后，都需要更新字体缓存，否则新安装的字体可能不会立即生效。</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用指令汇总</title>
    <url>/2024/12/10/Linux%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1-查看开机启动项"><a href="#1-查看开机启动项" class="headerlink" title="1.查看开机启动项"></a>1.查看开机启动项</h1><h2 id="1-1-使用-systemctl-查看-systemd-服务"><a href="#1-1-使用-systemctl-查看-systemd-服务" class="headerlink" title="1.1 使用 systemctl 查看 systemd 服务"></a>1.1 使用 systemctl 查看 systemd 服务</h2><p>使用 <code>systemctl</code> 命令来列出所有启用的（开机自启动的）systemd 服务：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl list-unit-files --<span class="built_in">type</span>=service --state=enabled</span><br></pre></td></tr></table></figure></div>

<p>查看当前运行的服务：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl list-units --<span class="built_in">type</span>=service --state=running</span><br></pre></td></tr></table></figure></div>

<p>你也可以使用 <code>systemctl</code> 查看所有启用的单元文件，包括服务、套接字、目标等：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl list-unit-files --state=enabled</span><br></pre></td></tr></table></figure></div>

<p>如果是查看当前用户级别的服务，只需要加上参数<code>--user</code>即可，不需要<code>sudo</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl --user list-unit-files --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure></div>

<h2 id="1-2-查看用户和系统级别的开机自启动应用"><a href="#1-2-查看用户和系统级别的开机自启动应用" class="headerlink" title="1.2 查看用户和系统级别的开机自启动应用"></a>1.2 查看用户和系统级别的开机自启动应用</h2><p>用户级别的开机自启动应用通常在 <code>~/.config/autostart</code> 目录下。你可以使用以下命令查看该目录中的内容：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户</span></span><br><span class="line"><span class="built_in">ls</span> ~/.config/autostart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统</span></span><br><span class="line"><span class="built_in">ls</span> /etc/xdg/autostart</span><br></pre></td></tr></table></figure></div>

<h2 id="1-3-使用-crontab-查看定时任务"><a href="#1-3-使用-crontab-查看定时任务" class="headerlink" title="1.3 使用 crontab 查看定时任务"></a>1.3 使用 crontab 查看定时任务</h2><p>你还可以使用 <code>crontab</code> 查看是否有任何定时任务设置为在启动时运行。使用以下命令查看当前用户的 <code>crontab</code> 条目：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure></div>

<p>如果有需要在系统启动时运行的任务，它们通常会使用 <code>@reboot</code> 时间标志。</p>
<h2 id="1-4-检查-etc-rc-local-文件"><a href="#1-4-检查-etc-rc-local-文件" class="headerlink" title="1.4 检查 &#x2F;etc&#x2F;rc.local 文件"></a>1.4 检查 &#x2F;etc&#x2F;rc.local 文件</h2><p>虽然 <code>rc.local</code> 文件在现代系统中不再常用，但有时仍然会使用它来设置开机自启动任务。你可以检查这个文件（如果存在）来查看是否有任何任务设置为在启动时运行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/rc.local</span><br></pre></td></tr></table></figure></div>

<hr>
<h1 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2.文件操作"></a>2.文件操作</h1><h2 id="2-1-touch-指令"><a href="#2-1-touch-指令" class="headerlink" title="2.1 touch 指令"></a>2.1 touch 指令</h2><p>创建文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-2-mkdir-指令"><a href="#2-2-mkdir-指令" class="headerlink" title="2.2 mkdir 指令"></a>2.2 mkdir 指令</h2><p>创建文件夹：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> &lt;foldername&gt;</span><br></pre></td></tr></table></figure></div>
<p>强行创建，比如当<code>&lt;folder1&gt;</code>不存在时：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p &lt;folder1&gt;/&lt;folder2&gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-3-rm-指令"><a href="#2-3-rm-指令" class="headerlink" title="2.3 rm 指令"></a>2.3 rm 指令</h2><p>删除文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> &lt;filename1&gt; &lt;filename2&gt;</span><br></pre></td></tr></table></figure></div>

<p>删除该文件夹下的所有子文件</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> &lt;foldername&gt;/ -rf</span><br></pre></td></tr></table></figure></div>

<p>删除当前文件夹的所有文件</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> * -rf</span><br></pre></td></tr></table></figure></div>

<p><strong>注：</strong> 后缀的<code>-rf</code>是指强制删除（不会有警告），<code>-r</code>是指递归普通删除（若与其它文件有链接，会提出警告）。</p>
<h2 id="2-4-cp-指令"><a href="#2-4-cp-指令" class="headerlink" title="2.4 cp 指令"></a>2.4 cp 指令</h2><p>复制文件夹操作需要加<code>-r</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> &lt;foldername1&gt; &lt;foldername2&gt; -r</span><br></pre></td></tr></table></figure></div>

<h2 id="2-5-mv-指令"><a href="#2-5-mv-指令" class="headerlink" title="2.5 mv 指令"></a>2.5 mv 指令</h2><p>可以对文件或者文件夹进行重命名：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> test01.txt test02.txt</span><br></pre></td></tr></table></figure></div>
<p>如果<code>test01.txt</code>存在，<code>test02.txt</code>不存在，会把<code>test01.txt</code>命名为<code>test02.txt</code>。</p>
<p>对文件或者文件夹进行移动操作：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> /test.txt ~/temp</span><br></pre></td></tr></table></figure></div>
<p>把<code>test.txt</code>移动到<code>~/temp</code>文件夹下。</p>
<p>总结下<code>rm</code>、<code>cp</code>、<code>mv</code>这三种指令，对文件夹操作都会加上<code>-r</code>。这里表示<code>加上</code>-r<code>（或</code>–recursive&#96;）选项后，这些命令会递归地操作目录及其内容。</p>
<h2 id="2-6-find-指令"><a href="#2-6-find-指令" class="headerlink" title="2.6 find 指令"></a>2.6 find 指令</h2><ol>
<li><p><strong>基本语法</strong> ：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find [路径] [选项] [表达式]</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>查找特定目录下的所有文件</strong> ：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/directory</span><br></pre></td></tr></table></figure></div>
<p>这会列出<code>/path/to/directory</code>目录下的所有文件及其子目录下的文件。</p>
</li>
<li><p><strong>根据文件名查找</strong> ：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/directory -name <span class="string">&quot;filename.txt&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>使用 <code>-iname</code> 可以进行不区分大小写的查找：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/directory -iname <span class="string">&quot;filename.txt&quot;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>查找特定类型的文件</strong> ：<br>查找所有目录：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/directory -<span class="built_in">type</span> d</span><br></pre></td></tr></table></figure></div>
<p>查找所有普通文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/directory -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>根据文件大小查找</strong> ：<br>查找大于 1MB 的文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/directory -size +1M</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>根据修改时间查找</strong> ：<br>查找最近 7 天内修改过的文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/directory -mtime -7</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>执行命令</strong> ：<br>找到文件后执行命令，例如删除找到的文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">find /path/to/directory -name <span class="string">&quot;filename.txt&quot;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件夹</span></span><br><span class="line">find /path/to/directory -<span class="built_in">type</span> d -name <span class="string">&#x27;folder&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> -rf &#123;&#125; +</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>查找并列出文件的详细信息</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/directory -name <span class="string">&quot;filename.txt&quot;</span> -<span class="built_in">ls</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>结合多个条件</strong> ：<br>查找所有 <code>.txt</code> 文件并且大小大于 1MB：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/directory -name <span class="string">&quot;*.txt&quot;</span> -size +1M</span><br></pre></td></tr></table></figure></div></li>
</ol>
<hr>
<h1 id="3-权限"><a href="#3-权限" class="headerlink" title="3.权限"></a>3.权限</h1><ol>
<li><p>使用<code>chmod</code>命令递归地更改文件夹内所有文件和子文件夹的权限：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 777 /path/to/your/folder</span><br></pre></td></tr></table></figure></div>
<p><code>-R</code>表示递归。</p>
</li>
<li><p>更改文件的权限而不更改文件夹的权限，可以结合<code>find</code>命令来实现：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/your/folder -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">chmod</span> 777 &#123;&#125; +</span><br></pre></td></tr></table></figure></div>
<p>这将只更改所有文件的权限，而不影响文件夹的权限。</p>
</li>
<li><p>单独更改文件夹的权限（例如，给文件夹777权限，而文件保持不变）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/your/folder -<span class="built_in">type</span> d -<span class="built_in">exec</span> <span class="built_in">chmod</span> 777 &#123;&#125; +</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>把文件改为可执行</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x script.sh</span><br></pre></td></tr></table></figure></div>
<p><code>u</code>参数代表文件的所有者<code>user</code>，可以不加，但是就会改变组<code>group</code>和其他用户的权限。</p>
</li>
</ol>
<hr>
<h1 id="4-解压缩"><a href="#4-解压缩" class="headerlink" title="4.解压缩"></a>4.解压缩</h1><p><code>tar</code> 是一个常用的 Unix 和 Linux 工具，用于归档（打包）和压缩文件。</p>
<p>参数如下：</p>
<ul>
<li><strong><code>-z</code></strong> ：通过 <code>gzip</code> 压缩或解压缩数据。这个选项告诉 <code>tar</code> 文件是经过 <code>gzip</code> 压缩的。用于处理<code>.tar.gz</code>或<code>.tgz</code>文件。</li>
<li><strong>J</strong> ：使用<code>xz</code>来处理<code>.xz</code>格式的压缩文件。</li>
<li><strong><code>-x</code></strong> ：解压缩归档文件。这个选项指示 <code>tar</code> 从归档文件中提取文件。</li>
<li><strong><code>-v</code></strong> ：显示详细的输出。在解压缩或打包过程中，它会列出处理的文件名。</li>
<li><strong><code>-f</code></strong> ：指定归档文件的名称。这个选项后面需要跟上归档文件的名称。</li>
</ul>
<p>假设你有一个压缩的 tar 文件 <code>archive.tar.gz</code>，你可以使用以下命令来解压它：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf archive.tar.gz</span><br></pre></td></tr></table></figure></div>

<hr>
<h1 id="5-切换为-root-用户"><a href="#5-切换为-root-用户" class="headerlink" title="5.切换为 root 用户"></a>5.切换为 root 用户</h1><h2 id="5-1-使用-su-命令"><a href="#5-1-使用-su-命令" class="headerlink" title="5.1 使用 su 命令"></a>5.1 使用 <code>su</code> 命令</h2><p><code>su</code>（switch user）命令可以用来切换到其他用户，包括 <code>root</code> 用户。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">su -</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>-</code></strong> 选项（或 <code>--login</code>）会使 <code>su</code> 命令模拟一个完整的登录 shell，设置环境变量如 <code>PATH</code> 和 <code>HOME</code>，相当于从登录开始。</li>
<li>执行命令后，你会被提示输入 <code>root</code> 用户的密码。如果密码正确，你会切换到 <code>root</code> 用户。</li>
</ul>
<p>如果你只想切换到 <code>root</code> 用户而不加载 <code>root</code> 用户的环境配置，可以省略 <code>-</code> 选项：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure></div>

<h2 id="5-2-使用-sudo-命令"><a href="#5-2-使用-sudo-命令" class="headerlink" title="5.2 使用 sudo 命令"></a>5.2 使用 <code>sudo</code> 命令</h2><p><code>sudo</code> 命令允许以 <code>root</code> 用户或其他用户的身份执行命令。要切换到 <code>root</code> 用户，你可以使用以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> -i</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>-i</code></strong> 选项使 <code>sudo</code> 模拟一个登录 shell，切换到 <code>root</code> 用户并加载 <code>root</code> 用户的环境变量。</li>
</ul>
<p>如果你只想以 <code>root</code> 用户身份执行单个命令，可以直接在命令前加上 <code>sudo</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ls</span> /root</span><br></pre></td></tr></table></figure></div>

<p>这会以 <code>root</code> 用户的权限执行 <code>ls /root</code> 命令。</p>
<h2 id="5-3-使用-sudo-su-命令（常用）"><a href="#5-3-使用-sudo-su-命令（常用）" class="headerlink" title="5.3 使用 sudo su 命令（常用）"></a>5.3 使用 <code>sudo su</code> 命令（常用）</h2><p>你也可以通过 <code>sudo</code> 命令切换到 <code>root</code> 用户，使用以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> su -</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>sudo su -</code></strong> 组合命令先用 <code>sudo</code> 获得临时的 <code>root</code> 权限，再用 <code>su -</code> 切换到 <code>root</code> 用户。</li>
</ul>
<h2 id="5-4-注意事项"><a href="#5-4-注意事项" class="headerlink" title="5.4 注意事项"></a>5.4 注意事项</h2><ul>
<li><strong><code>root</code> 密码</strong> ：你需要知道 <code>root</code> 用户的密码来使用 <code>su</code> 命令。<code>sudo</code> 需要你当前用户在 <code>sudoers</code> 文件中有权限执行 <code>sudo</code> 命令，且你需要输入你自己的用户密码。</li>
<li><strong>权限管理</strong> ：在某些系统（如 Ubuntu）默认不启用 <code>root</code> 用户的密码，而是通过 <code>sudo</code> 提供管理员权限。你可能需要使用 <code>sudo</code> 命令而不是 <code>su</code> 来获得 <code>root</code> 权限。</li>
</ul>
<hr>
<h1 id="6-查看文件大小"><a href="#6-查看文件大小" class="headerlink" title="6.查看文件大小"></a>6.查看文件大小</h1><h2 id="6-1-使用-du-命令"><a href="#6-1-使用-du-命令" class="headerlink" title="6.1 使用 du 命令"></a>6.1 使用 <code>du</code> 命令</h2><p><code>du</code>（disk usage）命令用于显示文件和目录的磁盘使用情况：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh /path/to/directory</span><br></pre></td></tr></table></figure></div>

<p><strong>参数解释：</strong></p>
<ul>
<li><strong><code>-s</code></strong> ：显示总计，只显示指定目录的总大小，而不是递归显示每个子目录。</li>
<li><strong><code>-h</code></strong> ：以人类可读的格式显示大小（如 KB, MB, GB），使输出更易读。</li>
</ul>
<h2 id="6-2-使用-du-命令按大小排序"><a href="#6-2-使用-du-命令按大小排序" class="headerlink" title="6.2 使用 du 命令按大小排序"></a>6.2 使用 <code>du</code> 命令按大小排序</h2><p>如果你想按大小排序显示子目录，可以使用以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">du</span> -h /path/to/directory | <span class="built_in">sort</span> -h</span><br></pre></td></tr></table></figure></div>

<h2 id="6-3-使用-ls-命令查看目录大小"><a href="#6-3-使用-ls-命令查看目录大小" class="headerlink" title="6.3 使用 ls 命令查看目录大小"></a>6.3 使用 <code>ls</code> 命令查看目录大小</h2><p>尽管 <code>ls</code> 命令主要用于列出目录中的文件，它也可以用来查看目录的大小，但它的显示可能不如 <code>du</code> 直观。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lh /path/to/directory</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>-l</code>**：长格式列出文件信息，包括大小。</li>
<li>**<code>-h</code>**：以人类可读的格式显示文件大小。</li>
</ul>
<hr>
<h1 id="7-查看文件详细信息"><a href="#7-查看文件详细信息" class="headerlink" title="7.查看文件详细信息"></a>7.查看文件详细信息</h1><ol>
<li><p><strong>使用 <code>stat</code> 命令：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> filename</span><br></pre></td></tr></table></figure></div>
<p>这会显示文件的详细信息，包括创建时间（如果文件系统支持），通常在“Birth”字段下。如果你的文件系统不支持创建时间，它可能不会显示这个字段。</p>
</li>
<li><p><strong>使用 <code>debugfs</code> 工具（仅适用于 ext 文件系统）：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> debugfs -R <span class="string">&#x27;stat &lt;inode&gt;&#x27;</span> /dev/sdXn</span><br></pre></td></tr></table></figure></div>
<p>替换 <code>&lt;inode&gt;</code> 为实际的 inode 号，<code>/dev/sdXn</code> 为文件所在的分区。这种方法可以提供更详细的文件信息。</p>
</li>
<li><p><strong>文件系统支持：</strong><br>一些文件系统（如 ext4）支持创建时间，而其他文件系统（如 ext3）则可能不支持。如果你在 <code>stat</code> 输出中看不到创建时间，可能是因为你的文件系统不支持这一功能。</p>
</li>
</ol>
<hr>
<h1 id="8-提高编译速度的方法"><a href="#8-提高编译速度的方法" class="headerlink" title="8.提高编译速度的方法"></a>8.提高编译速度的方法</h1><h2 id="8-1-增加编译并行度"><a href="#8-1-增加编译并行度" class="headerlink" title="8.1 增加编译并行度"></a>8.1 增加编译并行度</h2><p>可以通过设置更多的并行编译任务来加速编译过程。使用与 CPU 核心数量相等或更多的并行任务数。设置 MAKEFLAGS 来实现这一点：</p>
<p>编辑 &#x2F;etc&#x2F;makepkg.conf 文件，找到以下行并进行修改：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAKEFLAGS=&quot;-j$(nproc)&quot;</span><br></pre></td></tr></table></figure></div>
<p><code>$(nproc)</code>会自动检测 CPU 核心数，并设置相同数量的并行任务。包括在执行<code>make</code>指令时，可以通过加<code>-j&lt;核心数&gt;</code>来手动指定编译时用CPU的核心数。</p>
<hr>
<h1 id="9-用户操作"><a href="#9-用户操作" class="headerlink" title="9.用户操作"></a>9.用户操作</h1><h2 id="9-1-创建一个新用户"><a href="#9-1-创建一个新用户" class="headerlink" title="9.1 创建一个新用户"></a>9.1 创建一个新用户</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd -m &lt;new_username&gt;</span><br></pre></td></tr></table></figure></div>
<p><code>-m</code>：创建用户的同时生成一个主目录。</p>
<p>为新用户设置密码：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> passwd &lt;new_username&gt;</span><br></pre></td></tr></table></figure></div>

<p>如果希望新用户拥有管理员权限，可以将其加入<code>sudo</code>组：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG <span class="built_in">sudo</span> &lt;new_username&gt;</span><br></pre></td></tr></table></figure></div>
<p>Arch 系的发行版是用下面这种方式：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG wheel &lt;new_username&gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="9-2-移除用户"><a href="#9-2-移除用户" class="headerlink" title="9.2 移除用户"></a>9.2 移除用户</h2><p>删除用户及其主目录：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> userdel -r &lt;username&gt;</span><br></pre></td></tr></table></figure></div>
<p><code>-r</code>：删除用户的同时移除用户的主目录及文件。如果不使用<code>-r</code>，只会删除用户账号，不会删除用户的主目录和文件。</p>
<hr>
<h1 id="10-grep-指令"><a href="#10-grep-指令" class="headerlink" title="10.grep 指令"></a>10.grep 指令</h1><p><code>grep</code> 是一个强大的文本搜索工具，它在 Unix 和类 Unix 系统（如 Linux）中用于搜索文件中匹配指定模式的行。<code>grep</code> 命令的名字来源于全局正则表达式打印（Global Regular Expression Print）。</p>
<h2 id="10-1-基本用法"><a href="#10-1-基本用法" class="headerlink" title="10.1 基本用法"></a>10.1 基本用法</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grep [选项] 模式 文件</span><br></pre></td></tr></table></figure></div>

<ul>
<li>模式：你想要搜索的文本模式或正则表达式。</li>
<li>文件：你想要搜索的文件。</li>
</ul>
<h2 id="10-2-常用选项"><a href="#10-2-常用选项" class="headerlink" title="10.2 常用选项"></a>10.2 常用选项</h2><ul>
<li><code>-i</code>：忽略大小写。</li>
<li><code>-v</code>：显示不匹配的行（即显示除了匹配行之外的所有行）。</li>
<li><code>-c</code>：显示匹配行的数量，不显示具体内容。</li>
<li><code>-n</code>：显示匹配行及行号。</li>
<li><code>-l</code>：显示包含匹配行的文件名。</li>
<li><code>--color</code>：将匹配的文本高亮显示。</li>
<li><code>-r</code> 或 <code>-R</code>：递归搜索指定目录下的所有文件。</li>
<li><code>-e</code>：允许多个搜索模式。</li>
</ul>
<h2 id="10-3-示例"><a href="#10-3-示例" class="headerlink" title="10.3 示例"></a>10.3 示例</h2><ol>
<li><p><strong>搜索包含特定文本的行：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;search_text&quot;</span> filename.txt</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>忽略大小写搜索：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grep -i <span class="string">&quot;SearchText&quot;</span> filename.txt</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>显示不匹配的行：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grep -v <span class="string">&quot;text_to_exclude&quot;</span> filename.txt</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>显示匹配行的行号：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grep -n <span class="string">&quot;search_text&quot;</span> filename.txt</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>递归搜索目录下所有文件：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grep -r <span class="string">&quot;search_text&quot;</span> /path/to/directory</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>显示匹配行的数量：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grep -c <span class="string">&quot;search_text&quot;</span> filename.txt</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>使用正则表达式搜索：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;^[0-9]&quot;</span> filename.txt</span><br></pre></td></tr></table></figure></div>
<p>这个命令会搜索所有以数字开头的行。</p>
</li>
<li><p><strong>使用多个模式搜索：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grep -e <span class="string">&quot;pattern1&quot;</span> -e <span class="string">&quot;pattern2&quot;</span> filename.txt</span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MiHomo(Clash Meta) 纯内核使用教程</title>
    <url>/2024/07/25/MiHomo%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-前言（说明）"><a href="#1-前言（说明）" class="headerlink" title="1.前言（说明）"></a>1.前言（说明）</h1><p>在 <a class="link"   href="https://github.com/" >github<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 上其实有不少的客户端和服务端的软件，如果不喜欢折腾的话，这篇文章可能不怎么适合你，建议直接使用第三方客户端的代理软件。这篇文章主要是记录自己使用 mihomo 的一些心得，因为强迫症的原因，所以是通过 docker 来部署整个代理服务的。当然，用 docker 部署也是有好处的，配置好后可以连同镜像一起打包备份或者<code>push</code>到 <a class="link"   href="https://hub.docker.com/" >Docker Hub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 上，后续电脑环境改变了仍然能使用。</p>
<h1 id="2-下载必要的文件"><a href="#2-下载必要的文件" class="headerlink" title="2.下载必要的文件"></a>2.下载必要的文件</h1><p>先把存放下载文件的项目文件夹创建好：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/clashmeta &amp;&amp; <span class="built_in">cd</span> clashmeta</span><br></pre></td></tr></table></figure></div>
<p>后续下载好的文件都放在<code>clashmeta</code>文件夹下。</p>
<h2 id="2-1-内核"><a href="#2-1-内核" class="headerlink" title="2.1 内核"></a>2.1 内核</h2><p><a class="link"   href="https://github.com/MetaCubeX/mihomo/releases" >稳定版下载地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>我这里用的是 debian 镜像，所以下载的是这个版本：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/25/n5DSvEiMquTJ7fC.png"
                      alt="image01.png"
                ><figcaption>image01.png</figcaption></figure></p>
<h2 id="2-2-GeoIP-GeoSite-库"><a href="#2-2-GeoIP-GeoSite-库" class="headerlink" title="2.2 GeoIP &amp; GeoSite 库"></a>2.2 GeoIP &amp; GeoSite 库</h2><p><a class="link"   href="https://gcore.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geoip.dat" >GeoIP 库下载<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://gcore.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geosite.dat" >GeoSite 库下载<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="2-3-config-yaml-配置文件"><a href="#2-3-config-yaml-配置文件" class="headerlink" title="2.3 config.yaml 配置文件"></a>2.3 config.yaml 配置文件</h2><p><a class="link"   href="https://github.com/loskyertt/clash_meta/blob/master/config.yaml" >config.yaml 下载<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>需要把<code>config.yaml</code>这部分内容修改以下：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/25/uwHzqYafTrVlxE2.png"
                      alt="image02.png"
                ><figcaption>image02.png</figcaption></figure></p>
<p>填上自己的机场链接即可。</p>
<h2 id="2-4-UI-文件"><a href="#2-4-UI-文件" class="headerlink" title="2.4 UI 文件"></a>2.4 UI 文件</h2><p><a class="link"   href="https://github.com/MetaCubeX/metacubexd" >ui 下载<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="3-拉取镜像"><a href="#3-拉取镜像" class="headerlink" title="3.拉取镜像"></a>3.拉取镜像</h1><p>mihomo 的作者在 Docker Hub 上是有镜像的，但是里面没有说明文档，我在后面进行补充。</p>
<p>直接拉取最新的稳定版本的 debian 镜像即可：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull debian</span><br></pre></td></tr></table></figure></div>

<h1 id="4-开始配置"><a href="#4-开始配置" class="headerlink" title="4.开始配置"></a>4.开始配置</h1><h2 id="4-1-创建容器"><a href="#4-1-创建容器" class="headerlink" title="4.1 创建容器"></a>4.1 创建容器</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name clashmeta -p 7890:7890 -p 9090:9090 -v ~/clashmeta:/root/clashmeta debian:latest /bin/bash</span><br></pre></td></tr></table></figure></div>
<p>此时直接进入了创建好的容器内部。<br><strong>说明：</strong> 这里的<code>7890</code>端口是代理端口，<code>9090</code>端口是本地网站端口。</p>
<h2 id="4-2-容器内的操作"><a href="#4-2-容器内的操作" class="headerlink" title="4.2 容器内的操作"></a>4.2 容器内的操作</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/clashmeta</span><br></pre></td></tr></table></figure></div>

<p>执行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -i mihomo-linux-amd64-v1.18.6.deb</span><br></pre></td></tr></table></figure></div>
<p>把<code>mihomo</code>安装到容器内。可以通过<code>which mihomo</code>来查看是否安装成功。</p>
<p>开启代理，输入：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">mihomo -d ./</span><br></pre></td></tr></table></figure></div>
<p>然后打开浏览器输入<code>http://127.0.0.1:9090/ui</code>就能进入代理界面。</p>
<h1 id="5-使用现成的镜像配置"><a href="#5-使用现成的镜像配置" class="headerlink" title="5.使用现成的镜像配置"></a>5.使用现成的镜像配置</h1><p>拉取镜像：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull metacubex/mihomo:latest</span><br></pre></td></tr></table></figure></div>

<p>如果当前网络环境不行的话，也可以使用我存放在阿里的镜像：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/loskyertt/meta:1.18.8</span><br></pre></td></tr></table></figure></div>

<p>创建卷挂在目录：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume create mihomo</span><br></pre></td></tr></table></figure></div>

<p>创建容器实例：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --name=mihomo --restart=always -p7890:7890 -p9090:9090 -v mihomo:/root/.config/mihomo metacubex/mihomo:latest</span><br></pre></td></tr></table></figure></div>

<p>然后把配置文件（<code>config.yaml</code>）和<code>ui</code>文件移到卷挂载目录下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> config.yaml /var/lib/docker/volumes/mihomo/_data/</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> ui /var/lib/docker/volumes/mihomo/_data/</span><br></pre></td></tr></table></figure></div>

<p>重启容器即可：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart mihomo</span><br></pre></td></tr></table></figure></div>

<h1 id="6-结果图"><a href="#6-结果图" class="headerlink" title="6.结果图"></a>6.结果图</h1><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/25/ulftdepWhZK3YR4.png"
                      alt="image03.png"
                ><figcaption>image03.png</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/25/qxW3TZfYP5lBS9p.png"
                      alt="image04.png"
                ><figcaption>image04.png</figcaption></figure></p>
<h1 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7.注意事项"></a>7.注意事项</h1><p>如果发现仍然不能科学上网，可以打开“设置”检查下“代理设置”，手动设置代理地址和端口<code>127.0.0.1:7890</code>（火狐浏览器可能需要在内置的浏览器设置中进行配置下）。对于 Windows 用户来说，其实操作逻辑都是一样的（当然也可以不用 docker ），配置完后注意设置防火墙就行。</p>
<h1 id="8-参考教程"><a href="#8-参考教程" class="headerlink" title="8.参考教程"></a>8.参考教程</h1><ul>
<li><a class="link"   href="https://www.youtube.com/watch?v=d-2vCYLjXHs&t=23s" >【进阶使用】Clash Meta 纯内核使用教程|多机场融合|规则自动更新|Tun虚拟网卡模式|避免DNS泄露|WebRTC泄露<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
        <tag>proxy</tag>
        <tag>clash</tag>
      </tags>
  </entry>
  <entry>
    <title>Nix 使用教程</title>
    <url>/2024/12/03/Nix%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-Nix-简述"><a href="#1-Nix-简述" class="headerlink" title="1.Nix 简述"></a>1.Nix 简述</h1><h2 id="1-1-安装方法"><a href="#1-1-安装方法" class="headerlink" title="1.1 安装方法"></a>1.1 安装方法</h2><ol>
<li><p>官方推荐的安装方式：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh &lt;(curl -L https://nixos.org/nix/install)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>多用户安装（推荐）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh &lt;(curl -L https://nixos.org/nix/install) --daemon</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>安装好后，记得执行下<code>source ~/.bashrc</code>或者<code>source ~/.zshrc</code>进行初始化，取决于你用的是<code>bash</code>还是<code>zsh</code>。</p>
<p>还可以手动初始化：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">. ~/.nix-profile/etc/profile.d/nix.sh</span><br></pre></td></tr></table></figure></div>

<h2 id="1-2-Nix-的优缺点"><a href="#1-2-Nix-的优缺点" class="headerlink" title="1.2 Nix 的优缺点"></a>1.2 Nix 的优缺点</h2><p>优点：</p>
<ol>
<li>跨平台兼容性</li>
</ol>
<ul>
<li>可以在 Ubuntu、Fedora、macOS 等多种系统上使用</li>
<li>保持了包管理的一致性</li>
</ul>
<ol start="2">
<li>依赖管理优势</li>
</ol>
<ul>
<li>完全可重现的包管理</li>
<li>可以精确控制软件包版本</li>
<li>不同版本软件可以并存</li>
<li>回滚和切换软件版本非常容易</li>
</ul>
<ol start="3">
<li>隔离性</li>
</ol>
<ul>
<li>每个包都在独立的目录中</li>
<li>避免包之间的冲突</li>
<li>不会污染系统环境</li>
</ul>
<ol start="4">
<li>原子性更新</li>
</ol>
<ul>
<li>要么完全成功，要么完全回滚</li>
<li>降低系统损坏风险</li>
</ul>
<p>缺点：</p>
<ol>
<li>学习成本高</li>
</ol>
<ul>
<li>Nix 语言和概念相对复杂</li>
<li>与传统包管理器差异较大</li>
</ul>
<ol start="2">
<li>性能开销</li>
</ol>
<ul>
<li>首次安装和下载可能较慢</li>
<li>额外的存储空间消耗</li>
</ul>
<ol start="3">
<li>社区支持</li>
</ol>
<ul>
<li>相比<code>apt</code>、<code>yum</code>，生态较小</li>
<li>部分软件包可能不够及时</li>
</ul>
<h2 id="1-3-使用示例"><a href="#1-3-使用示例" class="headerlink" title="1.3 使用示例"></a>1.3 使用示例</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装软件</span></span><br><span class="line">nix-env -iA nixpkgs.firefox</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出已安装软件</span></span><br><span class="line">nix-env -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载软件</span></span><br><span class="line">nix-env -e firefox</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新所有软件</span></span><br><span class="line">nix-channel --update</span><br><span class="line">nix-env -u</span><br></pre></td></tr></table></figure></div>

<p>建议：</p>
<ul>
<li>对于日常使用，可以并存使用系统原生包管理器</li>
<li>适合开发者和追求系统可控性的用户</li>
<li>不建议完全替代系统默认包管理器</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>nix</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10 SSH 服务配置</title>
    <url>/2024/07/30/Openssh%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="1-Windows-10-下安装-SSH-服务（Openssh）"><a href="#1-Windows-10-下安装-SSH-服务（Openssh）" class="headerlink" title="1.Windows 10 下安装 SSH 服务（Openssh）"></a>1.Windows 10 下安装 SSH 服务（Openssh）</h1><h2 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h2><p><a href="https://github.com/PowerShell/Win32-OpenSSH"> <strong>Openssh 下载地址</strong> </a></p>
<h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2 解压"></a>1.2 解压</h2><p>解压到如下目录（建议加压到<code>C:\Program Files</code>下，不然会出现未知错误）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Program Files\OpenSSH_Win64\</span><br></pre></td></tr></table></figure></div>

<h2 id="1-3-安装"><a href="#1-3-安装" class="headerlink" title="1.3 安装"></a>1.3 安装</h2><p><strong>注意：</strong> 一定要使用<code>powershell</code>并且要以管理员的身份打开。</p>
<ul>
<li><p>Windows 下开启运行执行<code>*.sp1</code>文件类型：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">set-executionpolicy remotesigned</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>安装<code>sshd</code></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Program Files\OpenSSH_Win64\</span><br><span class="line"></span><br><span class="line">./install-sshd.ps1</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="1-4-测试连接"><a href="#1-4-测试连接" class="headerlink" title="1.4 测试连接"></a>1.4 测试连接</h2><ul>
<li><p>验证是否安装成功：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -V</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>测试是否能与远程主机进行连接：<br>在与远程主机连接之前确保能<code>ping</code>通，然后通过<code>ssh &lt;username&gt;@&lt;PCIPAddr&gt;</code>与远程主机进行连接。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy Settings</title>
    <url>/2024/07/19/Proxy-Settings/</url>
    <content><![CDATA[<h1 id="一、代理软件配置"><a href="#一、代理软件配置" class="headerlink" title="一、代理软件配置"></a>一、代理软件配置</h1><h2 id="1-1-speedTest"><a href="#1-1-speedTest" class="headerlink" title="1.1 speedTest"></a>1.1 speedTest</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 日本</span></span><br><span class="line">https://185-140-53-2.lg.looking.house/1000.mb</span><br><span class="line"><span class="comment"># 新加坡</span></span><br><span class="line">https://23-27-101-2.lg.looking.house/100.mb</span><br><span class="line"></span><br><span class="line">https://speed.cloudflare.com/__down?bytes=10000000</span><br><span class="line">https://speed.cloudflare.com/__down?bytes=50000000</span><br><span class="line">https://speed.cloudflare.com/__down?bytes=100000000</span><br><span class="line">https://speed.cloudflare.com/__down?bytes=200000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 老版测速</span></span><br><span class="line">http://cachefly.cachefly.net/10mb.<span class="built_in">test</span></span><br><span class="line">http://cachefly.cachefly.net/50mb.<span class="built_in">test</span></span><br><span class="line">http://cachefly.cachefly.net/100mb.<span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>

<h2 id="1-2-speedurl"><a href="#1-2-speedurl" class="headerlink" title="1.2 speedurl"></a>1.2 speedurl</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.google.com/generate_204</span><br><span class="line"></span><br><span class="line">http://cp.cloudflare.com/</span><br><span class="line"></span><br><span class="line">http://connectivitycheck.gstatic.com/generate_204</span><br></pre></td></tr></table></figure></div>

<h2 id="1-3-DNS选项"><a href="#1-3-DNS选项" class="headerlink" title="1.3 DNS选项"></a>1.3 DNS选项</h2><ul>
<li><strong>远程DNS</strong></li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">udp://1.1.1.1</span><br><span class="line"></span><br><span class="line">https://dns.google/dns-query</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>直连DNS</strong></li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">114.114.114.114</span><br><span class="line"></span><br><span class="line">https://doh.pub/dns-query</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 下的多进程和多线程编程</title>
    <url>/2024/09/16/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-多进程"><a href="#1-多进程" class="headerlink" title="1.多进程"></a>1.多进程</h1><h2 id="1-1-使用多进程完成任务"><a href="#1-1-使用多进程完成任务" class="headerlink" title="1. 1 使用多进程完成任务"></a>1. 1 使用多进程完成任务</h2><p>用到的包：<code>multiprocessing</code>，以下面的代码为例：</p>
<p>运行的函数示例：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;sing ...&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;dance ...&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>采用常规方式：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="comment"># 常规方式</span></span><br><span class="line">    sing()</span><br><span class="line">    dance()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;花费的时间：<span class="subst">&#123;end - start&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>在运行时可以发现，是先运行<code>sing</code>函数，直到<code>sing</code>函数完全执行完后，再运行的<code>dance</code>函数，输出结果为：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">sing ...</span><br><span class="line">sing ...</span><br><span class="line">sing ...</span><br><span class="line">dance ...</span><br><span class="line">dance ...</span><br><span class="line">dance ...</span><br><span class="line">花费的时间：3.001246929168701</span><br></pre></td></tr></table></figure></div>
<p>和预想的时间差不多。</p>
</li>
<li><p>采用多进程方式：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="comment"># 多进程方式</span></span><br><span class="line">    process1 = multiprocessing.Process(target=sing)</span><br><span class="line">    process2 = multiprocessing.Process(target=dance)</span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br><span class="line">    process1.join()</span><br><span class="line">    process2.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;花费的时间：<span class="subst">&#123;end - start&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>这里的<code>Process</code>类用于创建一个新的子进程。在运行时可以发现，<code>sing</code>和<code>dance</code>函数在同时进行，同时观察到输出结果为：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">sing ...</span><br><span class="line">dance ...</span><br><span class="line">sing ...</span><br><span class="line">dance ...</span><br><span class="line">sing ...</span><br><span class="line">dance ...</span><br><span class="line">花费的时间：1.5049564838409424</span><br></pre></td></tr></table></figure></div>
<p>基本上是在 <code>1.5s</code>左右，差不多就是一个函数执行完所需要的时间，多进程执行让两个函数同时开始执行。</p>
</li>
</ul>
<h2 id="1-2-join-方法"><a href="#1-2-join-方法" class="headerlink" title="1.2 join 方法"></a>1.2 join 方法</h2><p>注意：在多线程编程中也可以用这个方法！</p>
<p>当我们启动多个进程时，主进程默认不会等待这些子进程结束，而是继续执行自己的代码。通过调用子进程的<code>join()</code>方法，主进程会暂停执行，直到该子进程运行结束后再继续。</p>
<p><strong>主要作用如下：</strong></p>
<p><strong>确保子进程结束后再继续执行：</strong> 主进程在调用<code>join()</code>时会等待相应的子进程执行完毕，再继续执行后续代码。<br><strong>同步进程：</strong> 如果不使用<code>join()</code>，主进程可能会在子进程执行完之前就结束，从而导致子进程也被强行终止。</p>
<p>比如说这个例子：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    process1 = multiprocessing.Process(target=sing)</span><br><span class="line">    process2 = multiprocessing.Process(target=dance)</span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个测试 ... ...&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>输出结果是：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">sing ...</span><br><span class="line">dance ...</span><br><span class="line">sing ...</span><br><span class="line">dance ...</span><br><span class="line">这是一个测试 ... ...</span><br><span class="line">sing ...</span><br><span class="line">dance ...</span><br></pre></td></tr></table></figure></div>
<p>要输出主进程中的<code>print(&quot;这是一个测试 ... ...&quot;)</code>，需要等<code>1s</code>的时间，正好是在<code>sing</code>和<code>dance</code>函数中的循环体打印两次所需要的时间，可以发现，在到运行的时间时，主进程就直接开始执行了。</p>
<p>现在换成用<code>join()</code>方法：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    process1 = multiprocessing.Process(target=sing)</span><br><span class="line">    process2 = multiprocessing.Process(target=dance)</span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br><span class="line">    process1.join()</span><br><span class="line">    process2.join()</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(f&quot;这是一个测试 ... ...，所花费的时间为：&#123;end - start&#125;&quot;)</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">sing ...</span><br><span class="line">dance ...</span><br><span class="line">sing ...</span><br><span class="line">dance ...</span><br><span class="line">sing ...</span><br><span class="line">dance ...</span><br><span class="line">这是一个测试 ... ...，所花费的时间为：1.0003576278686523</span><br></pre></td></tr></table></figure></div>
<p>可以看出，是在子进程中的函数执行完后，再执行主进程中的内容。</p>
<h2 id="1-3-进程执行带有参数的任务"><a href="#1-3-进程执行带有参数的任务" class="headerlink" title="1.3 进程执行带有参数的任务"></a>1.3 进程执行带有参数的任务</h2><p>运行的函数示例：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;sing ...&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;dance ...&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    process1 = multiprocessing.Process(target=sing, args=(<span class="number">3</span>, ))</span><br><span class="line">    process2 = multiprocessing.Process(target=dance, kwargs=&#123;<span class="string">&#x27;num&#x27;</span>: <span class="number">3</span>&#125;)</span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br></pre></td></tr></table></figure></div>

<p>一共有两种传参方式：</p>
<ul>
<li><strong>args:</strong> 元组传参，需要注意只有一个参数时，要用逗号结尾，以及传如参数的顺序。</li>
<li><strong>kwargs:</strong> 字典传参，注意<code>key</code>要对应。</li>
</ul>
<h2 id="1-4-获取子-父进程-PID"><a href="#1-4-获取子-父进程-PID" class="headerlink" title="1.4 获取子&#x2F;父进程 PID"></a>1.4 获取子&#x2F;父进程 PID</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;sing 的父进程 pid：&#x27;</span>, os.getppid())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;sing 的子进程 pid：&#x27;</span>, os.getpid())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;sing ...&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;dance 的父进程 pid：&#x27;</span>, os.getppid())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;dance 的子进程 pid：&#x27;</span>, os.getpid())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;dance ...&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;程序的父进程 pid（终端/Shell）：&#x27;</span>, os.getppid())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前 Python 解释器的 pid：&#x27;</span>, os.getpid())</span><br><span class="line"></span><br><span class="line">    process1 = multiprocessing.Process(target=sing, args=(<span class="number">3</span>, ))</span><br><span class="line">    process2 = multiprocessing.Process(target=dance, kwargs=&#123;<span class="string">&#x27;num&#x27;</span>: <span class="number">3</span>&#125;)</span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br></pre></td></tr></table></figure></div>
<p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">程序的父进程 pid（终端/Shell）： 13583</span><br><span class="line">当前 Python 解释器的 pid： 23492</span><br><span class="line">sing 的父进程 pid： 23492</span><br><span class="line">sing 的子进程 pid： 23493</span><br><span class="line">sing ...</span><br><span class="line">dance 的父进程 pid： 23492</span><br><span class="line">dance 的子进程 pid： 23494</span><br><span class="line">dance ...</span><br><span class="line">sing ...</span><br><span class="line">dance ...</span><br><span class="line">sing ...</span><br><span class="line">dance ...</span><br></pre></td></tr></table></figure></div>

<h2 id="1-5-守护进程"><a href="#1-5-守护进程" class="headerlink" title="1.5 守护进程"></a>1.5 守护进程</h2><p>运行的函数示例：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;working ...&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>在默认情况下，主进程会等待子进程完全执行结束才会退出。<br>比如这样：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    sub_process = multiprocessing.Process(target=work)</span><br><span class="line">    sub_process.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;任务执行结束！&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p>输出结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">working ...</span><br><span class="line">working ...</span><br><span class="line">working ...</span><br><span class="line">任务执行结束！</span><br><span class="line">working ...</span><br><span class="line">working ...</span><br><span class="line">working ...</span><br></pre></td></tr></table></figure></div>
<p>主进程执行到<code>print(&#39;任务执行结束！&#39;)</code>这里的时候，已经是执行完了的，但是主进程并没有退出，而是在执行完子进程后才退出的。</p>
<p>现在是设置守护进程的效果：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    sub_process = multiprocessing.Process(target=work)</span><br><span class="line">    sub_process.daemon = <span class="literal">True</span></span><br><span class="line">    sub_process.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;任务执行结束！&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p>让<code>daemon = True</code>来设置守护进程，主进程退出后，子进程会被直接销毁，不再执行子进程中的代码。<br>除了用这种方式，还可以通过像<code>Process</code>传入参数来设置：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    sub_process = multiprocessing.Process(target=work, daemon=<span class="literal">True</span>)</span><br><span class="line">    sub_process.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;任务执行结束！&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p>两种方式的效果都是一样的。</p>
<h1 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2.多线程"></a>2.多线程</h1><h2 id="2-1-使用多线程完成任务"><a href="#2-1-使用多线程完成任务" class="headerlink" title="2.1 使用多线程完成任务"></a>2.1 使用多线程完成任务</h2><p>用到的包：<code>threading</code>，以下面的代码为例：</p>
<p>运行的函数示例：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i  <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;singing ...&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;dancing ...&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>采用多线程方式：<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    thread1 = threading.Thread(target=sing)</span><br><span class="line">    thread2 = threading.Thread(target=dance)</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line">    end = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;花费的时间：<span class="subst">&#123;end - start&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>
输出结果：<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">singing ...</span><br><span class="line">dancing ...</span><br><span class="line">singing ...</span><br><span class="line">dancing ...</span><br><span class="line">singing ...</span><br><span class="line">dancing ...</span><br><span class="line">花费的时间：3.0005264282226562</span><br></pre></td></tr></table></figure></div>
使用方式基本上和多进程的一样，只是把包名和函数名换了。</li>
</ul>
<h2 id="2-2-join-方法"><a href="#2-2-join-方法" class="headerlink" title="2.2 join 方法"></a>2.2 join 方法</h2><p>参考多进程的设置方式。</p>
<h2 id="2-3-线程执行带有参数的任务"><a href="#2-3-线程执行带有参数的任务" class="headerlink" title="2.3 线程执行带有参数的任务"></a>2.3 线程执行带有参数的任务</h2><p>参考多进程的设置方式，一模一样。</p>
<h2 id="2-4-守护线程"><a href="#2-4-守护线程" class="headerlink" title="2.4 守护线程"></a>2.4 守护线程</h2><p>参考多进程的设置方式，一模一样。</p>
<h2 id="2-5-线程之间的执行顺序"><a href="#2-5-线程之间的执行顺序" class="headerlink" title="2.5  线程之间的执行顺序"></a>2.5  线程之间的执行顺序</h2><p>线程之间的执行是无序的，以下面这段代码为例：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work</span>():</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    get_thread = threading.current_thread()</span><br><span class="line">    <span class="built_in">print</span>(get_thread)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        sub_thread = threading.Thread(target=work)</span><br><span class="line">        sub_thread.start()</span><br></pre></td></tr></table></figure></div>

<p>执行结果是这样的：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;Thread(Thread-1 (work), started 140407841228480)&gt;</span><br><span class="line">&lt;Thread(Thread-2 (work), started 140407830742720)&gt;</span><br><span class="line">&lt;Thread(Thread-3 (work), started 140407820256960)&gt;</span><br><span class="line">&lt;Thread(Thread-4 (work), started 140407809771200)&gt;</span><br><span class="line">&lt;Thread(Thread-5 (work), started 140407799285440)&gt;</span><br></pre></td></tr></table></figure></div>
<p>从这一个结果上看可能就会得出错误的结论：哪个线程先创建，哪个线程就先执行。但事实上如果我们多执行几次这段代码，就会发现，可能会出现这样的结果：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;Thread(Thread-2 (work), started 130684293220032)&gt;</span><br><span class="line">&lt;Thread(Thread-4 (work), started 130684272248512)&gt;</span><br><span class="line">&lt;Thread(Thread-3 (work), started 130684282734272)&gt;</span><br><span class="line">&lt;Thread(Thread-1 (work), started 130684303705792)&gt;</span><br><span class="line">&lt;Thread(Thread-5 (work), started 130684261762752)&gt;</span><br></pre></td></tr></table></figure></div>
<p>可以看出，线程并非是按创建顺序来执行的。这是由于线程调度的随机性，打印顺序是不确定的。</p>
<h1 id="3-总结-多线程和多进程的区别"><a href="#3-总结-多线程和多进程的区别" class="headerlink" title="3.总结-多线程和多进程的区别"></a>3.总结-多线程和多进程的区别</h1><h2 id="3-1-工作原理"><a href="#3-1-工作原理" class="headerlink" title="3.1 工作原理"></a>3.1 工作原理</h2><ul>
<li><p><strong>多线程（Threading）：</strong></p>
<ul>
<li>多线程是在 <strong>同一个进程的不同线程</strong> 中执行代码。线程是轻量级的执行单元，多个线程共享同一进程的内存空间。</li>
<li>在 Python 中，线程受制于全局解释器锁（GIL），这个锁保证同一时刻只有一个线程执行 Python 字节码。因此，尽管在多线程环境中可以并发执行 I&#x2F;O 密集型任务，但对于 CPU 密集型任务，多线程并不会真正实现并行执行。</li>
</ul>
</li>
<li><p><strong>多进程（Multiprocessing）：</strong></p>
<ul>
<li>多进程则是在 <strong>多个独立的进程</strong> 中运行，每个进程都有自己独立的内存空间和全局解释器锁（GIL）。这意味着不同进程可以真正地在多个 CPU 核心上并行运行，互不干扰。</li>
<li>由于进程间不共享内存，因此进程之间的通信需要通过诸如管道（pipes）、队列（queues）等方式进行。</li>
</ul>
</li>
</ul>
<h2 id="3-2-适用场景"><a href="#3-2-适用场景" class="headerlink" title="3.2 适用场景"></a>3.2 适用场景</h2><ul>
<li><p><strong>多线程：</strong></p>
<ul>
<li>适合<strong>I&#x2F;O 密集型任务</strong>，比如文件读写、网络请求等。在这种情况下，线程在等待 I&#x2F;O 操作时可以释放 GIL，从而让其他线程运行。</li>
<li><strong>不适合 CPU 密集型任务</strong>，如大量数学计算，因为 GIL 限制了同一时刻只能有一个线程在执行 Python 代码，无法充分利用多核 CPU。</li>
</ul>
</li>
<li><p><strong>多进程：</strong></p>
<ul>
<li>适合<strong>CPU 密集型任务</strong>，例如图像处理、复杂的数学计算、机器学习模型训练等。每个进程都拥有独立的 GIL，因此可以在多核 CPU 上并行执行任务。</li>
<li>对于 I&#x2F;O 密集型任务，也可以使用多进程，不过进程的启动和通信开销较大，性能未必优于多线程。</li>
</ul>
</li>
</ul>
<h2 id="3-3-性能与资源开销"><a href="#3-3-性能与资源开销" class="headerlink" title="3.3 性能与资源开销"></a>3.3 性能与资源开销</h2><ul>
<li><p><strong>多线程：</strong></p>
<ul>
<li>线程共享同一进程的内存空间，因此线程之间的数据共享和通信非常快。</li>
<li>线程是轻量级的，创建和管理的开销相对较小。</li>
<li>由于 GIL 的限制，多线程无法充分利用多核 CPU 进行并行计算，在线程数量较多时，频繁的上下文切换也会影响性能。</li>
</ul>
</li>
<li><p><strong>多进程：</strong></p>
<ul>
<li>进程之间独立运行，不共享内存，每个进程都有自己的内存空间。这使得进程间的通信开销较大，数据传输需要序列化（例如通过 <code>pickle</code>）。</li>
<li>进程的启动和管理开销较大，因为操作系统需要为每个进程分配内存和资源。</li>
<li>多进程可以充分利用多核 CPU，实现真正的并行计算。</li>
</ul>
</li>
</ul>
<h2 id="3-4-资源共享与数据传递"><a href="#3-4-资源共享与数据传递" class="headerlink" title="3.4 资源共享与数据传递"></a>3.4 资源共享与数据传递</h2><ul>
<li><p><strong>多线程：</strong></p>
<ul>
<li>线程共享内存空间，因此线程间的变量和数据是共享的。这带来了方便，但也容易引发竞争条件（race conditions）和线程安全问题，必须通过锁（<code>Lock</code>）、信号量（<code>Semaphore</code>）等机制来保护共享资源。</li>
</ul>
</li>
<li><p><strong>多进程：</strong></p>
<ul>
<li>进程不共享内存，因此每个进程有自己独立的数据空间。如果需要在进程间传递数据，必须使用进程间通信（IPC）机制，例如队列（<code>Queue</code>）、管道（<code>Pipe</code>）等。进程间通信的开销比线程间通信更大。</li>
</ul>
</li>
</ul>
<h2 id="3-5-故障隔离"><a href="#3-5-故障隔离" class="headerlink" title="3.5 故障隔离"></a>3.5 故障隔离</h2><ul>
<li><p><strong>多线程：</strong></p>
<ul>
<li>由于线程共享内存空间，如果一个线程发生异常，可能会影响其他线程，甚至导致整个进程崩溃。</li>
</ul>
</li>
<li><p><strong>多进程：</strong></p>
<ul>
<li>每个进程是相互独立的，如果一个进程崩溃了，其他进程仍然可以继续运行。因此多进程的故障隔离性更好。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Python技巧</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 获取当前代理 IP</title>
    <url>/2024/09/21/Python-%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86ip/</url>
    <content><![CDATA[<h1 id="1-Linux-下查看当前代理-IP"><a href="#1-Linux-下查看当前代理-IP" class="headerlink" title="1.Linux 下查看当前代理 IP"></a>1.Linux 下查看当前代理 IP</h1><h2 id="1-1-通过命令行查看当前的外部-IP"><a href="#1-1-通过命令行查看当前的外部-IP" class="headerlink" title="1.1 通过命令行查看当前的外部 IP"></a>1.1 通过命令行查看当前的外部 IP</h2><p>使用 <code>curl</code> 命令向外部网站请求，来查看当前代理访问的外部IP地址：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x http://localhost:port https://api.ipify.org</span><br></pre></td></tr></table></figure></div>

<p>或使用 <code>ifconfig.me</code> 服务：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x http://localhost:port http://ifconfig.me</span><br></pre></td></tr></table></figure></div>

<p>这里 <code>localhost:port</code> 是你本地当前代理运行的地址和端口。</p>
<p>如果你的代理使用的是 <code>socks</code> 协议，可以这样：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl --socks5 localhost:port https://api.ipify.org</span><br></pre></td></tr></table></figure></div>

<h2 id="1-2-通过浏览器插件或在线服务"><a href="#1-2-通过浏览器插件或在线服务" class="headerlink" title="1.2 通过浏览器插件或在线服务"></a>1.2 通过浏览器插件或在线服务</h2><p>你可以使用浏览器访问以下在线服务来查看当前外部 IP：</p>
<ul>
<li><a class="link"   href="https://www.whatismyip.com/" >What Is My IP<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://ipinfo.io/" >IPinfo.io<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>这些网站可以直接显示你当前使用的公网IP地址。如果你使用代理，显示的会是代理服务器的IP。</p>
<h1 id="2-Python-获取当前代理-IP"><a href="#2-Python-获取当前代理-IP" class="headerlink" title="2. Python 获取当前代理 IP"></a>2. Python 获取当前代理 IP</h1><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理地址，设置为你本地代理的地址和端口</span></span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="comment"># 记得改成自己的端口号</span></span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://localhost:7890&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;http://localhost:7890&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问外部API，获取代理IP</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(<span class="string">&#x27;http://api.ipify.org&#x27;</span>, proxies=proxy)</span><br><span class="line">    current_ip = response.text</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Current proxy IP: <span class="subst">&#123;current_ip&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error retrieving IP: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式提取代理IP和端口</span></span><br><span class="line">proxy_address = proxy[<span class="string">&#x27;http&#x27;</span>]</span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;http://([^\:]+):(\d+)&#x27;</span>, proxy_address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    ip = <span class="keyword">match</span>.group(<span class="number">1</span>)  <span class="comment"># 提取IP地址</span></span><br><span class="line">    port = <span class="keyword">match</span>.group(<span class="number">2</span>)  <span class="comment"># 提取端口号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;IP: <span class="subst">&#123;ip&#125;</span>, Port: <span class="subst">&#123;port&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Invalid proxy format&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>如果是在 Docker 容器中运行这段代码，记得把<code>localhost</code>改为自己宿主机的<code>ip</code>地址。</p>
]]></content>
      <categories>
        <category>Python技巧</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 配置 C++ Qt 开发环境</title>
    <url>/2024/12/11/Qt%E5%92%8CVScode%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="1-安装开发包"><a href="#1-安装开发包" class="headerlink" title="1.安装开发包"></a>1.安装开发包</h1><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S qt6-base</span><br></pre></td></tr></table></figure></div>
<p>如果要安装其它版本的，比如<code>qt5</code>，则是<code>qt5-base</code>。</p>
<p>对于<code>WSL</code>下，是只能连接到<code>x11</code>服务的，比较 Windows 也没有<code>wayland</code>会话。所以还需要安装<code>xcb</code>支持库：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S qt6-xcb-private-headers</span><br></pre></td></tr></table></figure></div>
<p>需要与安装的<code>qt</code>版本对应，因为我安装的是<code>qt6-base</code>，我这里自然安装的就是<code>qt6</code>对应的<code>xcb</code>支持库。</p>
<p>安装好后需要配置环境变量，把下面这行内容添加到<code>.bashrc</code>或者<code>.zshrc</code>中（取决于自己用的<code>shell</code>）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> QT_QPA_PLATFORM=xcb</span><br></pre></td></tr></table></figure></div>

<p>进行这步配置主要是为了避免运行<code>qt</code>程序时，出现下面的问题：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">qt.qpa.plugin: Could not find the Qt platform plugin &quot;wayland&quot; in &quot;&quot;</span><br></pre></td></tr></table></figure></div>

<p>如果是在 Linux 发行版上的话（能支持<code>wayland</code>会话的），可能会出现这样的问题：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">QApplication: invalid style override &#x27;kvantum&#x27; passed, ignoring it.</span><br><span class="line">        Available styles: Breeze, Windows, Fusion</span><br></pre></td></tr></table></figure></div>
<p>这是 Qt 程序的<code>ui</code>样式，提示<code>kvantum</code>样式不可用，可用的有<code>Breeze</code>，<code>Windows</code>，<code>Fusion</code>这三种。所以还需要设置环境变量，把下面这行内容添加到<code>.bashrc</code>或者<code>.zshrc</code>中（取决于自己用的<code>shell</code>）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> QT_STYLE_OVERRIDE=Fusion</span><br></pre></td></tr></table></figure></div>

<hr>
<h1 id="2-安装字体"><a href="#2-安装字体" class="headerlink" title="2.安装字体"></a>2.安装字体</h1><p>默认情况下，中文字体会安装在以下路径之一：</p>
<ol>
<li><code>/usr/share/fonts/noto-cjk/</code>：用于 <strong>Noto CJK</strong> 字体（推荐）。</li>
<li><code>/usr/share/fonts/wenquanyi/</code>：用于 <strong>文泉驿</strong> 字体。</li>
<li><code>/usr/share/fonts/TTF/</code> 或 <code>/usr/share/fonts/truetype/</code>：用于 TTF&#x2F;OTF 格式的字体文件。</li>
</ol>
<p>先查看下系统是否有中文字体，使用下面的指令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">fc-list :lang=zh</span><br></pre></td></tr></table></figure></div>
<p>如果有输出的话，后面操作就不用管，否则就需要额外安装字体。</p>
<p>在我的系统中（Arch-WSL2），<code>/usr/share/fonts/</code> 目录下只显示了以下内容，说明没有中文字体：</p>
<ul>
<li><p><strong>100dpi 和 75dpi</strong>：<br>这些是 X11 系统中的点阵字体（bitmap fonts），通常用于较低分辨率的显示器或作为一些旧式程序的备用字体。  </p>
<ul>
<li><code>100dpi</code> 表示每英寸 100 点的字体。</li>
<li><code>75dpi</code> 表示每英寸 75 点的字体。<br>这些字体一般用于非常老旧的 X11 应用程序，现代应用通常不需要这些字体。</li>
</ul>
</li>
<li><p><strong>encodings</strong>：<br>包含字体编码文件，用于定义如何将字符代码映射到字体中的字形。它主要与点阵字体或老式字体相关。</p>
</li>
<li><p><strong>util</strong>：<br>一些字体工具或辅助文件的目录，通常与字体管理或配置有关。</p>
</li>
</ul>
<ol>
<li>安装 Noto CJK 字体（推荐）</li>
</ol>
<p>这是 Google 提供的现代中文字体，适用于大多数应用场景：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S noto-fonts-cjk</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>安装其他中文字体</li>
</ol>
<ul>
<li><strong>文泉驿字体</strong>：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S wqy-zenhei wqy-microhei</span><br></pre></td></tr></table></figure></div></li>
<li><strong>思源宋体</strong>（Noto Serif CJK）：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S noto-fonts-emoji noto-fonts-cjk noto-fonts</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>安装一种即可，安装好后，需要重启系统（我这里只需要重启 Arch-WSL2 子系统）。</p>
<hr>
<h1 id="3-项目构建"><a href="#3-项目构建" class="headerlink" title="3.项目构建"></a>3.项目构建</h1><p>一个简单的<code>qt</code>开发模板：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSI0N 3.12)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_COMPILER clang)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_COMPILER clang++)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD 20)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_AUTOMOC ON)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_AUTORCC ON)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_AUTOUIC ON)</span><br><span class="line"></span><br><span class="line">project(qtguide)</span><br><span class="line"></span><br><span class="line">find_package(Qt6 REQUIRED COMPONENTS Core Widgets REQUIRED)</span><br><span class="line"></span><br><span class="line">file(GLOB sources *.cpp)</span><br><span class="line">add_executable(qtguide <span class="variable">$&#123;sources&#125;</span>)</span><br><span class="line">target_link_libraries(qtguide PRIVATE Qt6::Core Qt6::Widgets)</span><br></pre></td></tr></table></figure></div>
<p>建议设置<code>clang</code>和<code>clang++</code>作为编译器。我在 Arch-WSL2 下使用<code>gcc</code>和<code>g++</code>会出现问题。还有就是设置编译器这部分，一定要放在<code>cmake_minimum_required</code>下面，其它的上面。因为编译器的选择会影响后续变量、库、目标等配置。CMake 初始化后再更改编译器可能会导致配置问题。</p>
<p>对于<code>qt</code>模板，可以参考我的仓库中的模板配置：<a class="link"   href="https://github.com/loskyertt/cpp_template" >cpp_template<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>c++</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH 教程</title>
    <url>/2024/08/16/SSH%20%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-Windows-安装-SSH-工具"><a href="#1-Windows-安装-SSH-工具" class="headerlink" title="1.Windows 安装 SSH 工具"></a>1.Windows 安装 SSH 工具</h1><h2 id="1-1-方式一、使用-OpenSSH"><a href="#1-1-方式一、使用-OpenSSH" class="headerlink" title="1.1 方式一、使用 OpenSSH"></a>1.1 方式一、使用 OpenSSH</h2><p>可以直接搭配 Windows 的 PowerShell 使用，很轻量，但是功能少。配置方式可以参考我写的这篇文章：<a class="link"   href="https://loskyertt.github.io/2024/07/30/Openssh%E9%85%8D%E7%BD%AE/" >Win10 SSH 服务配置<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="1-2-方式二、使用-MobaXterm-（推荐）"><a href="#1-2-方式二、使用-MobaXterm-（推荐）" class="headerlink" title="1.2 方式二、使用  MobaXterm （推荐）"></a>1.2 方式二、使用  MobaXterm （推荐）</h2><p>本人用了下，效果还不错，就是没有中文。下载地址：<a class="link"   href="https://mobaxterm.mobatek.net/download.html" >MobaXterm<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="1-3-方式三、使用-WindTerm-（开源）"><a href="#1-3-方式三、使用-WindTerm-（开源）" class="headerlink" title="1.3 方式三、使用 WindTerm （开源）"></a>1.3 方式三、使用 WindTerm （开源）</h2><p>支持中文，在 GitHub 开源。下载地址：<a class="link"   href="https://github.com/kingToolbox/WindTerm" >WindTerm<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="1-4-方式三、其他"><a href="#1-4-方式三、其他" class="headerlink" title="1.4 方式三、其他"></a>1.4 方式三、其他</h2><p>Linux 下直接下载 OpenSSH 就行了，使用<code>zsh</code>或者<code>bash</code>终端。 </p>
<p>其他 SSH 连接工具推荐：<a class="link"   href="https://www.bilibili.com/video/BV1xJ4m1s7zX/?share_source=copy_web&vd_source=9fce48d1dc82a922216accb794549993" >视频地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="2-远程主机的配置"><a href="#2-远程主机的配置" class="headerlink" title="2.远程主机的配置"></a>2.远程主机的配置</h1><h2 id="2-1-安装-OpenSSH"><a href="#2-1-安装-OpenSSH" class="headerlink" title="2.1 安装 OpenSSH"></a>2.1 安装 OpenSSH</h2><p>Linux 一般默认安装上的，如果没有，可以手动安装，这里以 Arch 系 Linux 为例：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S openssh</span><br></pre></td></tr></table></figure></div>

<h2 id="2-2-开启-SSH-服务"><a href="#2-2-开启-SSH-服务" class="headerlink" title="2.2 开启 SSH 服务"></a>2.2 开启 SSH 服务</h2><ul>
<li><p>让 sshd 开机自启动：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> sshd</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>开启 sshd 服务：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start sshd</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>查看是否启动成功：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status sshd</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="2-3-配置防火墙（一定要配置）"><a href="#2-3-配置防火墙（一定要配置）" class="headerlink" title="2.3 配置防火墙（一定要配置）"></a>2.3 配置防火墙（一定要配置）</h2><ul>
<li><p><code>ufw</code> 防火墙：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow ssh</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>iptables</code>防火墙：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>firewalld</code>防火墙：<br>显示<code>firewalld</code>的当前防火墙配置状态：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> firewall-cmd --list-all</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>通常会显示以下信息：</p>
<ul>
<li><strong><code>interfaces</code></strong> : 显示与当前区域关联的网络接口。</li>
<li><strong><code>sources</code></strong> : 显示与当前区域关联的 IP 源地址或子网。</li>
<li><strong><code>services</code></strong> : 显示允许的服务列表（例如 <code>ssh</code>, <code>http</code>, <code>https</code> 等）。</li>
<li><strong><code>ports</code></strong> : 显示手动添加的开放端口及其协议（例如 <code>22/tcp</code>, <code>80/tcp</code> 等）。</li>
<li><strong><code>protocols</code></strong> : 显示允许的协议（通常包括 <code>ipv4</code> 和 <code>ipv6</code>）。</li>
<li><strong><code>zone</code></strong> : 当前配置的区域名称。</li>
<li><strong><code>forward</code></strong> : 显示转发规则（如果有的话）。</li>
<li><strong><code>masquerade</code></strong> : 显示是否启用网络地址转换（NAT）。</li>
</ul>
<p>确保<code>22</code>端口被开放：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> firewall-cmd --add-service=ssh --permanent</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --reload</span><br></pre></td></tr></table></figure></div>

<p>也可以检查 SSH 配置文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></div>

<h2 id="2-4-查看日志"><a href="#2-4-查看日志" class="headerlink" title="2.4 查看日志"></a>2.4 查看日志</h2><p>如果你遇到任何问题，可以查看 SSH 服务的日志以获取更多信息：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> journalctl -u sshd</span><br></pre></td></tr></table></figure></div>

<h1 id="3-常用指令"><a href="#3-常用指令" class="headerlink" title="3.常用指令"></a>3.常用指令</h1><h2 id="3-1-与远程主机进行连接"><a href="#3-1-与远程主机进行连接" class="headerlink" title="3.1 与远程主机进行连接"></a>3.1 与远程主机进行连接</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ssh &lt;用户名&gt;@&lt;远程主机 IP 地址&gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="3-2-检查与远程代码仓库的连接"><a href="#3-2-检查与远程代码仓库的连接" class="headerlink" title="3.2 检查与远程代码仓库的连接"></a>3.2 检查与远程代码仓库的连接</h2><p>这里以 GitHub 为例：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></div>

<p>显示以下内容表示连接成功：<br><code>Hi loskyertt! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p>
<h2 id="3-3-传输文件"><a href="#3-3-传输文件" class="headerlink" title="3.3 传输文件"></a>3.3 传输文件</h2><p>使用 <code>scp</code> 命令可以通过 SSH 传输文件，<code>scp</code> 是 Secure Copy Protocol 的缩写。</p>
<p><strong>示例：</strong></p>
<ol>
<li><p><strong>从本地计算机复制文件到远程计算机</strong> ：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">scp localfile.txt username@remote_host:/path/to/remote/directory/</span><br></pre></td></tr></table></figure></div>
<p>这里 <code>localfile.txt</code> 是要复制的本地文件，<code>username</code> 是远程计算机上的用户名，<code>remote_host</code> 是远程计算机的 IP 地址或主机名，<code>/path/to/remote/directory/</code> 是远程计算机上的目标目录。</p>
</li>
<li><p><strong>从远程计算机复制文件到本地计算机</strong> ：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">scp username@remote_host:/path/to/remote/file.txt /path/to/local/directory/</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>复制目录及其内容</strong> ：<br>使用 <code>-r</code> 选项可以递归地复制目录及其内容。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r local_directory username@remote_host:/path/to/remote/directory/</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h1 id="4-问题汇总"><a href="#4-问题汇总" class="headerlink" title="4.问题汇总"></a>4.问题汇总</h1><h2 id="4-1-远程主机密钥更改"><a href="#4-1-远程主机密钥更改" class="headerlink" title="4.1 远程主机密钥更改"></a>4.1 远程主机密钥更改</h2><h3 id="4-1-1-问题示例"><a href="#4-1-1-问题示例" class="headerlink" title="4.1.1 问题示例"></a>4.1.1 问题示例</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">24-08-14 16:10:00 [sky@~]</span><br><span class="line">╰─❯ssh root@124.15.31.104</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the ED25519 key sent by the remote host is</span><br><span class="line">SHA256:hQeGc/7954FRAh/w8RFXKUNFz6xxH9DnYRdygBIfWiw.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /home/sky/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending ECDSA key in /home/sky/.ssh/known_hosts:6</span><br><span class="line">Host key for 124.15.31.104 has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure></div>

<p>出现这种警告表明你尝试连接的远程主机的 SSH 密钥已经发生了变化。这种情况可能有几种原因：</p>
<ol>
<li><p><strong>主机密钥确实更改了</strong>：远程服务器可能因为重新安装了操作系统、重新生成了密钥对或者更改了 SSH 配置而更换了主机密钥。</p>
</li>
<li><p><strong>可能的安全风险</strong>：如果你没有预期到主机密钥的变化，可能有人试图进行中间人攻击（Man-in-the-Middle Attack），这意味着有人可能在试图窃听你的连接。</p>
</li>
</ol>
<h3 id="4-1-2-解决步骤"><a href="#4-1-2-解决步骤" class="headerlink" title="4.1.2 解决步骤"></a>4.1.2 解决步骤</h3><ol>
<li>确认更改的原因</li>
</ol>
<p>如果你对主机密钥更改有充分的理由（例如，你知道服务器进行了重新安装或者密钥更新），你可以安全地更新你的本地 <code>known_hosts</code> 文件。</p>
<ol start="2">
<li>删除旧的密钥</li>
</ol>
<p>你可以手动编辑 <code>~/.ssh/known_hosts</code> 文件，删除对应的旧密钥。</p>
<p>打开 <code>known_hosts</code> 文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nano ~/.ssh/known_hosts</span><br></pre></td></tr></table></figure></div>

<p>查找并删除第6行（或者显示的“Offending ECDSA key”所在的行），这行对应于你连接的服务器的旧密钥。</p>
<p>保存文件并退出编辑器。</p>
<p>如果你更喜欢使用命令行工具，你可以使用以下命令删除该行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;6d&#x27;</span> ~/.ssh/known_hosts</span><br></pre></td></tr></table></figure></div>

<p>注意：此命令会删除 <code>known_hosts</code> 文件中的第6行。</p>
<ol start="3">
<li>再次连接服务器</li>
</ol>
<p>删除旧密钥后，重新尝试连接服务器：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@124.15.31.104</span><br></pre></td></tr></table></figure></div>

<p>你将会看到提示要求确认新的主机密钥。确保你确认这个新的密钥是合法的。如果确定是合法的，可以输入 <code>yes</code> 来接受新的密钥并将其添加到 <code>known_hosts</code> 文件中。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Ubuntu 下中文乱码问题</title>
    <url>/2024/11/30/Ubuntu%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h1 id="1-安装中文字体包"><a href="#1-安装中文字体包" class="headerlink" title="1.安装中文字体包"></a>1.安装中文字体包</h1><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install language-pack-zh-hans</span><br></pre></td></tr></table></figure></div>

<h1 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.修改配置文件</h1><p>注：下列操作在<code>docker</code>的<code>ubuntu</code>容器中不需要加<code>sudo</code>，默认就是<code>root</code>权限。</p>
<h2 id="2-1-方式一：修改-bashrc文件（推荐）"><a href="#2-1-方式一：修改-bashrc文件（推荐）" class="headerlink" title="2.1 方式一：修改~/.bashrc文件（推荐）"></a>2.1 方式一：修改<code>~/.bashrc</code>文件（推荐）</h2><p>修改<code>~/.bashrc</code>文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nano ~/.bashrc</span><br></pre></td></tr></table></figure></div>

<p>添加：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">export LANG=zh_CN.UTF-8</span><br><span class="line">export LANGUAGE=zh_CN:zh</span><br><span class="line">export LC_ALL=zh_CN.UTF-8</span><br></pre></td></tr></table></figure></div>

<p>然后执行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></div>

<h2 id="2-2-方式二：修改-etc-profile文件"><a href="#2-2-方式二：修改-etc-profile文件" class="headerlink" title="2.2 方式二：修改/etc/profile文件"></a>2.2 方式二：修改<code>/etc/profile</code>文件</h2><p>修改<code>/etc/profile</code>配置文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/profile</span><br></pre></td></tr></table></figure></div>

<p>添加：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">export LANG=zh_CN.UTF-8</span><br><span class="line">export LANGUAGE=zh_CN:zh</span><br><span class="line">export LC_ALL=zh_CN.UTF-8</span><br></pre></td></tr></table></figure></div>

<p>然后执行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></div>
<p>可能每次重启系统后，都得执行这条命令。</p>
<h2 id="2-3-方式三：修改-etc-environment文件"><a href="#2-3-方式三：修改-etc-environment文件" class="headerlink" title="2.3 方式三：修改/etc/environment文件"></a>2.3 方式三：修改<code>/etc/environment</code>文件</h2><p>注：该方式不一定成功。</p>
<p>修改<code>/etc/environment</code>配置文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/environment</span><br></pre></td></tr></table></figure></div>

<p>加入下面的内容：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">LANG=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LANGUAGE=&quot;zh_CN:zh&quot;</span><br><span class="line">LC_ALL=&quot;zh_CN.UTF-8&quot;</span><br></pre></td></tr></table></figure></div>

<h1 id="3-添加中文配置内容（选做）"><a href="#3-添加中文配置内容（选做）" class="headerlink" title="3.添加中文配置内容（选做）"></a>3.添加中文配置内容（选做）</h1><p>再修改<code>/var/lib/locales/supported.d/local</code>文件（如果没有，就手动创建）</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /var/lib/locales/supported.d/local</span><br></pre></td></tr></table></figure></div>

<p>加入下面内容：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">en_US.UTF-8 UTF-8</span><br><span class="line">zh_CN.UTF-8 UTF-8</span><br><span class="line">zh_CN.GBK GBK</span><br><span class="line">zh_CN GB2312</span><br></pre></td></tr></table></figure></div>

<p>最后执行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> locale-gen</span><br></pre></td></tr></table></figure></div>

<p>然后重启系统即可。</p>
<h1 id="3-中文空格乱码解决"><a href="#3-中文空格乱码解决" class="headerlink" title="3.中文空格乱码解决"></a>3.中文空格乱码解决</h1><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install fonts-droid-fallback ttf-wqy-zenhei ttf-wqy-microhei fonts-arphic-ukai fonts-arphic-uming</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Ubuntu 系统下，软件包更新和软件下载速度慢的问题</title>
    <url>/2024/12/07/Ubuntu%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    <content><![CDATA[<h1 id="1-问题复现"><a href="#1-问题复现" class="headerlink" title="1.问题复现"></a>1.问题复现</h1><p>在安装后 Debian 系统后，一般第一步都是执行<code>sudo apt update</code>，此时用的是自带的官方镜像源，速度很慢，所以我们会选择切换为国内的镜像源，这里以清华镜像源为例，默认已经配置好了清华镜像源。</p>
<p>在执行更新时：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">root@5395055d0589:/# apt update</span><br><span class="line">Ign:1 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble InRelease</span><br><span class="line">Ign:2 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-updates InRelease                                </span><br><span class="line">Ign:3 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-backports InRelease                              </span><br><span class="line">Get:4 http://security.ubuntu.com/ubuntu noble-security InRelease [126 kB]                                </span><br><span class="line">Get:5 http://archive.ubuntu.com/ubuntu noble InRelease [256 kB]                                          </span><br><span class="line">Ign:1 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble InRelease </span><br><span class="line">Ign:2 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-updates InRelease</span><br><span class="line">Ign:3 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-backports InRelease</span><br><span class="line">Get:6 http://security.ubuntu.com/ubuntu noble-security/multiverse amd64 Packages [15.3 kB]</span><br><span class="line">Get:7 http://security.ubuntu.com/ubuntu noble-security/universe amd64 Packages [726 kB]</span><br><span class="line">Get:8 http://security.ubuntu.com/ubuntu noble-security/main amd64 Packages [627 kB]</span><br><span class="line">Get:9 http://security.ubuntu.com/ubuntu noble-security/restricted amd64 Packages [607 kB]</span><br><span class="line">Ign:1 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble InRelease                       </span><br><span class="line">Ign:2 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-updates InRelease</span><br><span class="line">Ign:3 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-backports InRelease</span><br><span class="line">Get:10 http://archive.ubuntu.com/ubuntu noble-updates InRelease [126 kB]                                                                                                                          </span><br><span class="line">Err:1 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble InRelease                                                                                                                                 </span><br><span class="line">  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 101.6.15.130 443]</span><br><span class="line">Err:2 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-updates InRelease                                                                                                                         </span><br><span class="line">  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 101.6.15.130 443]</span><br><span class="line">Err:3 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-backports InRelease                                                                                                                       </span><br><span class="line">  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 101.6.15.130 443]</span><br><span class="line">Get:11 http://archive.ubuntu.com/ubuntu noble-backports InRelease [126 kB]                                                                                                                        </span><br><span class="line">Get:12 http://archive.ubuntu.com/ubuntu noble/main amd64 Packages [1808 kB]                                                                                                                       </span><br><span class="line">Get:13 http://archive.ubuntu.com/ubuntu noble/restricted amd64 Packages [117 kB]                                                                                                                  </span><br><span class="line">Get:14 http://archive.ubuntu.com/ubuntu noble/universe amd64 Packages [19.3 MB]                                                                                                                   </span><br><span class="line">38% [14 Packages 3024 kB/19.3 MB 16%]                                                                                                                                           75.6 kB/s 4min 12s^C</span><br></pre></td></tr></table></figure></div>

<h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h1><p>可以看到，当清华镜像源证书验证失败时，会尝试从<code>/etc/apt/sources.list.d/ubuntu.sources</code>这里的官方镜像源下载更新，但是下载速度特别慢，所以我通常会禁用这个。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> /etc/apt/sources.list.d/ubuntu.sources /etc/apt/sources.list.d/ubuntu.sources.bak</span><br></pre></td></tr></table></figure></div>

<p>然后更新的时候临时禁用证书验证：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get -o Acquire::https::Verify-Peer=<span class="literal">false</span> -o Acquire::https::Verify-Host=<span class="literal">false</span> update</span><br></pre></td></tr></table></figure></div>

<p>更新完毕后，可能在安装<code>ca-certificates</code>还会出现这样的问题：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">root@5395055d0589:/# apt install ca-certificates</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree... Done</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following additional packages will be installed:</span><br><span class="line">  openssl</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  ca-certificates openssl</span><br><span class="line">0 upgraded, 2 newly installed, 0 to remove and 0 not upgraded.</span><br><span class="line">Need to get 1162 kB of archives.</span><br><span class="line">After this operation, 2326 kB of additional disk space will be used.</span><br><span class="line">Do you want to <span class="built_in">continue</span>? [Y/n] y</span><br><span class="line">Ign:1 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-updates/main amd64 openssl amd64 3.0.13-0ubuntu3.4</span><br><span class="line">Ign:2 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble/main amd64 ca-certificates all 20240203</span><br><span class="line">Ign:1 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-updates/main amd64 openssl amd64 3.0.13-0ubuntu3.4</span><br><span class="line">Ign:2 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble/main amd64 ca-certificates all 20240203</span><br><span class="line">Ign:1 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-updates/main amd64 openssl amd64 3.0.13-0ubuntu3.4</span><br><span class="line">Ign:2 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble/main amd64 ca-certificates all 20240203</span><br><span class="line">Err:1 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-updates/main amd64 openssl amd64 3.0.13-0ubuntu3.4</span><br><span class="line">  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 101.6.15.130 443]</span><br><span class="line">Err:2 https://mirrors.tuna.tsinghua.edu.cn/ubuntu noble/main amd64 ca-certificates all 20240203</span><br><span class="line">  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 101.6.15.130 443]</span><br><span class="line">W: https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/o/openssl/openssl_3.0.13-0ubuntu3.4_amd64.deb: No system certificates available. Try installing ca-certificates.</span><br><span class="line">W: https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/c/ca-certificates/ca-certificates_20240203_all.deb: No system certificates available. Try installing ca-certificates.</span><br><span class="line">W: https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/o/openssl/openssl_3.0.13-0ubuntu3.4_amd64.deb: No system certificates available. Try installing ca-certificates.</span><br><span class="line">W: https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/c/ca-certificates/ca-certificates_20240203_all.deb: No system certificates available. Try installing ca-certificates.</span><br><span class="line">W: https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/o/openssl/openssl_3.0.13-0ubuntu3.4_amd64.deb: No system certificates available. Try installing ca-certificates.</span><br><span class="line">W: https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/c/ca-certificates/ca-certificates_20240203_all.deb: No system certificates available. Try installing ca-certificates.</span><br><span class="line">W: https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/o/openssl/openssl_3.0.13-0ubuntu3.4_amd64.deb: No system certificates available. Try installing ca-certificates.</span><br><span class="line">W: https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/c/ca-certificates/ca-certificates_20240203_all.deb: No system certificates available. Try installing ca-certificates.</span><br><span class="line">E: Failed to fetch https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/o/openssl/openssl_3.0.13-0ubuntu3.4_amd64.deb  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 101.6.15.130 443]</span><br><span class="line">E: Failed to fetch https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/c/ca-certificates/ca-certificates_20240203_all.deb  Certificate verification failed: The certificate is NOT trusted. The certificate issuer is unknown.  Could not handshake: Error <span class="keyword">in</span> the certificate verification. [IP: 101.6.15.130 443]</span><br><span class="line">E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?</span><br></pre></td></tr></table></figure></div>
<p>从错误信息来看，<code>apt</code>在尝试从清华镜像站下载<code>ca-certificates</code>和<code>openssl</code>时仍然遇到了证书验证失败的问题。这可能是由于现有的<code>ca-certificates</code>软件包本身损坏或缺失导致的。</p>
<p>因此可以在下载时临时禁用证书验证：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get -o Acquire::https::Verify-Peer=<span class="literal">false</span> -o Acquire::https::Verify-Host=<span class="literal">false</span> install ca-certificates openssl</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox 实现主机与虚拟机（CachyOS）传文件</title>
    <url>/2024/08/01/VirtualBox%E4%B8%BB%E6%9C%BA%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%97%B4%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="1-VirtualBox-中实现主机与虚拟机之间传输文件"><a href="#1-VirtualBox-中实现主机与虚拟机之间传输文件" class="headerlink" title="1.VirtualBox 中实现主机与虚拟机之间传输文件"></a>1.VirtualBox 中实现主机与虚拟机之间传输文件</h1><h2 id="1-1-VirtualBox-中的设置"><a href="#1-1-VirtualBox-中的设置" class="headerlink" title="1.1 VirtualBox 中的设置"></a>1.1 VirtualBox 中的设置</h2><p>如图所示：</p>
<ul>
<li><p>进入虚拟机的设置：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://im.gurl.eu.org/file/b852b7e357c0db8eb549d.png"
                      alt="图一"
                ><figcaption>图一</figcaption></figure></p>
</li>
<li><p>创建主机挂载目录：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://im.gurl.eu.org/file/a6030bd1051ef5e2c8ced.png"
                      alt="图二"
                ><figcaption>图二</figcaption></figure></p>
</li>
</ul>
<h2 id="1-2-虚拟机中的设置"><a href="#1-2-虚拟机中的设置" class="headerlink" title="1.2 虚拟机中的设置"></a>1.2 虚拟机中的设置</h2><p>在虚拟机中创建共享目录：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/share -p</span><br></pre></td></tr></table></figure></div>

<p>将主机的那个共享目录挂载到<code>~/share</code>文件夹下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mount -t vboxsf CachyOS_share ~/share/</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2 和 Docker 容器中运行 GUI 程序</title>
    <url>/2024/11/27/WSL-%E5%AE%B9%E5%99%A8GUI/</url>
    <content><![CDATA[<h1 id="1-WSL2-执行-GUI-程序（X11）"><a href="#1-WSL2-执行-GUI-程序（X11）" class="headerlink" title="1.WSL2 执行 GUI 程序（X11）"></a>1.WSL2 执行 GUI 程序（X11）</h1><p>需要在 Windows 上安装<code>MobaXterm</code>，这里推荐安装中文版的（原版可以在官网下载）：<a class="link"   href="https://github.com/RipplePiam/MobaXterm-Chinese-Simplified?tab=readme-ov-file" >中文版 Mobaxterm<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。这个软件自带<code>x11-server</code>。</p>
<p>然后只需要在 WSL2 （Linux 子系统发行版）中安装<code>x11-apps</code>即可。</p>
<p>对于<code>Ubuntu</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install x11-apps -y</span><br></pre></td></tr></table></figure></div>
<p>执行这条命令就能安装好配套的<code>x11 apps</code>，比如<code>xclock</code>和<code>xeyes</code>。</p>
<p>对于<code>Arch</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S xorg</span><br></pre></td></tr></table></figure></div>
<p>这条命令只是安装对于的<code>x11-server</code>，然后执行下面的命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S xclock xeyes</span><br></pre></td></tr></table></figure></div>

<p>这样直接在终端、<code>VSCode WSL2</code>中的终端或者<code>MobaXterm</code>中运行<code>xclock</code>或者<code>xeyes</code>就能显示 GUI 程序了。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">xclock</span><br></pre></td></tr></table></figure></div>

<p>如下图所示：<br><a href="https://imgse.com/i/pA4NSkn"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/11/27/pA4NSkn.png"
                      alt="示例.png"
                ><figcaption>示例.png</figcaption></figure></a></p>
<p>这样也能在 WSL2 中进行可是开发，比如用<code>Python</code>的<code>matplotlib</code>绘图等。</p>
<p>如果运行不成功的话，可以执行下面的命令试试：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">DISPALY=&lt;你的宿主机的IP&gt;:0 xclock</span><br></pre></td></tr></table></figure></div>
<p>比如：<code>DISPALY=172.27.158.40:0 xclock</code>。</p>
<hr>
<h1 id="2-Docker-容器中执行-GUI-程序（X11）"><a href="#2-Docker-容器中执行-GUI-程序（X11）" class="headerlink" title="2.Docker 容器中执行 GUI 程序（X11）"></a>2.Docker 容器中执行 GUI 程序（X11）</h1><p>整体操作方式跟在 WSL2 中是一样的，这里以 Docker 的<code>ubuntu</code>镜像为例子。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name=test-gui --<span class="built_in">env</span> HTTP_PROXY=http:172.27.158.40:7890 --<span class="built_in">env</span> HTTPS_PROXY=http:172.27.158.40:7890 ubuntu:latest</span><br></pre></td></tr></table></figure></div>
<p>这里的<code>--env HTTP_PROXY=http:172.27.158.40:7890 --env HTTPS_PROXY=http:172.27.158.40:7890</code>是我配置的代理服务，<code>172.27.158.40</code>是宿主机的<code>IP</code>地址。是为了方便执行容器中一系列<code>apt</code>的命令。当然，也可以配置镜像源。</p>
<p>如果要配置镜像源，记得安装<code>CA</code>证书：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install ca-certificates</span><br></pre></td></tr></table></figure></div>

<p>进入容器后，先进行更新，执行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure></div>

<p>然后下载：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install x11-apps</span><br></pre></td></tr></table></figure></div>

<p>这里要运行 GUI 程序，只能在<code>MobaXterm</code>和<code>VSCode</code>中运行。</p>
<h2 id="2-1-在MobaXterm中运行"><a href="#2-1-在MobaXterm中运行" class="headerlink" title="2.1 在MobaXterm中运行"></a>2.1 在<code>MobaXterm</code>中运行</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">DISPALY=&lt;你的宿主机的IP&gt;:0 xclock</span><br></pre></td></tr></table></figure></div>

<p>如下图所示：<br><a href="https://imgse.com/i/pA4NEm4"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/11/27/pA4NEm4.png"
                      alt="MobaXterm中运行.png"
                ><figcaption>MobaXterm中运行.png</figcaption></figure></a></p>
<p>如果觉得麻烦，可以把<code>DISPALY=&lt;你的宿主机的IP&gt;</code>导入到环境变量中。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPALY=&lt;你的宿主机的IP&gt;</span><br></pre></td></tr></table></figure></div>

<p>如下图所示：<br><a href="https://imgse.com/i/pA4NMp6"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/11/27/pA4NMp6.png"
                      alt="MobaXterm中运行.png"
                ><figcaption>MobaXterm中运行.png</figcaption></figure></a></p>
<h2 id="2-2-在-VSCode-中运行"><a href="#2-2-在-VSCode-中运行" class="headerlink" title="2.2 在 VSCode 中运行"></a>2.2 在 VSCode 中运行</h2><p>需要通过<code>Dev Containers</code>扩展，进入到容器内部，然后直接执行命令即可：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">xclock</span><br></pre></td></tr></table></figure></div>

<p>如下图所示：<br><a href="https://imgse.com/i/pA4NtAA"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/11/27/pA4NtAA.png"
                      alt="VSCode中运行.png"
                ><figcaption>VSCode中运行.png</figcaption></figure></a></p>
<p>注意：如果是在 Linux 系统下，在 VSCode 中运行可能会出现这样的错误：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">root@710c5762df8e:~# xclock</span><br><span class="line">Authorization required, but no authorization protocol specified</span><br><span class="line">Error: Can&#x27;t open display: :0</span><br></pre></td></tr></table></figure></div>
<p>意味着当前用户或容器中的环境没有被授权访问<code>X11</code>显示服务器（<code>DISPLAY=:0</code>）。这是一个典型的<code>X11</code>权限问题。</p>
<p>只需要在宿主机上运行以下命令，允许容器的用户访问显示服务：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">xhost +<span class="built_in">local</span>:docker</span><br></pre></td></tr></table></figure></div>
<p>这样再运行<code>xclock</code>就能成功了。</p>
<p>如果希望更安全，只允许特定用户访问，可以指定用户（比如这里指定<code>root</code>用户）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">xhost +SI:localuser:root</span><br></pre></td></tr></table></figure></div>

<hr>
<h1 id="3-Docker-容器中执行-GUI-程序（Wayland）"><a href="#3-Docker-容器中执行-GUI-程序（Wayland）" class="headerlink" title="3.Docker 容器中执行 GUI 程序（Wayland）"></a>3.Docker 容器中执行 GUI 程序（Wayland）</h1><p>运行容器时，挂载 Wayland 必需的 Socket 和环境变量：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name=test-wayland -e WAYLAND_DISPLAY=<span class="variable">$WAYLAND_DISPLAY</span> -e XDG_RUNTIME_DIR=<span class="variable">$XDG_RUNTIME_DIR</span> -v <span class="variable">$XDG_RUNTIME_DIR</span>/<span class="variable">$WAYLAND_DISPLAY</span>:<span class="variable">$XDG_RUNTIME_DIR</span>/<span class="variable">$WAYLAND_DISPLAY</span> --device=/dev/dri ubuntu:latest</span><br></pre></td></tr></table></figure></div>

<p>解释：</p>
<ul>
<li><code>-e WAYLAND_DISPLAY=$WAYLAND_DISPLAY</code>：传递 Wayland 显示环境变量（通常为 <code>wayland-0</code>）。</li>
<li><code>-e XDG_RUNTIME_DIR=$XDG_RUNTIME_DIR</code>：传递 Wayland 的运行时目录。</li>
<li><code>-v $XDG_RUNTIME_DIR/$WAYLAND_DISPLAY:$XDG_RUNTIME_DIR/$WAYLAND_DISPLAY</code>：挂载 Wayland Socket 文件。</li>
<li><code>--device=/dev/dri</code>：允许容器访问 GPU。</li>
</ul>
<hr>
<h2 id="3-1-在容器中验证-Wayland-配置"><a href="#3-1-在容器中验证-Wayland-配置" class="headerlink" title="3.1 在容器中验证 Wayland 配置"></a>3.1 在容器中验证 Wayland 配置</h2><p>进入容器后，验证环境是否正确：</p>
<ol>
<li><p>检查 <code>WAYLAND_DISPLAY</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$WAYLAND_DISPLAY</span></span><br></pre></td></tr></table></figure></div>
<p>应返回 <code>wayland-0</code> 或类似内容。</p>
</li>
<li><p>检查 <code>XDG_RUNTIME_DIR</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$XDG_RUNTIME_DIR</span></span><br><span class="line"><span class="built_in">ls</span> <span class="variable">$XDG_RUNTIME_DIR</span></span><br></pre></td></tr></table></figure></div>
<p>应包含 <code>wayland-0</code>。</p>
</li>
</ol>
<hr>
<h2 id="3-2-运行-Weston-terminal（测试）"><a href="#3-2-运行-Weston-terminal（测试）" class="headerlink" title="3.2 运行 Weston-terminal（测试）"></a>3.2 运行 Weston-terminal（测试）</h2><ol>
<li><p>安装 Weston 系列程序：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt install -y weston</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>运行 Weston-terminal 测试：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">weston-terminal</span><br></pre></td></tr></table></figure></div>
<p>如果配置正确，应该会打开一个终端窗口。如下图所示：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/12/08/2vfPZbtHQkBIsdV.png"
                      alt="Snipaste_2024-12-08_13-17-50.png"
                ><figcaption>Snipaste_2024-12-08_13-17-50.png</figcaption></figure></p>
</li>
</ol>
<hr>
<h2 id="3-3-补充：切换-Wayland-X11-环境"><a href="#3-3-补充：切换-Wayland-X11-环境" class="headerlink" title="3.3 补充：切换 Wayland&#x2F;X11 环境"></a>3.3 补充：切换 Wayland&#x2F;X11 环境</h2><ul>
<li>如果你希望 <code>gedit</code> 和其他应用也通过 Wayland 运行，可以启动它们时强制启用 Wayland：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">WAYLAND_DISPLAY=wayland-0 gedit</span><br></pre></td></tr></table></figure></div></li>
<li>如果继续使用 X11，则无需修改。</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2 的使用教程</title>
    <url>/2024/11/12/WSL2%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-安装和升级-WSL2"><a href="#1-安装和升级-WSL2" class="headerlink" title="1.安装和升级 WSL2"></a>1.安装和升级 WSL2</h1><h2 id="1-1-安装前的准备"><a href="#1-1-安装前的准备" class="headerlink" title="1.1 安装前的准备"></a>1.1 安装前的准备</h2><p>首先需要在<code>控制面板 -&gt; 程序 -&gt; 启用或关闭Windows功能</code>处开启<code>Hyper-V</code>和<code>适用于Windows的Linux子系统</code>，然后重启电脑即可。默认有2个版本，1和2，1是使用和主机相同的 IP 地址；2是更加独立的 Linux 子系统，有单独的 IP 地址，通过 Windows 主机访问互联网，建议安装2，可以用<code>systemd</code>。如果安装2还需要安装一个软件：<a class="link"   href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi" >wsl_update_x64<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>,该软件来自于<a class="link"   href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package" >Windows 官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h2 id="1-2-升级-WSL2"><a href="#1-2-升级-WSL2" class="headerlink" title="1.2 升级 WSL2"></a>1.2 升级 WSL2</h2><p>设置默认版本：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure></div>

<p>更新版本：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --update</span><br></pre></td></tr></table></figure></div>
<p>这种方式大概率会卡住，建议离线下载安装：<a class="link"   href="https://github.com/microsoft/WSL" >microsoft&#x2F;WSL<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，下载好后直接双击安装即可。</p>
<p>验证是否安装成功：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --version</span><br></pre></td></tr></table></figure></div>
<p>输入这行指令有这样的输出，表示安装成功：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">WSL 版本： 2.3.24.0</span><br><span class="line">内核版本： 5.15.153.1-2</span><br><span class="line">WSLg 版本： 1.0.65</span><br><span class="line">MSRDC 版本： 1.2.5620</span><br><span class="line">Direct3D 版本： 1.611.1-81528511</span><br><span class="line">DXCore 版本： 10.0.26100.1-240331-1435.ge-release</span><br><span class="line">Windows 版本： 10.0.19045.2673</span><br></pre></td></tr></table></figure></div>


<h1 id="2-WSL-的指令"><a href="#2-WSL-的指令" class="headerlink" title="2.WSL 的指令"></a>2.WSL 的指令</h1><h1 id="2-1-常用指令"><a href="#2-1-常用指令" class="headerlink" title="2.1 常用指令"></a>2.1 常用指令</h1><ul>
<li><p>搜索可安装版本</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --list --online</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>安装指定的版本</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --install -d Ubuntu</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>查看安装的版本信息</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>关闭 wsl</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="2-2-备份与还原"><a href="#2-2-备份与还原" class="headerlink" title="2.2 备份与还原"></a>2.2 备份与还原</h2><p>下面的一系列操作以发行版<code>Ubuntu-22.04</code>为例。</p>
<ul>
<li><p>停止指定的 WSL</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>导出（备份）WSL 子系统（需要先停止 WSL 子系统）</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">export</span> Ubuntu-22.04 D:\Ubuntu-22.04.tar</span><br></pre></td></tr></table></figure></div>
<p><code>D:\Ubuntu-22.04.tar</code>是导出的路径。</p>
</li>
<li><p>卸载 WSL 子系统</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --unregister Ubuntu-22.04</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>导入（还原）WSL 子系统</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --import Ubuntu-22.04 D:\WSL D:\Ubuntu-22.04.tar</span><br></pre></td></tr></table></figure></div>
<p><code>D:\WSL</code>是导入路径，<code>D:\Ubuntu-22.04.tar</code>是前面备份子系统的路径。</p>
</li>
</ul>
<p>还原后的子系统一般默认是<code>root</code>用户，需要修改为其它用户。只要修改还原后的 Linux 子系统中的<code>/etc/wsl.conf</code>配置文件即可，如下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/wsl.conf</span><br></pre></td></tr></table></figure></div>
<p>加入下面的内容：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">default=用户名</span><br></pre></td></tr></table></figure></div>
<p>然后按前面的方法进行重启 WSL 子系统即可。</p>
<h1 id="3-WSL-的配置"><a href="#3-WSL-的配置" class="headerlink" title="3.WSL 的配置"></a>3.WSL 的配置</h1><h2 id="3-1-启用-systemd"><a href="#3-1-启用-systemd" class="headerlink" title="3.1 启用 systemd"></a>3.1 启用 systemd</h2><p>编辑<code>/etc/wsl.conf</code>配置文件。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/wsl.conf</span><br></pre></td></tr></table></figure></div>

<p>在文件中添加下面的内容：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">[boot]</span><br><span class="line">systemd=true</span><br></pre></td></tr></table></figure></div>

<h2 id="3-2-更换内核"><a href="#3-2-更换内核" class="headerlink" title="3.2 更换内核"></a>3.2 更换内核</h2><p>在 Windows 下的资源管理器中的地址栏输入<code>%UserProfile%</code>，然后按回车。在里面新建一个<code>.wslconfig</code>文件（如果没有的话）。在文件中天下下面的内容：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">kernel=e:\\wsl2linuxkernel\\bzImage</span><br></pre></td></tr></table></figure></div>
<p>这里的<code>e:\\wsl2linuxkernel\\bzImage</code>是内核路径，可以自己编译内核，手动编译内核参考官方仓库：<a class="link"   href="https://github.com/microsoft/WSL2-Linux-Kernel" >microsoft&#x2F;WSL2-Linux-Kernel<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。也可以用仓库里线现成的：<a class="link"   href="https://github.com/Nevuly/WSL2-Linux-Kernel-Rolling" >Nevuly&#x2F;WSL2-Linux-Kernel-Rolling<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h1 id="4-释放-WSL-占用的磁盘空间"><a href="#4-释放-WSL-占用的磁盘空间" class="headerlink" title="4.释放 WSL 占用的磁盘空间"></a>4.释放 WSL 占用的磁盘空间</h1><p>有时后会发现，你在 WSL 中删掉了一些文件，但是磁盘剩余空间并没有增加。这是因为 WSL 的磁盘是动态扩容的，但不会自动释放。</p>
<h2 id="4-1-操作步骤"><a href="#4-1-操作步骤" class="headerlink" title="4.1 操作步骤"></a>4.1 操作步骤</h2><ol>
<li><p>关闭 WSL 中的 Linux 发行版：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在<code>powershell</code>或者<code>cmd</code>中运行管理计算机的驱动器的 DiskPart 命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">diskpart</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>选择虚拟磁盘文件（根据自己实际情况填写路径）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> vdisk file=<span class="string">&quot;D:\WSL\Ubuntu24.04\ext4.vhdx&quot;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>只读，附加<code>vhdx</code>磁盘镜像文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">attach vdisk <span class="built_in">readonly</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>压缩 vhdx 磁盘镜像文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">compact vdisk</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>分离<code>vhdx</code>磁盘镜像文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">detach vdisk</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>退出</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></div>
<p>或者按住<code>ctrl+c</code>。</p>
</li>
</ol>
<h2 id="4-2-可能出现的问题"><a href="#4-2-可能出现的问题" class="headerlink" title="4.2 可能出现的问题"></a>4.2 可能出现的问题</h2><div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">DISKPART&gt; <span class="built_in">select</span> vdisk file=<span class="string">&quot;D:\WSL\Arch\ext4.vhdx&quot;</span></span><br><span class="line"></span><br><span class="line">DiskPart 已成功选择虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">DISKPART&gt; compact vdisk</span><br><span class="line"></span><br><span class="line">DiskPart 遇到错误: 由于虚拟磁盘系统限制，无法完成请求的操作。虚拟硬盘文件必须是未压缩和未加密的文件，并且不能是稀疏文件 。</span><br><span class="line">有关详细信息，请参阅系统事件日志。</span><br></pre></td></tr></table></figure></div>
<p>这说明<code>ext4.vhdx</code>文件可能是 压缩的(<code>compressed</code>)、加密的(<code>encrypted</code>)或稀疏的(<code>sparse</code>)，而<code>diskpart</code>要求它是一个普通的未压缩、未加密的 VHDX 文件。因此，<code>compact vdisk</code>失败了。</p>
<p>所以需要 <strong>移除压缩、加密和稀疏文件属性</strong> ，然后再尝试<code>compact vdisk</code>。</p>
<h2 id="4-3-解决方法"><a href="#4-3-解决方法" class="headerlink" title="4.3 解决方法"></a>4.3 解决方法</h2><ol>
<li><strong>检查 VHDX 文件属性</strong><br>执行以下命令来检查 <code>ext4.vhdx</code> 是否是 <strong>稀疏文件、压缩文件或加密文件</strong> ：</li>
</ol>
<p>检查文件是否被稀疏文件：</p>
<div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">fsutil sparse queryflag <span class="string">&quot;D:\WSL\Arch\ext4.vhdx&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>如果输出：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件 D:\WSL\Arch\ext4.vhdx 是稀疏文件</span><br></pre></td></tr></table></figure></div>
<p>那么该文件是稀疏文件，需要去掉稀疏标志。</p>
<p>检查文件是否被 NTFS 压缩：</p>
<div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">compact /q <span class="string">&quot;D:\WSL\Arch\ext4.vhdx&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>如果输出类似：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 个文件总计 10 GB</span><br><span class="line">8 GB 已压缩</span><br></pre></td></tr></table></figure></div>
<p>说明该文件已被压缩，需要取消压缩。</p>
<p>检查文件是否被加密：</p>
<div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">cipher /c <span class="string">&quot;D:\WSL\Arch\ext4.vhdx&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>如果输出类似：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">E  D:\WSL\Arch\ext4.vhdx</span><br></pre></td></tr></table></figure></div>
<p>说明该文件被加密，需要解密。</p>
<ol start="2">
<li><strong>解除压缩、加密和稀疏属性</strong><br>执行以下命令，确保 VHDX 文件是普通文件：</li>
</ol>
<p>取消稀疏文件标志：</p>
<div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">fsutil sparse setflag <span class="string">&quot;D:\WSL\Arch\ext4.vhdx&quot;</span> <span class="number">0</span>  </span><br></pre></td></tr></table></figure></div>

<p>取消 NTFS 压缩：</p>
<div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">compact /u /q <span class="string">&quot;D:\WSL\Arch\ext4.vhdx&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>取消加密：</p>
<div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">cipher /d <span class="string">&quot;D:\WSL\Arch\ext4.vhdx&quot;</span></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>再次尝试挂载并压缩 VHDX</strong><br>执行：<div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">diskpart</span><br><span class="line"><span class="built_in">select</span> vdisk file=<span class="string">&quot;D:\WSL\Arch\ext4.vhdx&quot;</span></span><br><span class="line">attach vdisk</span><br><span class="line">compact vdisk</span><br><span class="line">detach vdisk</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h1 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5.参考链接"></a>5.参考链接</h1><ul>
<li><a class="link"   href="https://xujinzh.github.io/2023/08/04/windows-wsl-install/index.html" >Windows 安装 Linux 子系统 wsl<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/Chary/p/18011740" >wsl2子系统的备份和还原<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://blog.azurezeng.com/wsl2-arch-docker-configuration/" >WSL2 Arch+Docker个人配置过程和踩坑记录，以及一些建议<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://nxdong.com/wsl-update-kernel/" >wsl2编译升级linux内核<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/qq_23865133/article/details/141642123" >在WSL2中删除文件后，磁盘空间未释放怎么办<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Zerotier 使用教程</title>
    <url>/2024/08/18/Zerotier%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-登录或注册-Zerotier-官网帐号"><a href="#1-登录或注册-Zerotier-官网帐号" class="headerlink" title="1.登录或注册 Zerotier 官网帐号"></a>1.登录或注册 Zerotier 官网帐号</h1><p><a class="link"   href="https://www.zerotier.com/" >官网地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="1-1-创建组网"><a href="#1-1-创建组网" class="headerlink" title="1.1 创建组网"></a>1.1 创建组网</h2><p>点击<code>Create A NetWork</code></p>
<p><a href="https://imgse.com/i/pACzRbV"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/08/18/pACzRbV.md.png"
                      alt="创建网络"
                ><figcaption>创建网络</figcaption></figure></a></p>
<p>蓝色框里的是我已经创建好了的。创建好后可以点击进入并管理。</p>
<h1 id="2-安装-Zerotier"><a href="#2-安装-Zerotier" class="headerlink" title="2.安装 Zerotier"></a>2.安装 Zerotier</h1><h2 id="2-1-常规安装"><a href="#2-1-常规安装" class="headerlink" title="2.1 常规安装"></a>2.1 常规安装</h2><p>请参考官网下载链接：<a class="link"   href="https://www.zerotier.com/download/" >Download<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="2-2-Arch-系-Linux-安装"><a href="#2-2-Arch-系-Linux-安装" class="headerlink" title="2.2 Arch 系 Linux 安装"></a>2.2 Arch 系 Linux 安装</h2><p>通过<code>pacman</code>安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Sy zerotier-one</span><br></pre></td></tr></table></figure></div>

<p>设置开机自启动，并启动<code>zerotier-one</code>服务：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now zerotier-one</span><br></pre></td></tr></table></figure></div>

<h1 id="3-加入创建的组网"><a href="#3-加入创建的组网" class="headerlink" title="3.加入创建的组网"></a>3.加入创建的组网</h1><p>红色框：ID （是一个 16 字节的十六进制字符串）要复制下来<br>紫色框处：要勾选上<br>黑色框：用户可以自定义命名加入的设备<br>绿色框：分配的 IP 地址，用于连接使用<br><a href="https://imgse.com/i/pACzhUU"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/08/18/pACzhUU.png"
                      alt="管理"
                ><figcaption>管理</figcaption></figure></a></p>
<h2 id="3-1-加入组网"><a href="#3-1-加入组网" class="headerlink" title="3.1 加入组网"></a>3.1 加入组网</h2><p>其它设备直接在软件里输入组网 ID 就能直接加入了，但是要确定防火墙不能组织 Zerotier 流量。对于 Linux 设备按如下方式：</p>
<ul>
<li><p>加入组网：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> zerotier-cli <span class="built_in">join</span> &lt;network-id&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>验证加入状态:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> zerotier-cli listnetworks</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="3-2-在-ZeroTier-管理控制台上授权设备"><a href="#3-2-在-ZeroTier-管理控制台上授权设备" class="headerlink" title="3.2 在 ZeroTier 管理控制台上授权设备"></a>3.2 在 ZeroTier 管理控制台上授权设备</h2><p>登录到 ZeroTier 的管理控制台（<a class="link"   href="https://my.zerotier.com/" >ZeroTier Central<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>），找到你创建的网络。你会看到一个待授权的设备列表。你需要在控制台中授权你的设备：</p>
<ol>
<li>在控制台的网络管理页面中，找到你的网络。</li>
<li>在“成员”部分，你会看到一个类似 <code>e3918db483f0c385</code> 的设备 ID（这是你的设备）。</li>
<li>勾选该设备，然后点击“授权”或“允许”按钮以授权设备加入网络。</li>
</ol>
<h3 id="3-3-验证网络连接"><a href="#3-3-验证网络连接" class="headerlink" title="3.3 验证网络连接"></a>3.3 验证网络连接</h3><p>可以使用 <code>ping</code> 命令来测试与网络中其他设备的连接：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ping &lt;zerotier-ip-address&gt;</span><br></pre></td></tr></table></figure></div>
<p>替换 <code>&lt;zerotier-ip-address&gt;</code> 为网络中其他设备的 ZeroTier IP 地址。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈 CMake 中的 find_package</title>
    <url>/2024/12/16/cmake%E4%B8%AD%E7%9A%84find_package/</url>
    <content><![CDATA[<h1 id="1-find-package-说明"><a href="#1-find-package-说明" class="headerlink" title="1.find_package 说明"></a>1.find_package 说明</h1><p><code>find_package</code> 是 CMake 中用于 <strong>查找外部库或包</strong> 的命令。它的主要作用是帮助 CMake 找到第三方库、工具或模块，并导入它们所需的信息（如库路径、头文件路径、链接依赖关系等），以便项目可以顺利进行编译和链接。</p>
<h2 id="1-1-工作原理"><a href="#1-1-工作原理" class="headerlink" title="1.1 工作原理"></a>1.1 工作原理</h2><p><code>find_package</code> 会在系统指定的路径中查找某个包，并加载与该包相关的信息。可以通过下面这种方式查看系统路径：</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(path <span class="variable">$&#123;CMAKE_SYSTEM_PREFIX_PATH&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;path&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure></div>

<p>会输出：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- /usr/local</span><br><span class="line">-- /usr</span><br><span class="line">-- /</span><br><span class="line">-- /usr</span><br><span class="line">-- /usr/local</span><br><span class="line">-- /usr/X11R6</span><br><span class="line">-- /usr/pkg</span><br><span class="line">-- /opt</span><br></pre></td></tr></table></figure></div>

<p>查找包时，它主要依赖以下机制：</p>
<ol>
<li><strong>查找路径</strong><br>CMake 会按顺序查找以下路径来寻找包：<ol>
<li>用户指定的路径：通过 <code>CMAKE_PREFIX_PATH</code> 或 <code>PATHS</code> 参数指定的路径。</li>
<li>默认路径：</li>
</ol>
<ul>
<li>系统路径。</li>
<li>环境变量，如 <code>CMAKE_MODULE_PATH</code> 和 <code>CMAKE_FIND_ROOT_PATH</code>。</li>
</ul>
<ol start="3">
<li>CMake 模块路径：CMake 内置的模块搜索路径。</li>
<li>自定义的查找脚本：</li>
</ol>
<ul>
<li>自定义的 <code>&lt;package&gt;Config.cmake</code> 文件。</li>
<li><code>Find&lt;Package&gt;.cmake</code> 模块文件。</li>
</ul>
</li>
</ol>
<p>CMake 按照这些路径的顺序进行搜索，找到第一个匹配的结果即停止。</p>
<ol start="2">
<li><p><strong>工作模式</strong><br><code>find_package</code> 有两种主要工作模式：</p>
<ol>
<li><p>Config 模式（配置文件模式）<br>查找 <code>&lt;Package&gt;Config.cmake</code> 或 <code>&lt;lowercase-package&gt;-config.cmake</code> 文件。该模式通常用于现代 CMake 兼容的库或第三方项目，它们会生成配置文件供 CMake 使用。</p>
</li>
<li><p>Module 模式（模块文件模式）<br>查找 <code>Find&lt;Package&gt;.cmake</code> 文件。此模式通常用于 CMake 自带的模块文件或用户定义的模块文件。</p>
</li>
</ol>
</li>
<li><p><strong>工作流程</strong><br>当你调用 <code>find_package(&lt;Package&gt; REQUIRED)</code> 时：</p>
<ol>
<li>首先查找 <code>&lt;Package&gt;Config.cmake</code> 配置文件。</li>
<li>如果找不到，再查找 <code>Find&lt;Package&gt;.cmake</code> 模块文件。</li>
<li>成功找到后，CMake 会设置一系列变量（如 <code>&lt;Package&gt;_INCLUDE_DIRS</code>、<code>&lt;Package&gt;_LIBRARIES</code> 等），这些变量可以在后续的 <code>target_include_directories</code> 和 <code>target_link_libraries</code> 中使用。</li>
<li>如果添加 <code>REQUIRED</code> 选项但未找到包，CMake 将报错。</li>
</ol>
</li>
</ol>
<h2 id="1-2-基本语法"><a href="#1-2-基本语法" class="headerlink" title="1.2 基本语法"></a>1.2 基本语法</h2><div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(&lt;PackageName&gt; [version] [EXACT] [QUIET] [REQUIRED] [MODULE])</span><br></pre></td></tr></table></figure></div>

<p>参数说明：</p>
<ol>
<li><code>&lt;PackageName&gt;</code>：要查找的包名。</li>
<li><code>[version]</code>：指定包的版本号，例如 <code>1.2.3</code>。</li>
<li><code>EXACT</code>：要求找到的版本必须完全匹配指定的版本号。</li>
<li><code>QUIET</code>：找到包时不输出查找过程的日志信息。</li>
<li><code>REQUIRED</code>：如果未找到包，CMake 将终止配置并报错。</li>
<li><code>MODULE</code>：强制 CMake 只查找 <code>Find&lt;Package&gt;.cmake</code> 模块文件，而不查找 <code>&lt;Package&gt;Config.cmake</code>。</li>
</ol>
<h2 id="1-3-使用-find-package-的结果"><a href="#1-3-使用-find-package-的结果" class="headerlink" title="1.3 使用 find_package 的结果"></a>1.3 使用 find_package 的结果</h2><p><code>find_package</code> 成功找到包后，通常会设置一些变量，用户可以使用这些变量来链接库、包含头文件等。</p>
<p>常见的变量包括：</p>
<ul>
<li><code>&lt;Package&gt;_FOUND</code>：是否找到包，值为 <code>TRUE</code> 或 <code>FALSE</code>。</li>
<li><code>&lt;Package&gt;_INCLUDE_DIRS</code>：包的头文件目录。</li>
<li><code>&lt;Package&gt;_LIBRARIES</code>：包的库文件路径。</li>
<li><code>&lt;Package&gt;_VERSION</code>：找到的包的版本号。</li>
</ul>
<hr>
<h1 id="2-注意点"><a href="#2-注意点" class="headerlink" title="2.注意点"></a>2.注意点</h1><p>在 CMake 中，<code>find_package</code> 对包名是 <strong>大小写敏感</strong> 的，包名必须与库提供的 <code>&lt;Package&gt;Config.cmake</code> 文件名、模块文件名（如 <code>Find&lt;Package&gt;.cmake</code>）中的定义 <strong>完全匹配</strong> 。</p>
<p>在不确定大小写时，可以通过查找库的 <strong>CMake 配置文件</strong> 方式来确定，通常位于库的安装路径下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /usr /opt -name <span class="string">&quot;*Config.cmake&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>例如，找到 <code>/usr/lib/cmake/Qt5/Qt5Config.cmake</code>，说明包名是 <code>Qt5</code>。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake 基础教程</title>
    <url>/2024/11/29/cmake%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-构建指令"><a href="#1-构建指令" class="headerlink" title="1.构建指令"></a>1.构建指令</h1><p>现代<code>CMake</code>提供了更方便的<code>-B</code>和<code>--build</code>指令，不同平台，统一命令！</p>
<p>在源码目录用<code>-B</code>直接创建<code>build</code>目录并生成<code>build/Makefile</code>:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -B build</span><br></pre></td></tr></table></figure></div>
<p>这种方式免去了先创建<code>build</code>目录再切换进去再指定源码目录的麻烦。</p>
<p>示例如下：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/11/29/tL9qsWvMekI3zcw.png"
                      alt="示例1"
                ><figcaption>示例1</figcaption></figure></p>
<p>自动调用本地的构建系统在<code>build</code>里构建，相当于<code>make -C build -j4</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cmake --build build -j4</span><br></pre></td></tr></table></figure></div>
<p>这种方式统一了不同平台（Linux 上会调用<code>make</code>，Windows 上调用<code>devenv.exe</code>）</p>
<p>调用本地的构建系统执行<code>install</code>这个目标，即安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> cmake --build build --target install</span><br></pre></td></tr></table></figure></div>
<p>相当于 Linux 下的<code>sudo make install</code>。</p>
<p>结论：从现在开始，如果在命令行操作<code>cmake</code>，请使用更方便的<code>-B</code>和<code>--build</code>命令。</p>
<h1 id="2-生成器"><a href="#2-生成器" class="headerlink" title="2.生成器"></a>2.生成器</h1><ul>
<li>Linux 系统上的<code>CMake</code>默认用是<code>Unix Makefiles</code>生成器；Windows 系统默认是<code>Visual Studio 2019</code>生成器；MacOS 系统默认是<code>Xcode</code>生成器。</li>
<li>可以用<code>-G</code>参数改用别的生成器，例如<code>cmake -G Ninja</code>会生成<code>Ninja</code>这个构建系统的构建规则。<code>Ninja</code>是一个高性能，跨平台的构建系统，Linux、Windows、MacOS上都可以用。</li>
<li><code>Ninja</code>可以从包管理器里安装，没有包管理器的 Windows 可以用 Python 的包管理器安装：<code>pip install ninja</code>（有趣的事实：<code>CMake</code>也可以通过<code>pip install cmake</code>安装）。</li>
<li>事实上，<code>MSBuild</code>是单核心的构建系统，<code>Makefile</code>虽然多核心，但因历史兼容原因效率一般。而<code>Ninja</code>则是专为性能优化的构建系统，它和<code>CMake</code>结合都是行业标准了。</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -G Ninja -B build</span><br></pre></td></tr></table></figure></div>
<p>注：<code>-G Ninja</code>还可以写成<code>-GNinja</code>和<code>-G &quot;Ninja&quot;</code>（推荐这种）。在 Linux 上没有指定的话，默认是<code>-G &quot;Unix Makefiles&quot;</code>。</p>
<p>如图所示：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/11/29/5veQ3nHVUhT7ipl.png"
                      alt="示例2"
                ><figcaption>示例2</figcaption></figure></p>
<h2 id="2-1-Ninja和Makefile的简单对比："><a href="#2-1-Ninja和Makefile的简单对比：" class="headerlink" title="2.1 Ninja和Makefile的简单对比："></a>2.1 <code>Ninja</code>和<code>Makefile</code>的简单对比：</h2><p><code>ninja</code>花费的时间：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/11/29/sha1dGMkHTNuQ8A.png"
                      alt="ninja.png"
                ><figcaption>ninja.png</figcaption></figure></p>
<p><code>make</code>花费的时间：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/11/29/kfcOwtZbQV4UMA5.png"
                      alt="make.png"
                ><figcaption>make.png</figcaption></figure></p>
<p>从两幅图对比可以看出，<code>ninja</code>花费的时间更少，效率更高。</p>
<p>事实上，在性能上：<code>Ninja &gt; Makefile &gt; MSBuild</code>。<code>Makefile</code>启动时会把每个文件都检测一遍，浪费很多时间。特别是有很多文件，但是实际需要构建的只有一小部分，从而是<code>I/O Bound</code>的时候，<code>Ninja</code>的速度提升就很明显。然而某些专利公司的<code>CUDA toolkit</code>在 Windows 上只允许用<code>MSBuild</code>构建，不能用<code>Ninja</code>（怕不是和<code>Bill Gates</code>有什么交易，哈哈）。</p>
<h1 id="3-设置"><a href="#3-设置" class="headerlink" title="3.设置"></a>3.设置</h1><h2 id="3-1-编译器设置"><a href="#3-1-编译器设置" class="headerlink" title="3.1 编译器设置"></a>3.1 编译器设置</h2><p>可以在<code>CMakeLists.txt</code>中添加：</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER clang)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER clang++)</span><br></pre></td></tr></table></figure></div>
<p>指定编译器为<code>clang</code>和<code>clang++</code>。不指定的话，默认是<code>gcc</code>和<code>g++</code>。这两条命令应该放在文件的开始位置（<code>cmake_minimum_required</code>之下，其他命令之上），否则可能无效。</p>
<p>也可以在命令行阶段指定：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -B build -G Ninja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++</span><br></pre></td></tr></table></figure></div>

<h1 id="4-查找第三方库（非默认路径）"><a href="#4-查找第三方库（非默认路径）" class="headerlink" title="4.查找第三方库（非默认路径）"></a>4.查找第三方库（非默认路径）</h1><p>有时安装的第三方库没有安装在系统环境变量路径，此时需要手动添加。</p>
<h2 id="4-1-set-CMAKE-PREFIX-PATH"><a href="#4-1-set-CMAKE-PREFIX-PATH" class="headerlink" title="4.1 set(CMAKE_PREFIX_PATH &quot;...&quot;)"></a>4.1 <code>set(CMAKE_PREFIX_PATH &quot;...&quot;)</code></h2><ul>
<li><p><strong>作用：</strong><br>设置一个搜索路径列表，供 CMake 的 <code>find_package()</code> 和其他查找命令使用。  </p>
<ul>
<li>CMake 会在指定的路径下，递归搜索各种配置文件（如 <code>*.cmake</code>）。</li>
<li>它是一个通用的全局路径变量，不仅适用于 Qt，还适用于其他外部库。</li>
<li><em><strong>完全控制搜索路径，不使用默认路径，也就是说会覆盖默认的<code>CMAKE_PREFIX_PATH</code>。</strong></em></li>
</ul>
</li>
<li><p><strong>适用场景：</strong><br>当你需要 CMake 查找多个不同的外部库或模块，并希望统一管理搜索路径时，使用 <code>CMAKE_PREFIX_PATH</code> 是最佳选择。</p>
</li>
<li><p><strong>工作机制：</strong></p>
<ul>
<li>查找时会从 <code>CMAKE_PREFIX_PATH</code> 指定的目录中依次搜索。</li>
</ul>
</li>
<li><p><strong>优点：</strong></p>
<ul>
<li>更通用，可以适配不同的路径组织结构。</li>
<li>统一管理多个依赖库的搜索路径。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_PREFIX_PATH <span class="string">&quot;/opt/Qt/6.8.0/gcc_64/lib/cmake/Qt6/&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(Qt6 REQUIRED COMPONENTS Widgets Core)</span><br></pre></td></tr></table></figure></div>
<p>这里会在 <code>/opt/Qt/6.8.0/gcc_64/lib/cmake/Qt6/</code> 下寻找 <code>Qt6Config.cmake</code> 配置文件。</p>
<p>可以同时添加多条路径：<code>set(CMAKE_PREFIX_PATH &quot;/opt/custom_lib1;/opt/custom_lib2&quot;)</code>。</p>
<h2 id="4-2-list-APPEND-（推荐）"><a href="#4-2-list-APPEND-（推荐）" class="headerlink" title="4.2 list(APPEND ...)（推荐）"></a>4.2 <code>list(APPEND ...)</code>（推荐）</h2><p><strong>作用：</strong> 该命令的目的是将一个新的路径添加到 CMake 的 CMAKE_PREFIX_PATH 变量，让 CMake 在该路径下查找依赖库（find_package 查找时会用到）。通过<code>list(APPEND ...)</code>，可以在<code>CMAKE_PREFIX_PATH</code>变量的末尾添加新的路径。</p>
<p>示例：</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND CMAKE_PREFIX_PATH /opt/Qt/<span class="number">6.8</span>.<span class="number">0</span>/gcc_64/lib/cmake/Qt6/)</span><br><span class="line"><span class="keyword">find_package</span>(Qt6 REQUIRED COMPONENTS Widgets Core)</span><br></pre></td></tr></table></figure></div>

<p>可以同时添加多个路径：</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND CMAKE_PREFIX_PATH </span><br><span class="line">    <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">install</span>/boost_1_82_0 </span><br><span class="line">    <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">install</span>/pcl_1_14 </span><br><span class="line">    <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">install</span>/qt6</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h2 id="4-3-set-Qt-dir"><a href="#4-3-set-Qt-dir" class="headerlink" title="4.3 set(Qt_dir &quot;...&quot;)"></a>4.3 <code>set(Qt_dir &quot;...&quot;)</code></h2><ul>
<li><p><strong>作用：</strong><br>这是一个项目自定义变量（<code>Qt_dir</code> 的名字是随意的），用于直接指向 Qt 的具体路径（通常是 <code>Qt6Config.cmake</code> 所在的目录）。</p>
<ul>
<li>CMake 本身对 <code>Qt_dir</code> 变量没有特殊处理。</li>
<li>它可以在代码中手动使用，比如直接传递给 <code>find_package()</code> 的 <code>HINTS</code> 参数。</li>
</ul>
</li>
<li><p><strong>适用场景：</strong><br>如果你只需要为当前项目指定一个特定的 Qt 路径，可以用这种方式。不过，这种方式需要手动确保路径的正确性，并显式使用。</p>
</li>
<li><p><strong>工作机制</strong>:</p>
<ul>
<li><code>Qt_dir</code> 不会影响 CMake 的全局搜索行为，除非在查找时手动传递它。</li>
</ul>
</li>
<li><p><strong>优点</strong>:</p>
<ul>
<li>更精确地指定路径，避免其他可能的干扰。</li>
<li>灵活性更高，适合需要手动控制路径的场景。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(Qt_dir /opt/Qt/<span class="number">6.8</span>.<span class="number">0</span>/gcc_64/lib/cmake/Qt6)</span><br><span class="line"><span class="keyword">find_package</span>(Qt6 REQUIRED COMPONENTS Widgets HINTS <span class="variable">$&#123;Qt_dir&#125;</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>firewall 的常用指令</title>
    <url>/2024/09/11/firewall%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1-检查-firewall"><a href="#1-检查-firewall" class="headerlink" title="1.检查 firewall"></a>1.检查 firewall</h1><p>是否安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> firewalld</span><br></pre></td></tr></table></figure></div>

<p>是否启动：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status firewalld</span><br></pre></td></tr></table></figure></div>

<h1 id="2-TCP-和-UDP"><a href="#2-TCP-和-UDP" class="headerlink" title="2.TCP 和 UDP"></a>2.TCP 和 UDP</h1><p>这几种协议都是网络协议中的重要组成部分，各自有不同的功能和用途。以下是对每种协议的详细解释：</p>
<h2 id="1-TCP（传输控制协议）"><a href="#1-TCP（传输控制协议）" class="headerlink" title="1. TCP（传输控制协议）"></a>1. TCP（传输控制协议）</h2><ul>
<li><strong>定义</strong> ：TCP（Transmission Control Protocol）是一个面向连接的、可靠的传输协议，位于传输层（OSI模型的第四层）。</li>
<li><strong>用途</strong> ：用于在网络上可靠地传输数据，确保数据包的顺序、完整性和无错误传输。常见的应用包括网页浏览（HTTP&#x2F;HTTPS）、电子邮件（SMTP&#x2F;IMAP&#x2F;POP3）、文件传输（FTP）等。</li>
<li><strong>特点</strong> ：<ul>
<li>需要建立连接（三次握手）。</li>
<li>提供数据完整性、顺序保证和错误检测。</li>
<li>支持流量控制和拥塞控制。</li>
</ul>
</li>
</ul>
<h2 id="2-UDP（用户数据报协议）"><a href="#2-UDP（用户数据报协议）" class="headerlink" title="2. UDP（用户数据报协议）"></a>2. UDP（用户数据报协议）</h2><ul>
<li><strong>定义</strong> ：UDP（User Datagram Protocol）是一个无连接的、轻量级的传输协议，也位于传输层。</li>
<li><strong>用途</strong> ：用于快速传输数据，但不保证数据的可靠性和顺序。常见的应用包括视频流、实时语音通信（VoIP）、在线游戏等。</li>
<li><strong>特点</strong> ：<ul>
<li>不需要建立连接。</li>
<li>不保证数据包的顺序和完整性。</li>
<li>速度快，开销小。</li>
</ul>
</li>
</ul>
<h1 id="3-常用指令"><a href="#3-常用指令" class="headerlink" title="3.常用指令"></a>3.常用指令</h1><h2 id="3-1-基本指令"><a href="#3-1-基本指令" class="headerlink" title="3.1 基本指令"></a>3.1 基本指令</h2><ul>
<li><p>列出所有配置：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> firewall-cmd --list-all</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>重载设置（在添加新配置后需要做，以使配置生效）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> firewall-cmd --reload</span><br></pre></td></tr></table></figure></div></li>
<li><p>列出所有开放的端口：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="3-2-端口设置"><a href="#3-2-端口设置" class="headerlink" title="3.2 端口设置"></a>3.2 端口设置</h2><ul>
<li>开放端口<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=80/tcp &lt;--zone=public&gt; &lt;--permanent&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><code>--zone=public</code>参数：指定区域。<br><code>--permanent</code>参数：可以实现永久开放该端口，重启后仍然生效。不加的话就是临时端口。</p>
<ul>
<li><p>查看所有可用区域：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --get-zones</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>查看当前默认区域：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --get-default-zone</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除端口：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> firewall-cmd --remove-port=80/tcp &lt;--zone=public&gt; &lt;--permanent&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 VSCode 下使用 gdb 调试 C++ 出现的问题</title>
    <url>/2024/11/13/gdb%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="1-问题复现"><a href="#1-问题复现" class="headerlink" title="1.问题复现"></a>1.问题复现</h1><p>如下图所示，这是调试时出现的问题：<br><a href="https://imgse.com/i/pAgMhxf"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/11/13/pAgMhxf.md.png"
                      alt="step1"
                ><figcaption>step1</figcaption></figure></a></p>
<p><a href="https://imgse.com/i/pAgMHaj"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/11/13/pAgMHaj.md.png"
                      alt="step2"
                ><figcaption>step2</figcaption></figure></a></p>
<p>从图中可以发现，在进行单步调试时，先进入<code>ostream</code>，但是失败了，因为它找的是错误的路径，这个路径<code>/usr/src/debug/gcc/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include</code>根本不存在。</p>
<h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h1><p>配置<code>~/.gdbinit</code>文件即可。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nano ~/.gdbinit</span><br></pre></td></tr></table></figure></div>

<p>加入下面的内容：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> directories /usr/include/c++/14.2.1</span><br><span class="line"><span class="built_in">set</span> substitute-path /usr/src/debug/gcc/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include /usr/include/c++/14.2.1</span><br></pre></td></tr></table></figure></div>

<p>然后就解决了，效果如下：<br><a href="https://imgse.com/i/pAgMXR0"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/11/13/pAgMXR0.md.png"
                      alt="step3"
                ><figcaption>step3</figcaption></figure></a></p>
<h1 id="3-说明"><a href="#3-说明" class="headerlink" title="3.说明"></a>3.说明</h1><ol>
<li><p><strong><code>set directories /usr/include/c++/14.2.1</code></strong> ：<br>这个命令告诉 GDB 在 <code>/usr/include/c++/14.2.1</code> 目录下搜索头文件。这个目录通常是系统上安装的 C++ 标准库头文件的位置。当你请求 GDB 显示源代码或者 GDB 需要查找源代码以进行调试时，它会首先查看这个目录。</p>
</li>
<li><p><strong><code>set substitute-path /usr/src/debug/gcc/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include /usr/include/c++/14.2.1</code></strong> ：<br>这个命令是一个路径替换指令，它将 GDB 查找源代码时遇到的一个路径映射到另一个路径。具体来说，当 GDB 尝试在 <code>/usr/src/debug/gcc/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include</code> 目录下查找文件时，它会将其重定向到 <code>/usr/include/c++/14.2.1</code> 目录。这通常用于解决源代码和编译后的二进制文件不在同一位置的问题，或者当你想要 GDB 从不同的位置加载源代码时。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>c++</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Linux 下使用 matplotlib 中文乱码问题</title>
    <url>/2024/09/14/linux-matplotli%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="1-出现的问题"><a href="#1-出现的问题" class="headerlink" title="1.出现的问题"></a>1.出现的问题</h1><p>以下面这个代码为例：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">1</span>, <span class="number">12</span>)</span><br><span class="line">y = x ** <span class="number">2</span> + <span class="number">4</span></span><br><span class="line">plt.title(<span class="string">&quot;Matplotlib demo&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;时间(分钟)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;金额($)&quot;</span>)</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>


<p>在 Linux 下使用 Python 的<code>matplotlib</code>包默认是会出现乱码的：<br><a href="https://imgse.com/i/pAuEYVI"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/09/14/pAuEYVI.png"
                      alt="乱码.png"
                ><figcaption>乱码.png</figcaption></figure></a></p>
<h1 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h1><p>首先需要下载字体，网上常用的中文字体是<code>SimHei</code>，<a class="link"   href="https://github.com/StellarCN/scp_zh/blob/master/fonts/SimHei.ttf" >下载地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="2-1-方式一：直接在代码中引入"><a href="#2-1-方式一：直接在代码中引入" class="headerlink" title="2.1 方式一：直接在代码中引入"></a>2.1 方式一：直接在代码中引入</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.font_manager <span class="keyword">as</span> fm</span><br><span class="line"></span><br><span class="line">font_path = <span class="string">&quot;/home/sky/下载/SimHei.ttf&quot;</span>  <span class="comment"># 设置字体路径</span></span><br><span class="line">my_font = fm.FontProperties(fname=font_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动注册字体</span></span><br><span class="line">fm.fontManager.addfont(font_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字体名称</span></span><br><span class="line">font_name = my_font.get_name()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;真实字体名称: <span class="subst">&#123;font_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Matplotlib 识别该字体</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>] = [font_name]</span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span>  <span class="comment"># 解决负号显示问题</span></span><br></pre></td></tr></table></figure></div>

<h2 id="2-2-方式二：修改配置文件"><a href="#2-2-方式二：修改配置文件" class="headerlink" title="2.2 方式二：修改配置文件"></a>2.2 方式二：修改配置文件</h2><ol>
<li><strong>查找存放字体的文件夹</strong></li>
</ol>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(matplotlib.matplotlib_fname())   <span class="comment"># 查找字体路径</span></span><br></pre></td></tr></table></figure></div>
<p>运行这段代码会打印出字体存放路径，如：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">/home/sky/miniconda3/envs/test/lib/python3.12/site-packages/matplotlib/mpl-data/matplotlibrc</span><br></pre></td></tr></table></figure></div>
<p><code>matplotlibrc</code>是配置文件，一会儿要修改的。然后进入存放字体的目录下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/sky/miniconda3/envs/test/lib/python3.12/site-packages/matplotlib/mpl-data/fonts/ttf</span><br></pre></td></tr></table></figure></div>

<p>把下载好的字体文件<code>SimHei.ttf</code>复制到<code>ttf</code>目录下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/下载/SimHei.ttf .  </span><br></pre></td></tr></table></figure></div>

<p>然后回到<code>mpl-data</code>目录下，修改<code>matplotlibrc</code>文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nano matplotlibrc</span><br></pre></td></tr></table></figure></div>

<p>找到<code>font.serif</code>，<code>font.sans-serif</code>所在位置，如下如所示。在冒号后面加入<code>SimHei</code>，保存退出：</p>
<ul>
<li><p>原来的：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">#font.serif:      DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopia, ITC Bookman, Bookman, Nimbus Roman No9 L, Times New Roman, Times, Palatino, Charter, serif</span><br><span class="line">#font.sans-serif: DejaVu Sans, Bitstream Vera Sans, Computer Modern Sans Serif, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>修改后的：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">#font.serif:      SimHei, DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopia, ITC Bookman, Bookman, Nimbus Roman No9 L, Times New Roman, Times, Palatino, Charter, serif</span><br><span class="line">#font.sans-serif: SimHei, DejaVu Sans, Bitstream Vera Sans, Computer Modern Sans Serif, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><a href="https://imgse.com/i/pAuJFz9"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/09/15/pAuJFz9.md.png"
                      alt="修改示意图"
                ><figcaption>修改示意图</figcaption></figure></a></p>
<ol start="2">
<li><strong>清理缓存</strong></li>
</ol>
<p>查找缓存位置：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib    </span><br><span class="line"><span class="built_in">print</span>(matplotlib.get_cachedir())</span><br></pre></td></tr></table></figure></div>

<p>把缓存文件删除即可：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> ~/.cache/matplotlib -rf</span><br></pre></td></tr></table></figure></div>

<h1 id="3-解决示例"><a href="#3-解决示例" class="headerlink" title="3.解决示例"></a>3.解决示例</h1><p><a href="https://imgse.com/i/pAuERiV"><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s21.ax1x.com/2024/09/14/pAuERiV.png"
                      alt="正常输出.png"
                ><figcaption>正常输出.png</figcaption></figure></a></p>
<h2 id="3-1-参考教程"><a href="#3-1-参考教程" class="headerlink" title="3.1 参考教程"></a>3.1 参考教程</h2><ul>
<li><a class="link"   href="https://developer.aliyun.com/article/1577567" >【Deepin20系统】Linux系统中永久解决matplotlib画图中文乱码问题和使用seaborn中文乱码问题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://cloud.tencent.com/developer/article/1877673" >解决Python使用matplotlib绘图时出现的中文乱码问题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<h1 id="4-负号乱码解决"><a href="#4-负号乱码解决" class="headerlink" title="4.负号乱码解决"></a>4.负号乱码解决</h1><p>只要在前面加以段这个代码：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解决负号显示问题</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure></div>
<p>就能正常显示负号</p>
]]></content>
      <categories>
        <category>Python技巧</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>linux</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>pacman 包管理器使用教程</title>
    <url>/2024/07/24/pacman%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><p>  在 <code>EndeavouOS</code>（以及其他基于<code>Arch</code>的发行版）中，<code>pacman</code> 是一个用于软件包管理的命令行工具。下面是 <code>pacman</code> 命令的详细解释：</p>
<ul>
<li><code>-S</code>：用于安装软件包。</li>
<li><code>-y</code>：强制刷新软件包数据库。</li>
<li><code>-yy</code>：强制刷新所有的软件包数据库。通常只需要一个 <code>-y</code> 就足够，但 <code>-yy</code> 用于解决某些情况下可能出现的数据库同步问题。</li>
<li><code>-u</code>：更新所有已安装的软件包，用于更新系统或者<code>pacman</code>包含的软件以及以来库。</li>
</ul>
<p>对于所有用<code>pacman</code>进行的操作，都可以通过<code>yay</code>实现：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman yay</span><br></pre></td></tr></table></figure></div>
<p><code>yay</code>支持的软件多一些（通过<code>aur</code>源）。</p>
<h1 id="2-下载和更新"><a href="#2-下载和更新" class="headerlink" title="2.下载和更新"></a>2.下载和更新</h1><ul>
<li><strong>要更新或下载指定的软件包：</strong><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S 包名</span><br></pre></td></tr></table></figure></div>
<code>pacman</code> 会检查你指定的软件包是否有新版本，如果有的话，就会下载并安装更新后的版本。</li>
</ul>
<h1 id="3-查看包-库信息"><a href="#3-查看包-库信息" class="headerlink" title="3.查看包&#x2F;库信息"></a>3.查看包&#x2F;库信息</h1><ul>
<li><strong>查看包名信息</strong>：<br>显示指定软件包的信息，但不会安装或更新。这个选项可以用来查看某个软件包的详细信息，包括它的版本、依赖关系等。例如：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Si &lt;pkgname&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>查看包的简略信息：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">yay -Qs &lt;pkgname&gt;</span><br></pre></td></tr></table></figure></div>

<p>查看包的详细信息：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">yay -Qi &lt;pkgname&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>查看可升级的包&#x2F;库：</strong><br>列出有可用更新的已安装软件包及其最新版本。<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Qu</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>列出所有的外部软件包（即非官方仓库安装的包，如<code>AUR</code>软件包）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Qm</span><br></pre></td></tr></table></figure></div>

<h1 id="4-卸载"><a href="#4-卸载" class="headerlink" title="4.卸载"></a>4.卸载</h1><h2 id="4-1-卸载单个软件包"><a href="#4-1-卸载单个软件包" class="headerlink" title="4.1 卸载单个软件包"></a>4.1 卸载单个软件包</h2><p>要卸载单个软件包，可以使用以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -R package_name</span><br></pre></td></tr></table></figure></div>

<h2 id="4-2-卸载软件包及其未使用的依赖"><a href="#4-2-卸载软件包及其未使用的依赖" class="headerlink" title="4.2 卸载软件包及其未使用的依赖"></a>4.2 卸载软件包及其未使用的依赖</h2><p>有时卸载一个包后，它的一些依赖包可能不再被其他软件包使用。要卸载软件包及其未使用的依赖，可以使用以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Rns package_name</span><br></pre></td></tr></table></figure></div>

<p>解释：</p>
<ul>
<li><code>-R</code>(–remove)：卸载指定的包。</li>
<li><code>-n</code>(–nosave)：从系统中删除安装包的所有配置文件。</li>
<li><code>-s</code>(–recursive)：递归地卸载未使用的依赖包。</li>
</ul>
<h2 id="4-3-强制卸载（不推荐）"><a href="#4-3-强制卸载（不推荐）" class="headerlink" title="4.3 强制卸载（不推荐）"></a>4.3 强制卸载（不推荐）</h2><p>在极少数情况下，可能需要强制卸载一个包，即使这可能会破坏系统的依赖关系。请谨慎使用此选项：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Rdd package_name</span><br></pre></td></tr></table></figure></div>

<p>解释：</p>
<ul>
<li><code>-d</code>：忽略依赖关系检查。</li>
</ul>
<h2 id="4-4-清理未使用的孤立包"><a href="#4-4-清理未使用的孤立包" class="headerlink" title="4.4 清理未使用的孤立包"></a>4.4 清理未使用的孤立包</h2><p>系统中可能会有一些未使用的孤立包，这些包是作为依赖安装的，但现在没有任何包依赖它们。可以使用以下命令清理这些孤立包：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Rns $(pacman -Qtdq)</span><br></pre></td></tr></table></figure></div>

<p>解释：</p>
<ul>
<li><code>pacman -Qtdq</code>：列出所有未使用的孤立包。</li>
<li><code>-Rns</code>：递归地卸载未使用的包及其配置文件。</li>
</ul>
<h1 id="5-查看安装包的文件及其路径"><a href="#5-查看安装包的文件及其路径" class="headerlink" title="5.查看安装包的文件及其路径"></a>5.查看安装包的文件及其路径</h1><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Ql boost</span><br></pre></td></tr></table></figure></div>

<p>输出示例：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">boost /usr/share/boostbook/xsl/source-highlight.xsl</span><br><span class="line">boost /usr/share/boostbook/xsl/template.xsl</span><br><span class="line">boost /usr/share/boostbook/xsl/testing/</span><br><span class="line">boost /usr/share/boostbook/xsl/testing/Jamfile.xsl</span><br><span class="line">boost /usr/share/boostbook/xsl/testing/testsuite.xsl</span><br><span class="line">boost /usr/share/boostbook/xsl/type.xsl</span><br><span class="line">boost /usr/share/boostbook/xsl/utility.xsl</span><br><span class="line">boost /usr/share/boostbook/xsl/xhtml.xsl</span><br><span class="line">boost /usr/share/boostbook/xsl/xref.xsl</span><br></pre></td></tr></table></figure></div>

<p>可以加上<code>grep</code>进行匹配：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Ql boost | grep cmake</span><br></pre></td></tr></table></figure></div>
<p>在<code>grep</code>后加上<code>-i</code>参数可以忽略大小写进行匹配查找。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>终端 zsh 配置指南</title>
    <url>/2024/07/19/zsh%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一、终端代理设置"><a href="#一、终端代理设置" class="headerlink" title="一、终端代理设置"></a>一、终端代理设置</h1><p>建议加上，在进行通过终端的下载、更新系统、<code>conda</code>下载或者<code>git clone</code>时，能走代理来提高下载速度。但是<code>docker</code>需要单独配置一套代理。<code>zsh</code>和<code>bash</code>都可以用这种方式。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">kate ~/.zshrc</span><br></pre></td></tr></table></figure></div>
<p><code>bash</code>需要在<code>.bashrc</code>中修改。</p>
<ul>
<li><strong>在<code>.zshrc</code>中添加以下内容：</strong></li>
</ul>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line"># where proxy</span><br><span class="line">proxy()&#123;</span><br><span class="line">  export http_proxy=&quot;http://127.0.0.1:7890&quot;</span><br><span class="line">  export https_proxy=&quot;http://127.0.0.1:7890&quot;</span><br><span class="line">  echo &quot;HTTP Proxy on&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># where noproxy</span><br><span class="line">noproxy()&#123;</span><br><span class="line">  unset http_proxy</span><br><span class="line">  unset https_proxy</span><br><span class="line">  echo &quot;HTTP Proxy off&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>根据实际情况填写自己的代理端口。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></div>

<p>通过在终端输入<code>proxy</code>或者<code>noproxy</code>来开启或关闭代理。</p>
<p>输入下面指令，可以查看终端代理地址：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">env</span> | grep -i proxy</span><br></pre></td></tr></table></figure></div>

<h1 id="二、zsh配置"><a href="#二、zsh配置" class="headerlink" title="二、zsh配置"></a>二、zsh配置</h1><h2 id="2-1-切换-zsh-为默认终端"><a href="#2-1-切换-zsh-为默认终端" class="headerlink" title="2.1 切换 zsh 为默认终端"></a>2.1 切换 zsh 为默认终端</h2><p>要确保已经安装了<code>zsh</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s $(<span class="built_in">which</span> zsh)</span><br></pre></td></tr></table></figure></div>

<p>通常要重启系统才会生效。</p>
<p>验证默认<code>shell</code></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure></div>

<h2 id="2-2-zsh-prompt"><a href="#2-2-zsh-prompt" class="headerlink" title="2.2 zsh prompt"></a>2.2 zsh prompt</h2><table>
<thead>
<tr>
<th>Code</th>
<th align="center">Info</th>
</tr>
</thead>
<tbody><tr>
<td>%T</td>
<td align="center">系统时间（时：分）</td>
</tr>
<tr>
<td>%*</td>
<td align="center">系统时间（时：分：秒）</td>
</tr>
<tr>
<td>%D</td>
<td align="center">系统日期（年-月-日）</td>
</tr>
<tr>
<td>%n</td>
<td align="center">用户名称（即：当前登陆终端的用户的名称，和whami命令输出相同）</td>
</tr>
<tr>
<td>%B</td>
<td align="center">开始到结束使用粗体打印</td>
</tr>
<tr>
<td>%b</td>
<td align="center">开始到结束使用粗体打印</td>
</tr>
<tr>
<td>%U</td>
<td align="center">开始到结束使用下划线打印</td>
</tr>
<tr>
<td>%u</td>
<td align="center">开始到结束使用下划线打印</td>
</tr>
<tr>
<td>%d</td>
<td align="center">你当前的工作目录</td>
</tr>
<tr>
<td>%~</td>
<td align="center">你目前的目录相对于～的相对路径</td>
</tr>
<tr>
<td>%M</td>
<td align="center">计算机的主机名</td>
</tr>
<tr>
<td>%m</td>
<td align="center">计算机的主机名（在第一个句号之前截断）</td>
</tr>
<tr>
<td>%l</td>
<td align="center">你当前的tty</td>
</tr>
<tr>
<td>%F{色码}</td>
<td align="center">用来设定某个颜色的开始</td>
</tr>
<tr>
<td>%f</td>
<td align="center">用来设定成预设的样式， 也可以说是设定好的颜色结束</td>
</tr>
</tbody></table>
<h3 id="2-2-1推荐配置"><a href="#2-2-1推荐配置" class="headerlink" title="2.2.1推荐配置"></a>2.2.1推荐配置</h3><p>关于自定义<code>git prompt</code>。参考这两篇文章：</p>
<ul>
<li><a class="link"   href="https://stackoverflow.com/questions/67587439/show-current-branch-on-prompt-on-zsh-shell" >Show current branch on prompt on zsh shell<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://medium.com/pareture/simplest-zsh-prompt-configs-for-git-branch-name-3d01602a6f33" >Simplest ZSH Prompt Configs for Git Branch Name<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>关于自定义<code>conda prompt</code>。参考这篇论坛：</p>
<ul>
<li><a class="link"   href="https://unix.stackexchange.com/questions/656045/how-to-modify-the-anaconda-environment-prompt-in-zsh" >how to modify the anaconda environment prompt in zsh?<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ~/.zshrc</span><br><span class="line"># Find and set branch name var if in git repository.</span><br><span class="line">function git_branch_name()</span><br><span class="line">&#123;</span><br><span class="line">  branch=$(git symbolic-ref HEAD 2&gt; /dev/null | awk &#x27;BEGIN&#123;FS=&quot;/&quot;&#125; &#123;print $NF&#125;&#x27;)</span><br><span class="line">  if [[ $branch == &quot;&quot; ]];</span><br><span class="line">  then</span><br><span class="line">    :</span><br><span class="line">  else</span><br><span class="line">    echo &#x27;- (&#x27;$branch&#x27;)&#x27;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Enable substitution in the prompt.</span><br><span class="line">setopt prompt_subst</span><br><span class="line"></span><br><span class="line">precmd_get_conda_env_name() &#123;</span><br><span class="line">if [[ -n $CONDA_PREFIX ]]; then</span><br><span class="line">    if [[ $(basename $CONDA_PREFIX) == &quot;miniconda3&quot; ]]; then</span><br><span class="line">        CONDA_ENV=&quot;base&quot;</span><br><span class="line">    else</span><br><span class="line">        CONDA_ENV=&quot;$(basename $CONDA_PREFIX)&quot;</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    CONDA_ENV=&quot;&quot;</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line">precmd_functions+=( precmd_get_conda_env_name )</span><br><span class="line">precmd_update_prompt() &#123;</span><br><span class="line">    PROMPT=$&#x27;\n&#x27;&quot;%B%F&#123;119&#125;[%F&#123;green&#125;%D&#123;%m/%d %H:%M&#125;%F&#123;119&#125;] %F&#123;red&#125;%n%F&#123;blue&#125;@%F&#123;yellow&#125;%m%F&#123;black&#125;:%F&#123;cyan&#125;%~%B%F&#123;70&#125;$(git_branch_name)&quot;$&#x27;\n&#x27;&quot;%F&#123;magenta&#125;$CONDA_ENV%F&#123;119&#125; ➜ %f%b&quot;</span><br><span class="line">&#125;</span><br><span class="line">precmd_functions+=( precmd_update_prompt )</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="2-3-插件配置"><a href="#2-3-插件配置" class="headerlink" title="2.3 插件配置"></a>2.3 插件配置</h2><ul>
<li><p><strong>备份（避免配置失败，最好备份下）：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/.zshrc ~/.zshrc.backup</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>创建配置文件夹：</strong></p>
</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p .zsh/plugins</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> .zshrc .zsh/</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> .zsh_history .zsh/</span><br></pre></td></tr></table></figure></div>
<p>注：若没有<code>.zsh_history</code>，那么需要用<code>touch</code>指令创建。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> .zsh_history</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>然后编辑文件夹<code>.zsh</code>中的<code>.zshrc</code>，加上：</strong></p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">### ZSH HOME</span><br><span class="line">export ZSH=$HOME/.zsh</span><br><span class="line"></span><br><span class="line">### ---- history config ----------</span><br><span class="line">export HISTFILE=$ZSH/.zsh_history</span><br><span class="line"></span><br><span class="line"># How many commands zsh will load to memory.</span><br><span class="line">export HISTSIZE=10000</span><br><span class="line"></span><br><span class="line"># How maney commands history will save on file.</span><br><span class="line">export SAVEHIST=10000</span><br><span class="line"></span><br><span class="line"># History won&#x27;t save duplicates.</span><br><span class="line">setopt HIST_IGNORE_ALL_DUPS</span><br><span class="line"></span><br><span class="line"># History won&#x27;t show duplicates on search.</span><br><span class="line">setopt HIST_FIND_NO_DUPS</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>安装插件：</strong></p>
</li>
</ul>
<p>进入安装插件的目录：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.zsh/plugins</span><br></pre></td></tr></table></figure></div>
<p>插件一：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span>  https://github.com/zdharma-continuum/fast-syntax-highlighting.git</span><br></pre></td></tr></table></figure></div>
<p>插件二：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions.git</span><br></pre></td></tr></table></figure></div>
<p>插件三：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-completions.git</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>在<code>.zshrc</code>copy中添加：</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">source $ZSH/plugins/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh</span><br><span class="line">fpath=($ZSH/plugins/zsh-completions/src $fpath)</span><br><span class="line"></span><br><span class="line"># zsh-autosuggestions:config</span><br><span class="line">source $ZSH/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br><span class="line">ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&quot;fg=#ff00ff,bg=cyan,bold,underline&quot;</span><br><span class="line">ZSH_AUTOSUGGEST_STRATEGY=(history completion)</span><br><span class="line">ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=20</span><br><span class="line"></span><br><span class="line"># end config</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>链接：</strong><br>最后就是创建符号链接，这样我们就可以通过更改<code>~/.zshrc</code>Copy来同步更改<code>.zsh/.zshrc</code>Copy配置文件了。首先需要确认<code>~</code>目录下没有<code>.zshrc</code>文件，如果有，就<code>rm .zshrc</code>。</p>
</li>
</ul>
<p>此时可以开始创建符号链接了：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s ~/.zsh/.zshrc ~/.zshrc</span><br></pre></td></tr></table></figure></div>

<p>重新加载配置文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></div>
<p>可以通过<code>ls -la</code>来查看是否链接成功。</p>
<h1 id="三、问题汇总"><a href="#三、问题汇总" class="headerlink" title="三、问题汇总"></a>三、问题汇总</h1><h2 id="3-1-历史命令问题"><a href="#3-1-历史命令问题" class="headerlink" title="3.1 历史命令问题"></a>3.1 历史命令问题</h2><p>出现这种情况<code>zsh: corrupt history file /home/sky/.zsh/.zsh_history</code>。有的时候系统因为默写原因强行启动的时候会破坏zsh的历史文件。<br>解决办法：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/.zsh_history ~/.zsh_history_backup</span><br><span class="line"><span class="built_in">rm</span> ~/.zsh_history</span><br><span class="line">strings -eS ~/.zsh_history_backup &gt; ~/.zsh_history</span><br><span class="line"><span class="built_in">fc</span> -R ~/.zsh_history</span><br></pre></td></tr></table></figure></div>
<p>如果上述步骤没有解决问题，可能是因为.zsh_history文件严重损坏。在这种情况下，需要放弃旧的历史记录并创建一个新的文件。</p>
<h2 id="3-2-安装-oh-my-zsh-可能会出现的问题"><a href="#3-2-安装-oh-my-zsh-可能会出现的问题" class="headerlink" title="3.2 安装 oh my zsh 可能会出现的问题"></a>3.2 安装 oh my zsh 可能会出现的问题</h2><p><strong>注意：</strong> 如果是安装<code>oh my zsh</code>可能会出现下面的问题：</p>
<p>1.发现安装完<code>oh my zsh</code>后终端中有些命令不能使用：<br>编辑<code>.zshrc</code>发现里面内容都被替换掉了，之前的配置内容都被转移到一个叫<code>.zshrc.pre-oh-my-zsh</code>文件中。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>从源码安装 SSH</title>
    <url>/2024/09/11/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85SSH/</url>
    <content><![CDATA[<h1 id="1-构建基础镜像"><a href="#1-构建基础镜像" class="headerlink" title="1.构建基础镜像"></a>1.构建基础镜像</h1><p>在当期目录下（与<code>Dockerfile</code>同目录），添加<code>sources.list</code>文件，并添加镜像源：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line"># Ubuntu sources have moved to the /etc/apt/sources.list.d/ubuntu.sources</span><br><span class="line"># file, which uses the deb822 format. Use deb822-formatted .sources files</span><br><span class="line"># to manage package sources in the /etc/apt/sources.list.d/ directory.</span><br><span class="line"># See the sources.list(5) manual page for details.</span><br><span class="line"></span><br><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换</span><br><span class="line"># deb http://security.ubuntu.com/ubuntu/ noble-security main restricted universe multiverse</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu/ noble-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-proposed main restricted universe multiverse</span><br><span class="line"># # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure></div>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/"><code>Ubuntu</code>清华镜像源</a></p>
<p><code>Dockerfile</code>编写：</p>
<div class="code-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> http_proxy=http://<span class="number">172.27</span>.<span class="number">150.74</span>:<span class="number">7890</span>/</span><br><span class="line"><span class="keyword">ENV</span> https_proxy=http://<span class="number">172.27</span>.<span class="number">150.74</span>:<span class="number">7890</span>/</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y nano wget <span class="built_in">sudo</span> net-tools</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> sources.list /etc/apt/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br></pre></td></tr></table></figure></div>
<p>根据自己实际情况设置代理环境（<code>ENV</code>）。</p>
<p>然后开始构建镜像：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t ubuntu:openssh .</span><br></pre></td></tr></table></figure></div>

<h1 id="2-创建容器"><a href="#2-创建容器" class="headerlink" title="2.创建容器"></a>2.创建容器</h1><p>运行一个容器实例：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name=ssh ubuntu:openssh</span><br></pre></td></tr></table></figure></div>

<h1 id="3-从源码安装-SSH"><a href="#3-从源码安装-SSH" class="headerlink" title="3.从源码安装 SSH"></a>3.从源码安装 SSH</h1><p>要从源码安装和升级 OpenSSH，在 Ubuntu 上可以按照以下步骤操作：</p>
<h2 id="3-1-准备环境"><a href="#3-1-准备环境" class="headerlink" title="3.1 准备环境"></a>3.1 准备环境</h2><p>首先，确保系统中安装了编译 OpenSSH 所需的依赖包。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install build-essential zlib1g-dev libssl-dev libpam0g-dev libselinux1-dev</span><br></pre></td></tr></table></figure></div>

<h2 id="3-2-下载-OpenSSH-源码"><a href="#3-2-下载-OpenSSH-源码" class="headerlink" title="3.2 下载 OpenSSH 源码"></a>3.2 下载 OpenSSH 源码</h2><p>从官方 OpenSSH 网站下载最新的源码压缩包：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-X.XX.tar.gz</span><br></pre></td></tr></table></figure></div>

<p>将 <code>X.XX</code> 替换为最新版本的版本号，可以在 <a class="link"   href="https://www.openssh.com/portable.html" >OpenSSH 官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 查询最新版本。</p>
<p>解压缩下载的文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf openssh-X.XX.tar.gz先设置下容器的`root`账户的</span><br><span class="line"><span class="built_in">cd</span> openssh-X.XX</span><br></pre></td></tr></table></figure></div>

<h2 id="3-3-配置-OpenSSH"><a href="#3-3-配置-OpenSSH" class="headerlink" title="3.3 配置 OpenSSH"></a>3.3 配置 OpenSSH</h2><p>在编译 OpenSSH 之前，使用 <code>configure</code> 脚本来生成 Makefile。可以根据你的系统环境和需求指定一些配置选项：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr --sysconfdir=/etc/ssh --with-pam --with-ssl-engine</span><br></pre></td></tr></table></figure></div>

<p>常用的选项包括：</p>
<ul>
<li><code>--prefix=/usr</code>: 将安装路径设置为 <code>/usr</code> 而不是默认的 <code>/usr/local</code>。</li>
<li><code>--sysconfdir=/etc/ssh</code>: 指定配置文件目录为 <code>/etc/ssh</code>。</li>
<li><code>--with-pam</code>: 启用 PAM（可插拔认证模块）。</li>
<li><code>--with-ssl-engine</code>: 使用 OpenSSL 的 SSL 引擎。</li>
</ul>
<p>你可以使用 <code>./configure --help</code> 来查看所有可用的配置选项。</p>
<h2 id="3-4-编译-OpenSSH"><a href="#3-4-编译-OpenSSH" class="headerlink" title="3.4 编译 OpenSSH"></a>3.4 编译 OpenSSH</h2><p>配置完成后，编译源码：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></div>

<p>编译完成后，可以通过 <code>make tests</code> 运行测试，以确保 OpenSSH 正确构建。</p>
<h2 id="3-5-安装-OpenSSH"><a href="#3-5-安装-OpenSSH" class="headerlink" title="3.5 安装 OpenSSH"></a>3.5 安装 OpenSSH</h2><p>在编译成功并通过测试后，使用 <code>make install</code> 来安装 OpenSSH。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure></div>

<p>这个命令将会把编译好的文件安装到系统中。</p>
<p>执行时可能会出现这种错误：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">Privilege separation user sshd does not exist</span><br></pre></td></tr></table></figure></div>
<p>该错误与<code>sshd</code>用户的缺失有关，这是 OpenSSH 用于权限隔离的一个功能。没有这个用户，SSH 守护进程可能无法正常启动。</p>
<p>解决办法：</p>
<ul>
<li><p>创建<code>sshd</code>用户：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd -r -d /var/empty -s /usr/sbin/nologin sshd</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>验证配置：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> /usr/sbin/sshd -t -f /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></div>
<p>如果没有输出或错误，说明配置文件是正确的。</p>
</li>
</ul>
<h2 id="3-6-配置-OpenSSH"><a href="#3-6-配置-OpenSSH" class="headerlink" title="3.6 配置 OpenSSH"></a>3.6 配置 OpenSSH</h2><p>安装完成后，检查 OpenSSH 的配置文件 <code>/etc/ssh/sshd_config</code>。</p>
<p>找到以下配置项，并确保它们没有被注释掉（前面没有<code>#</code>）并且值设置正确：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">PasswordAuthentication <span class="built_in">yes</span></span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></div>
<p>记得设置容器中<code>root</code>用户的密码：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure></div>

<p>升级或重新安装可能会覆盖某些配置，因此你可能需要备份原有的配置文件并重新应用它们：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/ssh/sshd_config /etc/ssh/sshd_config.backup</span><br></pre></td></tr></table></figure></div>

<p>编辑新的配置文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></div>

<h2 id="3-7-重启-SSH-服务"><a href="#3-7-重启-SSH-服务" class="headerlink" title="3.7 重启 SSH 服务"></a>3.7 重启 SSH 服务</h2><p>安装完成后，需要重新启动 SSH 服务来应用新版本：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart ssh</span><br></pre></td></tr></table></figure></div>

<p>你可以通过以下命令确认 SSH 版本是否更新：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -V</span><br></pre></td></tr></table></figure></div>

<p>环境中可能没有<code>systemctl</code>，先检查下是否有<code>service</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> service</span><br></pre></td></tr></table></figure></div>

<p>可以用<code>service</code>来控制：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service ssh status</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service ssh start</span><br></pre></td></tr></table></figure></div>

<p>如果<code>service</code>不可用，可以直接运行<code>sshd</code>来启动：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> sshd</span><br></pre></td></tr></table></figure></div>
<p>运行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/sbin/sshd</span><br></pre></td></tr></table></figure></div>
<h3 id="8-防止自动更新覆盖"><a href="#8-防止自动更新覆盖" class="headerlink" title="8. 防止自动更新覆盖"></a>8. 防止自动更新覆盖</h3><p>默认情况下，Ubuntu 使用 <code>apt</code> 来自动管理和更新软件包。如果你不希望 OpenSSH 通过 <code>apt</code> 更新被覆盖，可以将其锁定：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-mark hold openssh-server openssh-client</span><br></pre></td></tr></table></figure></div>

<p>这样可以确保 <code>apt</code> 不会自动更新 OpenSSH。</p>
<h2 id="3-9-验证安装"><a href="#3-9-验证安装" class="headerlink" title="3.9 验证安装"></a>3.9 验证安装</h2><p>最后，确保 OpenSSH 正常运行。通过以下命令验证 SSH 是否正在监听：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status ssh</span><br></pre></td></tr></table></figure></div>

<p>没有<code>systemctl</code>的话，可以用：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | grep sshd</span><br></pre></td></tr></table></figure></div>

<p>输出是这样表示启动成功：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">root       10106  0.0  0.0   8784  4508 ?        Ss   06:28   0:00 sshd: /usr/sbin/sshd [listener] 0 of 10-100 startups</span><br><span class="line">root       10150  0.0  0.0   3528  1872 pts/0    S+   06:32   0:00 grep --color=auto sshd</span><br></pre></td></tr></table></figure></div>

<h2 id="3-8-连接"><a href="#3-8-连接" class="headerlink" title="3.8 连接"></a>3.8 连接</h2><p>在宿主机中测试：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@&lt;container_IP&gt;</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>双系统时间配置（Linux + Windows）</title>
    <url>/2024/12/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><ol>
<li><p>将系统的实时时钟（RTC，Real-Time Clock）设置为本地时间：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> timedatectl set-local-rtc 1 --adjust-system-clock</span><br></pre></td></tr></table></figure></div>
<p>RTC 是计算机主板上的一个小型电池供电的时钟，即使在计算机关闭时也会继续运行。参数 <code>1</code> 表示启用本地时间，而 <code>0</code> 表示协调世界时（UTC）。<code>--adjust-system-clock</code> 参数的作用是在设置 RTC 为本地时间的同时，自动调整系统时钟以匹配 RTC 时间。这可以确保系统时间和 RTC 时间同步。</p>
</li>
<li><p>检验，询当前的系统时间和日期设置：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl</span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 如何安装 qtile 平铺窗口</title>
    <url>/2024/12/14/%E5%AE%89%E8%A3%85qtile/</url>
    <content><![CDATA[<h1 id="1-安装-qtile"><a href="#1-安装-qtile" class="headerlink" title="1.安装 qtile"></a>1.安装 qtile</h1><ol>
<li><p>安装<code>qtile</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S arcolinux-qtile-distrotube-git</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>拉取<code>arco-qtile</code>仓库：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/arcolinuxd/arco-qtile.git</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>依次执行里面的脚本（下面这个是美化脚本）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./100-display-manager-and-desktop.sh</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>其它脚本按需选择执行，然后重启系统即可。</p>
<p>效果图如下：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/12/14/wKk2ijJC79qxm8h.png"
                      alt="PixPin_2024-12-14_21-10-14.png"
                ><figcaption>PixPin_2024-12-14_21-10-14.png</figcaption></figure></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 如何安装 KDE 桌面</title>
    <url>/2024/12/05/%E5%AE%89%E8%A3%85KDE%E6%A1%8C%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="1-安装教程"><a href="#1-安装教程" class="headerlink" title="1.安装教程"></a>1.安装教程</h1><p>前提是确保驱动已经安装好，并且执行了<code>pacman -Syu</code>进行更新。</p>
<p>安装<code>x11</code>会话服务：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S xorg-server</span><br></pre></td></tr></table></figure></div>

<p>安装<code>wayland</code>会话（如果只使用<code>x11</code>的话，可以不选）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S wayland xorg-xwayland</span><br></pre></td></tr></table></figure></div>
<p>不过我建议还是使用<code>wayland</code>会话好，我感觉<code>x11</code>的会话有点卡。</p>
<p>安装 plasma 桌面：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S plasma-desktop</span><br></pre></td></tr></table></figure></div>

<p>安装必要的组件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S sddm dolphin konsole</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>sddm</code>： <code>KDE</code> 推荐的显示管理器，如果只使用<code>x11</code>会话，可以不安装，如果要使用<code>wayland</code>会话，则建议安装好。</li>
<li><code>dolphin</code>：文件管理器。</li>
<li><code>konsole</code>：终端模拟器。</li>
</ul>
<p>启动<code>sddm</code>服务：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now sddm.service</span><br></pre></td></tr></table></figure></div>
<p>如何更改<code>sddm</code>主题，请查看<code>Arch Wiki</code>：<a class="link"   href="https://wiki.archlinuxcn.org/wiki/SDDM" >SDDM<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>安装音频服务：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S pipewire pipewire-pulse pipewire-alsa</span><br></pre></td></tr></table></figure></div>
<p>对<code>jack</code>应用有要求的话，可以再安装个<code>pipewire-jack</code>。</p>
<p>安装<code>kde</code>音频控件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S plasma-pa</span><br></pre></td></tr></table></figure></div>

<p>启动音频服务：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl --user <span class="built_in">enable</span> pipewire pipewire-pulse</span><br><span class="line">systemctl --user start pipewire pipewire-pulse</span><br></pre></td></tr></table></figure></div>

<p>确保安装后运行以下命令检查未使用的包然后并删除：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Qtdq | <span class="built_in">sudo</span> pacman -Rns -</span><br></pre></td></tr></table></figure></div>

<p>还有需要的在这基础上补充就行了，这里只提供桌面环境必要的安装。可以参考<code>Arch Wiki</code>：<a class="link"   href="https://wiki.archlinuxcn.org/wiki/KDE" >KDE<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="2-针对-x11-的补充"><a href="#2-针对-x11-的补充" class="headerlink" title="2.针对 x11 的补充"></a>2.针对 x11 的补充</h1><p>如果只用<code>x11</code>的话，又不想安装<code>sddm</code>，可以通过下面的方式启动<code>x11</code>会话窗口。默认是先进入的<code>tty</code>。</p>
<p>创建<code>~/.xinitrc</code>文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/.xinitrc</span><br></pre></td></tr></table></figure></div>

<p>添加下面内容（直接执行该命令）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;exec startplasma-x11&quot;</span> &gt; ~/.xinitrc</span><br></pre></td></tr></table></figure></div>

<p>好像可以添加<code>exec startplasma-wayland</code>来使得启动的会话窗口是<code>wayland</code>，但是没成功。</p>
<p>然后启动<code>plasma</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">startx</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建代理池</title>
    <url>/2024/10/17/%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="1-开源项目地址"><a href="#1-开源项目地址" class="headerlink" title="1.开源项目地址"></a>1.开源项目地址</h1><p><a class="link"   href="https://github.com/jhao104/proxy_pool" >jhao104&#x2F;proxy_pool<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="2-搭建教程"><a href="#2-搭建教程" class="headerlink" title="2.搭建教程"></a>2.搭建教程</h1><h2 id="2-1-通过-docker-搭建"><a href="#2-1-通过-docker-搭建" class="headerlink" title="2.1 通过 docker 搭建"></a>2.1 通过 docker 搭建</h2><p>默认情况下，Docker 容器彼此无法通过<code>localhost</code>访问，需要通过容器的网络名称（桥接网络：<code>bridge</code>）进行通信。因此可以将<code>proxy_pool</code>和<code>redis</code>放在同一个 Docker 网络中。</p>
<p><strong>创建网络：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create mynetwork</span><br></pre></td></tr></table></figure></div>

<p><strong>运行 Redis 容器并加入网络：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis --network=mynetwork -p 6379:6379 redis:latest</span><br></pre></td></tr></table></figure></div>

<p><strong>运行<code>proxy_pool</code>容器并连接 Redis：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name proxy_pool --network=mynetwork --<span class="built_in">env</span> DB_CONN=redis://redis:6379/0 -p 5010:5010 jhao104/proxy_pool:latest</span><br></pre></td></tr></table></figure></div>

<p><strong>查看日志信息：</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs proxy_pool</span><br></pre></td></tr></table></figure></div>

<p>这是很就能看到获得的代理地址和端口。如下面所示：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">2024-10-17 21:03:11,533 fetch.py[line:39] INFO ProxyFetch - freeProxy11: 39.175.75.144:30001     ok</span><br><span class="line">2024-10-17 21:03:11,533 fetch.py[line:39] INFO ProxyFetch - freeProxy11: 8.221.141.88:8443       ok</span><br><span class="line">2024-10-17 21:03:11,533 fetch.py[line:39] INFO ProxyFetch - freeProxy11: 47.109.83.196:8080      ok</span><br><span class="line">2024-10-17 21:03:11,533 fetch.py[line:39] INFO ProxyFetch - freeProxy11: 185.49.31.205:8080      ok</span><br><span class="line">2024-10-17 21:03:11,533 fetch.py[line:39] INFO ProxyFetch - freeProxy11: 72.10.160.171:11319     ok</span><br><span class="line">2024-10-17 21:03:11,533 fetch.py[line:39] INFO ProxyFetch - freeProxy11: 102.213.146.206:8080    ok</span><br><span class="line">2024-10-17 21:03:11,533 fetch.py[line:39] INFO ProxyFetch - freeProxy11: 79.110.202.131:8081     ok</span><br><span class="line">2024-10-17 21:03:11,533 fetch.py[line:39] INFO ProxyFetch - freeProxy11: 178.130.40.231:8080     ok</span><br><span class="line">2024-10-17 21:03:11,533 fetch.py[line:39] INFO ProxyFetch - freeProxy11: 188.166.56.246:80       ok</span><br></pre></td></tr></table></figure></div>

<h1 id="3-使用教程"><a href="#3-使用教程" class="headerlink" title="3.使用教程"></a>3.使用教程</h1><p>代码示例：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_proxy</span>():</span><br><span class="line">    <span class="keyword">return</span> requests.get(<span class="string">&quot;http://127.0.0.1:5010/get/&quot;</span>).json()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_proxy</span>(<span class="params">proxy</span>):</span><br><span class="line">    requests.get(<span class="string">&quot;http://127.0.0.1:5010/delete/?proxy=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(proxy))</span><br><span class="line"></span><br><span class="line"><span class="comment"># your spider code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getHtml</span>(<span class="params">url, headers</span>):</span><br><span class="line">    retry_count = <span class="number">15</span></span><br><span class="line">    <span class="keyword">while</span> retry_count &gt; <span class="number">0</span>:</span><br><span class="line">        proxy = get_proxy().get(<span class="string">&quot;proxy&quot;</span>)</span><br><span class="line">        proxies = &#123;</span><br><span class="line">            <span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://&quot;</span> + proxy,</span><br><span class="line">            <span class="string">&quot;https&quot;</span>: <span class="string">&quot;http://&quot;</span> + proxy</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">print</span>(get_proxy().get(<span class="string">&quot;proxy&quot;</span>))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 使用代理访问</span></span><br><span class="line">            html = requests.get(url=url, headers=headers, proxies=proxies, timeout=<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> html.text</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            retry_count -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 删除代理池中代理</span></span><br><span class="line">            delete_proxy(proxy)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://wuhan.anjuke.com/sale/p1/?from=esf_list&quot;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>:  <span class="string">&quot;your-cookie&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html_data = getHtml(url, headers)</span><br><span class="line"><span class="built_in">print</span>(html_data)</span><br></pre></td></tr></table></figure></div>
<p><code>getHtml</code>函数中，会通过<code>while</code>循环来切换代理<code>ip</code>和<code>port</code>，直到请求成功，然后返回出结果并退出循环。</p>
]]></content>
      <categories>
        <category>Python技巧</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>编译 ElaWidgetTools 库</title>
    <url>/2025/01/03/%E7%BC%96%E8%AF%91ElaWidgetTools/</url>
    <content><![CDATA[<h1 id="1-库下载"><a href="#1-库下载" class="headerlink" title="1.库下载"></a>1.库下载</h1><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Liniyous/ElaWidgetTools.git</span><br></pre></td></tr></table></figure></div>

<h1 id="2-编译库"><a href="#2-编译库" class="headerlink" title="2.编译库"></a>2.编译库</h1><h2 id="2-1-修改点"><a href="#2-1-修改点" class="headerlink" title="2.1 修改点"></a>2.1 修改点</h2><p>主要修改的点是<code>./CMakeLists.txt</code>、<code>./src/CMakeLists.txt</code>和<code>./example/CMakeLists.txt</code>。</p>
<ul>
<li>修改<code>./src/CMakeLists.txt</code>中的安装路径：<br>原来的：<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(CMAKE_INSTALL_PREFIX <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">install</span> CACHE PATH <span class="string">&quot;Installation path&quot;</span> FORCE)</span><br></pre></td></tr></table></figure></div>
改为：<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(CMAKE_INSTALL_PREFIX /opt/ElaWidgetTools CACHE PATH <span class="string">&quot;Installation path&quot;</span> FORCE)</span><br></pre></td></tr></table></figure></div>
当然，这部分其实可以不改，我是习惯把第三方库安装<code>/opt</code>目录下，这样可以用<code>find_package</code>直接找到。</li>
</ul>
<p>原来的：</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line">configure_package_config_file(</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="variable">$&#123;EXPORT_NAME&#125;</span>Config.cmake.in</span><br><span class="line">    <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;EXPORT_NAME&#125;</span>Config.cmake</span><br><span class="line">    INSTALL_DESTINATION lib/cmake</span><br><span class="line">    PATH_VARS INCLUDE_DIRS LIBRARIES LIB_DIR</span><br><span class="line">    INSTALL_PREFIX <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">    FILES <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;EXPORT_NAME&#125;</span>Config.cmake <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;EXPORT_NAME&#125;</span>ConfigVersion.cmake DESTINATION lib/cmake</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
<p>改为：</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line">configure_package_config_file(</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="variable">$&#123;EXPORT_NAME&#125;</span>Config.cmake.in</span><br><span class="line">    <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;EXPORT_NAME&#125;</span>Config.cmake</span><br><span class="line">    INSTALL_DESTINATION lib/cmake/<span class="variable">$&#123;EXPORT_NAME&#125;</span> <span class="comment"># 修改这里</span></span><br><span class="line">    PATH_VARS INCLUDE_DIRS LIBRARIES LIB_DIR</span><br><span class="line">    INSTALL_PREFIX <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">    FILES <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;EXPORT_NAME&#125;</span>Config.cmake <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;EXPORT_NAME&#125;</span>ConfigVersion.cmake DESTINATION lib/cmake/<span class="variable">$&#123;EXPORT_NAME&#125;</span> <span class="comment"># 修改这里</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>然后就可以开始编译并安装了。</p>
<h2 id="2-2-编译测试案例"><a href="#2-2-编译测试案例" class="headerlink" title="2.2 编译测试案例"></a>2.2 编译测试案例</h2><ul>
<li><p>修改<code>./CMakeLists.txt</code>：<br>添加：</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(BUILD_ELAWIDGETTOOLS_EXAMPLE <span class="keyword">TRUE</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>修改<code>./example/CMakeLists.txt</code>：<br>注释掉下面这行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list(APPEND CMAKE_PREFIX_PATH $&#123;CMAKE_SOURCE_DIR&#125;/install/lib/cmake/)</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h1 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3.使用示例"></a>3.使用示例</h1><p><code>CMakeLists.txt</code>中查找<code>ElaWidgetTools</code>库编写：</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(ElaWidgetTools REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;ElaWidgetTools include dirs: $&#123;ELAWIDGETTOOLS_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;ElaWidgetTools libraries: $&#123;ELAWIDGETTOOLS_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;ElaWidgetTools library dirs: $&#123;ELAWIDGETTOOLS_LIBRARY_DIRS&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">test</span>.out PUBLIC</span><br><span class="line">    <span class="variable">$&#123;ELAWIDGETTOOLS_INCLUDE_DIRS&#125;</span></span><br><span class="line">    <span class="comment"># ExamplePage</span></span><br><span class="line">    <span class="comment"># ModelView</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_directories</span>(<span class="keyword">test</span>.out PUBLIC</span><br><span class="line">    <span class="variable">$&#123;ELAWIDGETTOOLS_LIBRARY_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">test</span>.out PRIVATE</span><br><span class="line">    <span class="variable">$&#123;ELAWIDGETTOOLS_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
<p><strong>注意：</strong> <code>target_link_directories</code>是必需的，当<code>ElaWidgetTools</code>库文件所在的目录不在系统默认路径或未被<code>find_package</code>自动添加时。这一步骤告诉链接器正确的库文件路径，是解决链接失败的关键。主要原因是<code>ElaWidgetTools</code> 没有正确安装到<code>CMAKE_INSTALL_PREFIX</code>或其路径未被标准化造成的。一般比较正规的标准库（比如<code>Qt</code>、<code>PCL</code>、<code>OpenCV</code>）是不需要额外写<code>target_link_directories</code>的，因为链接器路径会自动设置。</p>
<p>不添加的话就会报这种错误：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/sbin/ld: cannot find -lElaWidgetTools: No such file or directory</span><br><span class="line">clang++: error: linker <span class="built_in">command</span> failed with <span class="built_in">exit</span> code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure></div>
<p>遇到相似的错误可以试着采用这种方式来解决下。</p>
<p>当然，也可以写成：</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(ElaWidgetTools REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">test</span>.out PUBLIC</span><br><span class="line">    <span class="variable">$&#123;ELAWIDGETTOOLS_INCLUDE_DIRS&#125;</span></span><br><span class="line">    <span class="comment"># ExamplePage</span></span><br><span class="line">    <span class="comment"># ModelView</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">test</span>.out PRIVATE</span><br><span class="line">    <span class="variable">$&#123;ELAWIDGETTOOLS_LIBRARY_DIRS&#125;</span>/libElaWidgetTools.so</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>测试代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ElaApplication.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ElaWindow.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    ElaApplication::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">init</span>();</span><br><span class="line">    ElaWindow w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>编译 PCL 库</title>
    <url>/2024/12/04/%E7%BC%96%E8%AF%91pcl/</url>
    <content><![CDATA[<h1 id="1-环境说明"><a href="#1-环境说明" class="headerlink" title="1.环境说明"></a>1.环境说明</h1><p>编译环境是 Docker 的 Ubuntu 镜像所运行的容器实例，版本是<code>&quot;DockerVersion&quot;: &quot;24.0.7&quot;</code>。运行好容器后，第一部还是要配置好镜像源（或网络代理），然后更新软件仓库。</p>
<h1 id="2-安装编译工具和依赖"><a href="#2-安装编译工具和依赖" class="headerlink" title="2.安装编译工具和依赖"></a>2.安装编译工具和依赖</h1><p>创建安装脚本：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> install_build_pcl.sh</span><br></pre></td></tr></table></figure></div>

<p>把下面内容添加到脚本中：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新包列表并升级系统</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;更新系统并安装依赖项...&quot;</span></span><br><span class="line">apt update</span><br><span class="line">apt upgrade -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装基础工具和开发环境</span></span><br><span class="line">apt install -y build-essential cmake git pkg-config clang clangd wget unzip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装系统库和硬件相关支持</span></span><br><span class="line">apt install -y \</span><br><span class="line">  libusb-1.0-0-dev \</span><br><span class="line">  libusb-dev \</span><br><span class="line">  libudev-dev \</span><br><span class="line">  freeglut3-dev \</span><br><span class="line">  libxmu-dev \</span><br><span class="line">  libxi-dev \</span><br><span class="line">  libomp-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装数学和算法库</span></span><br><span class="line">apt install -y \</span><br><span class="line">  libboost-all-dev \</span><br><span class="line">  libeigen3-dev \</span><br><span class="line">  libflann-dev \</span><br><span class="line">  libqhull-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 VTK（可视化工具包）</span></span><br><span class="line">apt install -y libvtk9-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装图形和 GUI 相关支持</span></span><br><span class="line">apt install -y \</span><br><span class="line">  libglew-dev \</span><br><span class="line">  libglfw3-dev \</span><br><span class="line">  libpng-dev \</span><br><span class="line">  libjpeg-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Qt5 和 OpenGL 支持</span></span><br><span class="line">apt install -y \</span><br><span class="line">  qtbase5-dev \</span><br><span class="line">  qttools5-dev-tools \</span><br><span class="line">  libqt5opengl5-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装点云处理相关库</span></span><br><span class="line">apt install -y \</span><br><span class="line">  libopenni-dev \</span><br><span class="line">  libopenni2-dev \</span><br><span class="line">  libpcap-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装额外的开发工具（可选）</span></span><br><span class="line"><span class="comment"># apt install -y \</span></span><br><span class="line"><span class="comment">#   mono-complete \</span></span><br><span class="line"><span class="comment">#   openjdk-8-jdk \</span></span><br><span class="line"><span class="comment">#   openjdk-8-jre \</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 安装中文包</span></span><br><span class="line">apt install -y language-pack-zh-hans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理无用的包缓存</span></span><br><span class="line">apt autoremove -y</span><br><span class="line">apt clean</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;所有依赖项已安装！准备编译 PCL。&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>将脚本更改为可执行权限：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x install_build_pcl.sh</span><br></pre></td></tr></table></figure></div>

<p>最好配置下<code>.bashrc</code>，增加代理和中文字体配置。在<code>.bashrc</code>中添加如下内容：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中文字体设置</span></span><br><span class="line"><span class="built_in">export</span> LANG=zh_CN.UTF-8</span><br><span class="line"><span class="built_in">export</span> LANGUAGE=zh_CN:zh</span><br><span class="line"><span class="built_in">export</span> LC_ALL=zh_CN.UTF-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># where proxy</span></span><br><span class="line"><span class="function"><span class="title">proxy</span></span>()&#123;</span><br><span class="line">  <span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line">  <span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;HTTP Proxy on&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># where noproxy</span></span><br><span class="line"><span class="function"><span class="title">noproxy</span></span>()&#123;</span><br><span class="line">  <span class="built_in">unset</span> http_proxy</span><br><span class="line">  <span class="built_in">unset</span> https_proxy</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;HTTP Proxy off&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="3-编译"><a href="#3-编译" class="headerlink" title="3.编译"></a>3.编译</h1><h2 id="3-1-拉取源码"><a href="#3-1-拉取源码" class="headerlink" title="3.1 拉取源码"></a>3.1 拉取源码</h2><p>可以通过<code>git</code>拉取最新源码：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/PointCloudLibrary/pcl.git</span><br></pre></td></tr></table></figure></div>

<p>也可以直接下载指定版本源码并进行解压，比如<code>1.14</code>版的：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://github.com/PointCloudLibrary/pcl/releases/download/pcl-1.14.1/source.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压到当前目录</span></span><br><span class="line">unzip source.zip -d .</span><br></pre></td></tr></table></figure></div>

<h2 id="3-2-开始编译"><a href="#3-2-开始编译" class="headerlink" title="3.2 开始编译"></a>3.2 开始编译</h2><ol>
<li><strong>方式一：安装到默认目录</strong></li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> pcl</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line">make -j8</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>方式二：安装到指定目录</strong></li>
</ol>
<p>比如要安装到<code>/opt/pcl_1.14/</code>目录下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /opt/pcl_1.14</span><br></pre></td></tr></table></figure></div>

<p>开始编译：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> pcl</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line">cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/pcl_1.14</span><br><span class="line"></span><br><span class="line">make -j8</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div>

<p>这种方式会把<code>pcl</code>安装到<code>/opt/pcl_1.14</code>下，<code>pcl_1.14</code>下的文件结构是这样的：</p>
<div class="code-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">├── include</span><br><span class="line">├── lib</span><br><span class="line">└── share</span><br><span class="line"></span><br><span class="line">5 directories, 0 files</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
</search>
